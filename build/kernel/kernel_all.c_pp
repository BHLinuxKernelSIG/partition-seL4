# 1 "kernel_all.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




/* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */

/* glibc's intent is to support the IEC 559 math functionality, real
   and complex.  If the GCC (4.9 and later) predefined macros
   specifying compiler intent are available, use them to determine
   whether the overall intent is to support these features; otherwise,
   presume an older compiler has intent to support these features and
   define these macros by default.  */
# 52 "/usr/include/stdc-predef.h" 3 4
/* wchar_t uses ISO/IEC 10646 (2nd ed., published 2011-03-15) /
   Unicode 6.0.  */


/* We do not support C11 <threads.h>.  */
# 1 "<command-line>" 2
# 1 "kernel_all.c"
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/basic_types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;

typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef signed long long int64_t;
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/stdint.h" 2
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/basic_types.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/types.h" 2

typedef uint32_t word_t;
typedef uint32_t vptr_t;
typedef uint32_t paddr_t;
typedef uint32_t pptr_t;

typedef uint32_t dev_id_t;
typedef uint32_t cpu_id_t;
typedef uint32_t node_id_t;
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/basic_types.h" 2

enum _bool {
    false = 0,
    true = 1
};
typedef uint32_t bool_t;

typedef struct region {
    pptr_t start;
    pptr_t end;
} region_t;

typedef struct p_region {
    paddr_t start;
    paddr_t end;
} p_region_t;

typedef struct v_region {
    vptr_t start;
    vptr_t end;
} v_region_t;
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/compound_types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/compound_types.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




/* Compile-time configuration parameters. Might be set by the build system. */


# 1 "/home/kq/Sources/RefOS_x86/include/generated/autoconf.h" 1
/*
 * Automatically generated C config: don't edit
 * Project Configuration
 * Wed Apr 27 17:43:44 2016
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 2


/* size of the initial thread's root CNode (2^x slots, x >= 4) */




/* number of timer ticks until a thread is preempted  */




/* the number of scheduler domains */




/* number of priorities per domain */




/* maximum number of caps that can be created in one retype invocation */




/* maximum number of iterations until we preempt a delete/revoke invocation */




/* address range to flush per preemption work unit */




/* maximum number of untyped caps in bootinfo */
/* WARNING: must match value in libsel4! */
/* CONSTRAINT: (5 * CONFIG_MAX_NUM_BOOTINFO_UNTYPED_CAPS) <= 4036 */




/* length of a timer tick in ms  */




/* Configuration parameters below are for IA-32 only. */

/* maximum number of nodes supported (if 1, a uniprocessor version is compiled) */




/* maximum number of memory regions to report in bootinfo */




/* maximum number of IOMMU RMRR entries we can record while ACPI parsing */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 45 "/home/kq/Sources/RefOS_x86/kernel/include/util.h"
/* Borrowed from linux/include/linux/compiler.h */







/* need that for compiling with c99 instead of gnu99 */


/* Evaluate a Kconfig-provided configuration setting at compile-time. */






/** MODIFIES:
    FNSPEC
        halt_spec: "\<Gamma> \<turnstile> {} Call halt_'proc {}"
*/
void halt(void) __attribute__((__noreturn__));
void memzero(void *s, unsigned int n);
void *memset(void *s, unsigned int c, unsigned int n);
void *memcpy(void* ptr_dst, const void* ptr_src, unsigned int n);
int strncmp(const char *s1, const char *s2, int n);
int __attribute__((__const__)) char_to_int(char c);
int __attribute__((__pure__)) str_to_int(const char* str);
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 2
# 1 "./api/types_gen.h" 1



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 2



void _fail(
    const char* str,
    const char* file,
    unsigned int line,
    const char* function
) __attribute__((__noreturn__));



void _assert_fail(
    const char* assertion,
    const char* file,
    unsigned int line,
    const char* function
) __attribute__((__noreturn__));




/* Create an assert that will trigger a compile error if it fails. */
# 5 "./api/types_gen.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 6 "./api/types_gen.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 7 "./api/types_gen.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 8 "./api/types_gen.h" 2
struct message_info {
    uint32_t words[1];
};
typedef struct message_info message_info_t;

static inline message_info_t __attribute__((__const__))
message_info_new(uint32_t msgLabel, uint32_t msgCapsUnwrapped, uint32_t msgExtraCaps, uint32_t msgLength) {
    message_info_t message_info;

    message_info.words[0] = 0;

    /* fail if user has passed bits that we will override */
    if(!((msgLabel & ~0xffffful) == ((0 && (msgLabel & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(msgLabel & ~0xffffful) == ((0 && (msgLabel & (1ul << 31))) ? 0x0 : 0)", "./api/types_gen.h", 20, __FUNCTION__);
    message_info.words[0] |= (msgLabel & 0xffffful) << 12;
    /* fail if user has passed bits that we will override */
    if(!((msgCapsUnwrapped & ~0x7ul) == ((0 && (msgCapsUnwrapped & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(msgCapsUnwrapped & ~0x7ul) == ((0 && (msgCapsUnwrapped & (1ul << 31))) ? 0x0 : 0)", "./api/types_gen.h", 23, __FUNCTION__);
    message_info.words[0] |= (msgCapsUnwrapped & 0x7ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!((msgExtraCaps & ~0x3ul) == ((0 && (msgExtraCaps & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(msgExtraCaps & ~0x3ul) == ((0 && (msgExtraCaps & (1ul << 31))) ? 0x0 : 0)", "./api/types_gen.h", 26, __FUNCTION__);
    message_info.words[0] |= (msgExtraCaps & 0x3ul) << 7;
    /* fail if user has passed bits that we will override */
    if(!((msgLength & ~0x7ful) == ((0 && (msgLength & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(msgLength & ~0x7ful) == ((0 && (msgLength & (1ul << 31))) ? 0x0 : 0)", "./api/types_gen.h", 29, __FUNCTION__);
    message_info.words[0] |= (msgLength & 0x7ful) << 0;

    return message_info;
}

static inline uint32_t __attribute__((__const__))
message_info_get_msgLabel(message_info_t message_info) {
    uint32_t ret;
    ret = (message_info.words[0] & 0xfffff000ul) >> 12;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
message_info_get_msgCapsUnwrapped(message_info_t message_info) {
    uint32_t ret;
    ret = (message_info.words[0] & 0xe00ul) >> 9;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline message_info_t __attribute__((__const__))
message_info_set_msgCapsUnwrapped(message_info_t message_info, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xe00 >> 9) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xe00 >> 9) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./api/types_gen.h", 60, __FUNCTION__);
    message_info.words[0] &= ~0xe00ul;
    message_info.words[0] |= (v << 9) & 0xe00ul;
    return message_info;
}

static inline uint32_t __attribute__((__const__))
message_info_get_msgExtraCaps(message_info_t message_info) {
    uint32_t ret;
    ret = (message_info.words[0] & 0x180ul) >> 7;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline message_info_t __attribute__((__const__))
message_info_set_msgExtraCaps(message_info_t message_info, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x180 >> 7) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x180 >> 7) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./api/types_gen.h", 80, __FUNCTION__);
    message_info.words[0] &= ~0x180ul;
    message_info.words[0] |= (v << 7) & 0x180ul;
    return message_info;
}

static inline uint32_t __attribute__((__const__))
message_info_get_msgLength(message_info_t message_info) {
    uint32_t ret;
    ret = (message_info.words[0] & 0x7ful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline message_info_t __attribute__((__const__))
message_info_set_msgLength(message_info_t message_info, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x7f >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x7f >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./api/types_gen.h", 100, __FUNCTION__);
    message_info.words[0] &= ~0x7ful;
    message_info.words[0] |= (v << 0) & 0x7ful;
    return message_info;
}

struct cap_rights {
    uint32_t words[1];
};
typedef struct cap_rights cap_rights_t;

static inline cap_rights_t __attribute__((__const__))
cap_rights_new(uint32_t capAllowGrant, uint32_t capAllowRead, uint32_t capAllowWrite) {
    cap_rights_t cap_rights;

    cap_rights.words[0] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capAllowGrant & ~0x1ul) == ((0 && (capAllowGrant & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capAllowGrant & ~0x1ul) == ((0 && (capAllowGrant & (1ul << 31))) ? 0x0 : 0)", "./api/types_gen.h", 118, __FUNCTION__);
    cap_rights.words[0] |= (capAllowGrant & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((capAllowRead & ~0x1ul) == ((0 && (capAllowRead & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capAllowRead & ~0x1ul) == ((0 && (capAllowRead & (1ul << 31))) ? 0x0 : 0)", "./api/types_gen.h", 121, __FUNCTION__);
    cap_rights.words[0] |= (capAllowRead & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((capAllowWrite & ~0x1ul) == ((0 && (capAllowWrite & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capAllowWrite & ~0x1ul) == ((0 && (capAllowWrite & (1ul << 31))) ? 0x0 : 0)", "./api/types_gen.h", 124, __FUNCTION__);
    cap_rights.words[0] |= (capAllowWrite & 0x1ul) << 0;

    return cap_rights;
}

static inline uint32_t __attribute__((__const__))
cap_rights_get_capAllowGrant(cap_rights_t cap_rights) {
    uint32_t ret;
    ret = (cap_rights.words[0] & 0x4ul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_rights_get_capAllowRead(cap_rights_t cap_rights) {
    uint32_t ret;
    ret = (cap_rights.words[0] & 0x2ul) >> 1;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_rights_get_capAllowWrite(cap_rights_t cap_rights) {
    uint32_t ret;
    ret = (cap_rights.words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




typedef enum api_object {
    seL4_UntypedObject,
    seL4_TCBObject,
    seL4_EndpointObject,
    seL4_AsyncEndpointObject,
    seL4_CapTableObject,
    seL4_NonArchObjectTypeCount,
} seL4_ObjectType;

typedef uint32_t api_object_t;
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/api/types.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/api/types.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/api/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */





# 1 "/home/kq/Sources/RefOS_x86/include/generated/autoconf.h" 1
/*
 * Automatically generated C config: don't edit
 * Project Configuration
 * Wed Apr 27 17:43:44 2016
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/api/objecttype.h" 2


typedef enum _object {
    seL4_IA32_4K = seL4_NonArchObjectTypeCount,
    seL4_IA32_LargePage,
    seL4_IA32_PageTableObject,
    seL4_IA32_PageDirectoryObject,
    seL4_IA32_PDPTObject,

    seL4_IA32_IOPageTableObject,


    seL4_IA32_VCPUObject,
    seL4_IA32_EPTPageDirectoryPointerTableObject,
    seL4_IA32_EPTPageDirectoryObject,
    seL4_IA32_EPTPageTableObject,

    seL4_ObjectTypeCount
} seL4_ArchObjectType;
typedef uint32_t object_t;

/* Previously frame types were explcitly 4K and 4M. If not PAE
 * we assume legacy environment and emulate old definitions */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/api/types.h" 2
# 19 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/constants.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */






enum priorityConstants {
    seL4_InvalidPrio = -1,
    seL4_MinPrio = 0,
    seL4_MaxPrio = 256 - 1
};

/* message_info_t defined in api/types.bf */

enum seL4_MsgLimits {
    seL4_MsgLengthBits = 7,
    seL4_MsgExtraCapBits = 2
};

enum {
    seL4_MsgMaxLength = 120,
};
# 21 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 2

/* cap_rights_t defined in api/types.bf */

typedef uint32_t prio_t;
typedef uint32_t dom_t;
typedef uint32_t cptr_t;

struct cap_transfer {
    cptr_t ctReceiveRoot;
    cptr_t ctReceiveIndex;
    unsigned int ctReceiveDepth;
};
typedef struct cap_transfer cap_transfer_t;

enum ctLimits {
    capTransferDataSize = 3
};

static inline cap_rights_t __attribute__((__const__))
rightsFromWord(word_t w)
{
    cap_rights_t cap_rights;

    cap_rights.words[0] = w;
    return cap_rights;
}

static inline word_t __attribute__((__const__))
wordFromRights(cap_rights_t cap_rights)
{
    return cap_rights.words[0] & ((1ul<<(3))-1ul);
}

static inline cap_transfer_t __attribute__((__pure__))
capTransferFromWords(word_t *wptr)
{
    cap_transfer_t transfer;

    transfer.ctReceiveRoot = (cptr_t)wptr[0];
    transfer.ctReceiveIndex = (cptr_t)wptr[1];
    transfer.ctReceiveDepth = (unsigned int)wptr[2];
    return transfer;
}

static inline message_info_t __attribute__((__const__))
messageInfoFromWord_raw(word_t w)
{
    message_info_t mi;

    mi.words[0] = w;
    return mi;
}

static inline message_info_t __attribute__((__const__))
messageInfoFromWord(word_t w)
{
    message_info_t mi;
    word_t len;

    mi.words[0] = w;

    len = message_info_get_msgLength(mi);
    if (len > seL4_MsgMaxLength) {
        mi = message_info_set_msgLength(mi, seL4_MsgMaxLength);
    }

    return mi;
}

static inline message_info_t __attribute__((__const__))
messageInfoFromWord_nolencheck(word_t w)
{
    message_info_t mi;
    mi.words[0] = w;
    return mi;
}

static inline word_t __attribute__((__const__))
wordFromMessageInfo(message_info_t mi)
{
    return mi.words[0];
}
# 111 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h"
/*
 * Print to serial a message helping userspace programmers to determine why the
 * kernel is not performing their requested operation.
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/compound_types.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 2
# 1 "./arch/object/structures_gen.h" 1



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 5 "./arch/object/structures_gen.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 6 "./arch/object/structures_gen.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 7 "./arch/object/structures_gen.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 8 "./arch/object/structures_gen.h" 2
struct io_port_capdata {
    uint32_t words[1];
};
typedef struct io_port_capdata io_port_capdata_t;

static inline uint32_t __attribute__((__const__))
io_port_capdata_get_firstPort(io_port_capdata_t io_port_capdata) {
    uint32_t ret;
    ret = (io_port_capdata.words[0] & 0xffff0000ul) >> 16;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
io_port_capdata_get_lastPort(io_port_capdata_t io_port_capdata) {
    uint32_t ret;
    ret = (io_port_capdata.words[0] & 0xfffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct ept_pte {
    uint32_t words[2];
};
typedef struct ept_pte ept_pte_t;

static inline ept_pte_t __attribute__((__const__))
ept_pte_new(uint32_t page_base_address, uint32_t avl_cte_depth, uint32_t ignore_pat, uint32_t type, uint32_t execute, uint32_t write, uint32_t read) {
    ept_pte_t ept_pte;

    ept_pte.words[0] = 0;
    ept_pte.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((page_base_address & ~0xfffff000ul) == ((0 && (page_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(page_base_address & ~0xfffff000ul) == ((0 && (page_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 48, __FUNCTION__);
    ept_pte.words[0] |= (page_base_address & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((avl_cte_depth & ~0x3ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl_cte_depth & ~0x3ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 51, __FUNCTION__);
    ept_pte.words[0] |= (avl_cte_depth & 0x3ul) << 10;
    /* fail if user has passed bits that we will override */
    if(!((ignore_pat & ~0x1ul) == ((0 && (ignore_pat & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(ignore_pat & ~0x1ul) == ((0 && (ignore_pat & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 54, __FUNCTION__);
    ept_pte.words[0] |= (ignore_pat & 0x1ul) << 6;
    /* fail if user has passed bits that we will override */
    if(!((type & ~0x7ul) == ((0 && (type & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(type & ~0x7ul) == ((0 && (type & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 57, __FUNCTION__);
    ept_pte.words[0] |= (type & 0x7ul) << 3;
    /* fail if user has passed bits that we will override */
    if(!((execute & ~0x1ul) == ((0 && (execute & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(execute & ~0x1ul) == ((0 && (execute & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 60, __FUNCTION__);
    ept_pte.words[0] |= (execute & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 63, __FUNCTION__);
    ept_pte.words[0] |= (write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 66, __FUNCTION__);
    ept_pte.words[0] |= (read & 0x1ul) << 0;

    return ept_pte;
}

static inline uint32_t __attribute__((__pure__))
ept_pte_ptr_get_page_base_address(ept_pte_t *ept_pte_ptr) {
    uint32_t ret;
    ret = (ept_pte_ptr->words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
ept_pte_ptr_get_avl_cte_depth(ept_pte_t *ept_pte_ptr) {
    uint32_t ret;
    ret = (ept_pte_ptr->words[0] & 0xc00ul) >> 10;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct pte {
    uint32_t words[1];
};
typedef struct pte pte_t;

static inline pte_t __attribute__((__const__))
pte_new(uint32_t page_base_address, uint32_t avl_cte_depth, uint32_t global, uint32_t pat, uint32_t dirty, uint32_t accessed, uint32_t cache_disabled, uint32_t write_through, uint32_t super_user, uint32_t read_write, uint32_t present) {
    pte_t pte;

    pte.words[0] = 0;

    /* fail if user has passed bits that we will override */
    if(!((page_base_address & ~0xfffff000ul) == ((0 && (page_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(page_base_address & ~0xfffff000ul) == ((0 && (page_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 106, __FUNCTION__);
    pte.words[0] |= (page_base_address & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 109, __FUNCTION__);
    pte.words[0] |= (avl_cte_depth & 0x7ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!((global & ~0x1ul) == ((0 && (global & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(global & ~0x1ul) == ((0 && (global & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 112, __FUNCTION__);
    pte.words[0] |= (global & 0x1ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!((pat & ~0x1ul) == ((0 && (pat & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(pat & ~0x1ul) == ((0 && (pat & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 115, __FUNCTION__);
    pte.words[0] |= (pat & 0x1ul) << 7;
    /* fail if user has passed bits that we will override */
    if(!((dirty & ~0x1ul) == ((0 && (dirty & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(dirty & ~0x1ul) == ((0 && (dirty & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 118, __FUNCTION__);
    pte.words[0] |= (dirty & 0x1ul) << 6;
    /* fail if user has passed bits that we will override */
    if(!((accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 121, __FUNCTION__);
    pte.words[0] |= (accessed & 0x1ul) << 5;
    /* fail if user has passed bits that we will override */
    if(!((cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 124, __FUNCTION__);
    pte.words[0] |= (cache_disabled & 0x1ul) << 4;
    /* fail if user has passed bits that we will override */
    if(!((write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 127, __FUNCTION__);
    pte.words[0] |= (write_through & 0x1ul) << 3;
    /* fail if user has passed bits that we will override */
    if(!((super_user & ~0x1ul) == ((0 && (super_user & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(super_user & ~0x1ul) == ((0 && (super_user & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 130, __FUNCTION__);
    pte.words[0] |= (super_user & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((read_write & ~0x1ul) == ((0 && (read_write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read_write & ~0x1ul) == ((0 && (read_write & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 133, __FUNCTION__);
    pte.words[0] |= (read_write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 136, __FUNCTION__);
    pte.words[0] |= (present & 0x1ul) << 0;

    return pte;
}

static inline void
pte_ptr_new(pte_t *pte_ptr, uint32_t page_base_address, uint32_t avl_cte_depth, uint32_t global, uint32_t pat, uint32_t dirty, uint32_t accessed, uint32_t cache_disabled, uint32_t write_through, uint32_t super_user, uint32_t read_write, uint32_t present) {
    pte_ptr->words[0] = 0;

    /* fail if user has passed bits that we will override */
    if(!((page_base_address & ~0xfffff000ul) == ((0 && (page_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(page_base_address & ~0xfffff000ul) == ((0 && (page_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 147, __FUNCTION__);
    pte_ptr->words[0] |= (page_base_address & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 150, __FUNCTION__);
    pte_ptr->words[0] |= (avl_cte_depth & 0x7ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!((global & ~0x1ul) == ((0 && (global & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(global & ~0x1ul) == ((0 && (global & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 153, __FUNCTION__);
    pte_ptr->words[0] |= (global & 0x1ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!((pat & ~0x1ul) == ((0 && (pat & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(pat & ~0x1ul) == ((0 && (pat & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 156, __FUNCTION__);
    pte_ptr->words[0] |= (pat & 0x1ul) << 7;
    /* fail if user has passed bits that we will override */
    if(!((dirty & ~0x1ul) == ((0 && (dirty & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(dirty & ~0x1ul) == ((0 && (dirty & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 159, __FUNCTION__);
    pte_ptr->words[0] |= (dirty & 0x1ul) << 6;
    /* fail if user has passed bits that we will override */
    if(!((accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 162, __FUNCTION__);
    pte_ptr->words[0] |= (accessed & 0x1ul) << 5;
    /* fail if user has passed bits that we will override */
    if(!((cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 165, __FUNCTION__);
    pte_ptr->words[0] |= (cache_disabled & 0x1ul) << 4;
    /* fail if user has passed bits that we will override */
    if(!((write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 168, __FUNCTION__);
    pte_ptr->words[0] |= (write_through & 0x1ul) << 3;
    /* fail if user has passed bits that we will override */
    if(!((super_user & ~0x1ul) == ((0 && (super_user & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(super_user & ~0x1ul) == ((0 && (super_user & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 171, __FUNCTION__);
    pte_ptr->words[0] |= (super_user & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((read_write & ~0x1ul) == ((0 && (read_write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read_write & ~0x1ul) == ((0 && (read_write & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 174, __FUNCTION__);
    pte_ptr->words[0] |= (read_write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 177, __FUNCTION__);
    pte_ptr->words[0] |= (present & 0x1ul) << 0;
}

static inline uint32_t __attribute__((__const__))
pte_get_page_base_address(pte_t pte) {
    uint32_t ret;
    ret = (pte.words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pte_ptr_get_page_base_address(pte_t *pte_ptr) {
    uint32_t ret;
    ret = (pte_ptr->words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pte_ptr_get_avl_cte_depth(pte_t *pte_ptr) {
    uint32_t ret;
    ret = (pte_ptr->words[0] & 0xe00ul) >> 9;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
pte_get_super_user(pte_t pte) {
    uint32_t ret;
    ret = (pte.words[0] & 0x4ul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
pte_get_present(pte_t pte) {
    uint32_t ret;
    ret = (pte.words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pte_ptr_get_present(pte_t *pte_ptr) {
    uint32_t ret;
    ret = (pte_ptr->words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct ept_pml4e {
    uint32_t words[2];
};
typedef struct ept_pml4e ept_pml4e_t;

static inline ept_pml4e_t __attribute__((__const__))
ept_pml4e_new(uint32_t pdpt_base_address, uint32_t execute, uint32_t write, uint32_t read) {
    ept_pml4e_t ept_pml4e;

    ept_pml4e.words[0] = 0;
    ept_pml4e.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((pdpt_base_address & ~0xfffff000ul) == ((0 && (pdpt_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(pdpt_base_address & ~0xfffff000ul) == ((0 && (pdpt_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 260, __FUNCTION__);
    ept_pml4e.words[0] |= (pdpt_base_address & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((execute & ~0x1ul) == ((0 && (execute & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(execute & ~0x1ul) == ((0 && (execute & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 263, __FUNCTION__);
    ept_pml4e.words[0] |= (execute & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 266, __FUNCTION__);
    ept_pml4e.words[0] |= (write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 269, __FUNCTION__);
    ept_pml4e.words[0] |= (read & 0x1ul) << 0;

    return ept_pml4e;
}

struct ept_pdpte {
    uint32_t words[2];
};
typedef struct ept_pdpte ept_pdpte_t;

static inline ept_pdpte_t __attribute__((__const__))
ept_pdpte_new(uint32_t pd_base_address, uint32_t avl_cte_depth, uint32_t execute, uint32_t write, uint32_t read) {
    ept_pdpte_t ept_pdpte;

    ept_pdpte.words[0] = 0;
    ept_pdpte.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((pd_base_address & ~0xfffff000ul) == ((0 && (pd_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(pd_base_address & ~0xfffff000ul) == ((0 && (pd_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 288, __FUNCTION__);
    ept_pdpte.words[0] |= (pd_base_address & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 291, __FUNCTION__);
    ept_pdpte.words[0] |= (avl_cte_depth & 0x7ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!((execute & ~0x1ul) == ((0 && (execute & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(execute & ~0x1ul) == ((0 && (execute & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 294, __FUNCTION__);
    ept_pdpte.words[0] |= (execute & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 297, __FUNCTION__);
    ept_pdpte.words[0] |= (write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 300, __FUNCTION__);
    ept_pdpte.words[0] |= (read & 0x1ul) << 0;

    return ept_pdpte;
}

static inline uint32_t __attribute__((__pure__))
ept_pdpte_ptr_get_pd_base_address(ept_pdpte_t *ept_pdpte_ptr) {
    uint32_t ret;
    ret = (ept_pdpte_ptr->words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
ept_pdpte_ptr_get_avl_cte_depth(ept_pdpte_t *ept_pdpte_ptr) {
    uint32_t ret;
    ret = (ept_pdpte_ptr->words[0] & 0xe00ul) >> 9;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
ept_pdpte_ptr_get_read(ept_pdpte_t *ept_pdpte_ptr) {
    uint32_t ret;
    ret = (ept_pdpte_ptr->words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct async_endpoint {
    uint32_t words[4];
};
typedef struct async_endpoint async_endpoint_t;

static inline uint32_t __attribute__((__pure__))
async_endpoint_ptr_get_aepBoundTCB(async_endpoint_t *async_endpoint_ptr) {
    uint32_t ret;
    ret = (async_endpoint_ptr->words[3] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
async_endpoint_ptr_set_aepBoundTCB(async_endpoint_t *async_endpoint_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xfffffff0 << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xfffffff0 << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 358, __FUNCTION__);
    async_endpoint_ptr->words[3] &= ~0xfffffff0ul;
    async_endpoint_ptr->words[3] |= (v >> 0) & 0xfffffff0;
}

static inline uint32_t __attribute__((__pure__))
async_endpoint_ptr_get_aepMsgIdentifier(async_endpoint_t *async_endpoint_ptr) {
    uint32_t ret;
    ret = (async_endpoint_ptr->words[2] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
async_endpoint_ptr_set_aepMsgIdentifier(async_endpoint_t *async_endpoint_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xffffffff >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xffffffff >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 377, __FUNCTION__);
    async_endpoint_ptr->words[2] &= ~0xfffffffful;
    async_endpoint_ptr->words[2] |= (v << 0) & 0xffffffff;
}

static inline uint32_t __attribute__((__pure__))
async_endpoint_ptr_get_aepQueue_head(async_endpoint_t *async_endpoint_ptr) {
    uint32_t ret;
    ret = (async_endpoint_ptr->words[1] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
async_endpoint_ptr_set_aepQueue_head(async_endpoint_t *async_endpoint_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xfffffff0 << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xfffffff0 << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 396, __FUNCTION__);
    async_endpoint_ptr->words[1] &= ~0xfffffff0ul;
    async_endpoint_ptr->words[1] |= (v >> 0) & 0xfffffff0;
}

static inline uint32_t __attribute__((__pure__))
async_endpoint_ptr_get_aepQueue_tail(async_endpoint_t *async_endpoint_ptr) {
    uint32_t ret;
    ret = (async_endpoint_ptr->words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
async_endpoint_ptr_set_aepQueue_tail(async_endpoint_t *async_endpoint_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xfffffff0 << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xfffffff0 << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 415, __FUNCTION__);
    async_endpoint_ptr->words[0] &= ~0xfffffff0ul;
    async_endpoint_ptr->words[0] |= (v >> 0) & 0xfffffff0;
}

static inline uint32_t __attribute__((__pure__))
async_endpoint_ptr_get_state(async_endpoint_t *async_endpoint_ptr) {
    uint32_t ret;
    ret = (async_endpoint_ptr->words[0] & 0x3ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
async_endpoint_ptr_set_state(async_endpoint_t *async_endpoint_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x3 >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x3 >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 434, __FUNCTION__);
    async_endpoint_ptr->words[0] &= ~0x3ul;
    async_endpoint_ptr->words[0] |= (v << 0) & 0x3;
}

struct apic_icr2 {
    uint32_t words[1];
};
typedef struct apic_icr2 apic_icr2_t;

static inline apic_icr2_t __attribute__((__const__))
apic_icr2_new(uint32_t dest) {
    apic_icr2_t apic_icr2;

    apic_icr2.words[0] = 0;

    /* fail if user has passed bits that we will override */
    if(!((dest & ~0xfful) == ((0 && (dest & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(dest & ~0xfful) == ((0 && (dest & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 451, __FUNCTION__);
    apic_icr2.words[0] |= (dest & 0xfful) << 24;

    return apic_icr2;
}

struct thread_state {
    uint32_t words[3];
};
typedef struct thread_state thread_state_t;

static inline uint32_t __attribute__((__pure__))
thread_state_ptr_get_blockingIPCBadge(thread_state_t *thread_state_ptr) {
    uint32_t ret;
    ret = (thread_state_ptr->words[2] & 0xfffffff0ul) >> 4;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_blockingIPCBadge(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xfffffff0 >> 4) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xfffffff0 >> 4) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 476, __FUNCTION__);
    thread_state_ptr->words[2] &= ~0xfffffff0ul;
    thread_state_ptr->words[2] |= (v << 4) & 0xfffffff0;
}

static inline uint32_t __attribute__((__pure__))
thread_state_ptr_get_blockingIPCCanGrant(thread_state_t *thread_state_ptr) {
    uint32_t ret;
    ret = (thread_state_ptr->words[2] & 0x8ul) >> 3;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_blockingIPCCanGrant(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x8 >> 3) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x8 >> 3) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 495, __FUNCTION__);
    thread_state_ptr->words[2] &= ~0x8ul;
    thread_state_ptr->words[2] |= (v << 3) & 0x8;
}

static inline uint32_t __attribute__((__pure__))
thread_state_ptr_get_blockingIPCIsCall(thread_state_t *thread_state_ptr) {
    uint32_t ret;
    ret = (thread_state_ptr->words[2] & 0x4ul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_blockingIPCIsCall(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x4 >> 2) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x4 >> 2) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 514, __FUNCTION__);
    thread_state_ptr->words[2] &= ~0x4ul;
    thread_state_ptr->words[2] |= (v << 2) & 0x4;
}

static inline uint32_t __attribute__((__const__))
thread_state_get_blockingIPCDiminishCaps(thread_state_t thread_state) {
    uint32_t ret;
    ret = (thread_state.words[2] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
thread_state_ptr_get_blockingIPCDiminishCaps(thread_state_t *thread_state_ptr) {
    uint32_t ret;
    ret = (thread_state_ptr->words[2] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_blockingIPCDiminishCaps(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x1 >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x1 >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 544, __FUNCTION__);
    thread_state_ptr->words[2] &= ~0x1ul;
    thread_state_ptr->words[2] |= (v << 0) & 0x1;
}

static inline uint32_t __attribute__((__const__))
thread_state_get_tcbQueued(thread_state_t thread_state) {
    uint32_t ret;
    ret = (thread_state.words[1] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_tcbQueued(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x1 >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x1 >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 563, __FUNCTION__);
    thread_state_ptr->words[1] &= ~0x1ul;
    thread_state_ptr->words[1] |= (v << 0) & 0x1;
}

static inline uint32_t __attribute__((__pure__))
thread_state_ptr_get_blockingIPCEndpoint(thread_state_t *thread_state_ptr) {
    uint32_t ret;
    ret = (thread_state_ptr->words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_blockingIPCEndpoint(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xfffffff0 << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xfffffff0 << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 582, __FUNCTION__);
    thread_state_ptr->words[0] &= ~0xfffffff0ul;
    thread_state_ptr->words[0] |= (v >> 0) & 0xfffffff0;
}

static inline uint32_t __attribute__((__const__))
thread_state_get_tsType(thread_state_t thread_state) {
    uint32_t ret;
    ret = (thread_state.words[0] & 0xful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
thread_state_ptr_get_tsType(thread_state_t *thread_state_ptr) {
    uint32_t ret;
    ret = (thread_state_ptr->words[0] & 0xful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_tsType(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xf >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xf >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 612, __FUNCTION__);
    thread_state_ptr->words[0] &= ~0xful;
    thread_state_ptr->words[0] |= (v << 0) & 0xf;
}

struct apic_base_msr {
    uint32_t words[1];
};
typedef struct apic_base_msr apic_base_msr_t;

static inline uint32_t __attribute__((__const__))
apic_base_msr_get_base_addr(apic_base_msr_t apic_base_msr) {
    uint32_t ret;
    ret = (apic_base_msr.words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
apic_base_msr_get_enabled(apic_base_msr_t apic_base_msr) {
    uint32_t ret;
    ret = (apic_base_msr.words[0] & 0x800ul) >> 11;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct tss {
    uint32_t words[26];
};
typedef struct tss tss_t;

static inline void
tss_ptr_new(tss_t *tss_ptr, uint32_t io_map_base, uint32_t trap, uint32_t sel_ldt, uint32_t gs, uint32_t fs, uint32_t ds, uint32_t ss, uint32_t cs, uint32_t es, uint32_t edi, uint32_t esi, uint32_t ebp, uint32_t esp, uint32_t ebx, uint32_t edx, uint32_t ecx, uint32_t eax, uint32_t eflags, uint32_t eip, uint32_t cr3, uint32_t ss2, uint32_t esp2, uint32_t ss1, uint32_t esp1, uint32_t ss0, uint32_t esp0, uint32_t prev_task) {
    tss_ptr->words[0] = 0;
    tss_ptr->words[1] = 0;
    tss_ptr->words[2] = 0;
    tss_ptr->words[3] = 0;
    tss_ptr->words[4] = 0;
    tss_ptr->words[5] = 0;
    tss_ptr->words[6] = 0;
    tss_ptr->words[7] = 0;
    tss_ptr->words[8] = 0;
    tss_ptr->words[9] = 0;
    tss_ptr->words[10] = 0;
    tss_ptr->words[11] = 0;
    tss_ptr->words[12] = 0;
    tss_ptr->words[13] = 0;
    tss_ptr->words[14] = 0;
    tss_ptr->words[15] = 0;
    tss_ptr->words[16] = 0;
    tss_ptr->words[17] = 0;
    tss_ptr->words[18] = 0;
    tss_ptr->words[19] = 0;
    tss_ptr->words[20] = 0;
    tss_ptr->words[21] = 0;
    tss_ptr->words[22] = 0;
    tss_ptr->words[23] = 0;
    tss_ptr->words[24] = 0;
    tss_ptr->words[25] = 0;

    /* fail if user has passed bits that we will override */
    if(!((io_map_base & ~0xfffful) == ((0 && (io_map_base & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(io_map_base & ~0xfffful) == ((0 && (io_map_base & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 679, __FUNCTION__);
    tss_ptr->words[25] |= (io_map_base & 0xfffful) << 16;
    /* fail if user has passed bits that we will override */
    if(!((trap & ~0x1ul) == ((0 && (trap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(trap & ~0x1ul) == ((0 && (trap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 682, __FUNCTION__);
    tss_ptr->words[25] |= (trap & 0x1ul) << 0;
    /* fail if user has passed bits that we will override */
    if(!((sel_ldt & ~0xfffful) == ((0 && (sel_ldt & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(sel_ldt & ~0xfffful) == ((0 && (sel_ldt & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 685, __FUNCTION__);
    tss_ptr->words[24] |= (sel_ldt & 0xfffful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((gs & ~0xfffful) == ((0 && (gs & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(gs & ~0xfffful) == ((0 && (gs & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 688, __FUNCTION__);
    tss_ptr->words[23] |= (gs & 0xfffful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((fs & ~0xfffful) == ((0 && (fs & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(fs & ~0xfffful) == ((0 && (fs & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 691, __FUNCTION__);
    tss_ptr->words[22] |= (fs & 0xfffful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((ds & ~0xfffful) == ((0 && (ds & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(ds & ~0xfffful) == ((0 && (ds & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 694, __FUNCTION__);
    tss_ptr->words[21] |= (ds & 0xfffful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((ss & ~0xfffful) == ((0 && (ss & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(ss & ~0xfffful) == ((0 && (ss & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 697, __FUNCTION__);
    tss_ptr->words[20] |= (ss & 0xfffful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((cs & ~0xfffful) == ((0 && (cs & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cs & ~0xfffful) == ((0 && (cs & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 700, __FUNCTION__);
    tss_ptr->words[19] |= (cs & 0xfffful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((es & ~0xfffful) == ((0 && (es & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(es & ~0xfffful) == ((0 && (es & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 703, __FUNCTION__);
    tss_ptr->words[18] |= (es & 0xfffful) << 0;
    tss_ptr->words[17] |= edi << 0;
    tss_ptr->words[16] |= esi << 0;
    tss_ptr->words[15] |= ebp << 0;
    tss_ptr->words[14] |= esp << 0;
    tss_ptr->words[13] |= ebx << 0;
    tss_ptr->words[12] |= edx << 0;
    tss_ptr->words[11] |= ecx << 0;
    tss_ptr->words[10] |= eax << 0;
    tss_ptr->words[9] |= eflags << 0;
    tss_ptr->words[8] |= eip << 0;
    tss_ptr->words[7] |= cr3 << 0;
    /* fail if user has passed bits that we will override */
    if(!((ss2 & ~0xfffful) == ((0 && (ss2 & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(ss2 & ~0xfffful) == ((0 && (ss2 & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 717, __FUNCTION__);
    tss_ptr->words[6] |= (ss2 & 0xfffful) << 0;
    tss_ptr->words[5] |= esp2 << 0;
    /* fail if user has passed bits that we will override */
    if(!((ss1 & ~0xfffful) == ((0 && (ss1 & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(ss1 & ~0xfffful) == ((0 && (ss1 & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 721, __FUNCTION__);
    tss_ptr->words[4] |= (ss1 & 0xfffful) << 0;
    tss_ptr->words[3] |= esp1 << 0;
    /* fail if user has passed bits that we will override */
    if(!((ss0 & ~0xfffful) == ((0 && (ss0 & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(ss0 & ~0xfffful) == ((0 && (ss0 & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 725, __FUNCTION__);
    tss_ptr->words[2] |= (ss0 & 0xfffful) << 0;
    tss_ptr->words[1] |= esp0 << 0;
    /* fail if user has passed bits that we will override */
    if(!((prev_task & ~0xfffful) == ((0 && (prev_task & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(prev_task & ~0xfffful) == ((0 && (prev_task & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 729, __FUNCTION__);
    tss_ptr->words[0] |= (prev_task & 0xfffful) << 0;
}

static inline void
tss_ptr_set_esp0(tss_t *tss_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xffffffff >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xffffffff >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 736, __FUNCTION__);
    tss_ptr->words[1] &= ~0xfffffffful;
    tss_ptr->words[1] |= (v << 0) & 0xffffffff;
}

struct mdb_node {
    uint32_t words[2];
};
typedef struct mdb_node mdb_node_t;

static inline mdb_node_t __attribute__((__const__))
mdb_node_new(uint32_t cdtRight_, uint32_t cdtDepth, uint32_t cdtLeft_, uint32_t cdtLevel) {
    mdb_node_t mdb_node;

    mdb_node.words[0] = 0;
    mdb_node.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((cdtRight_ & ~0x7fffffful) == ((0 && (cdtRight_ & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cdtRight_ & ~0x7fffffful) == ((0 && (cdtRight_ & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 754, __FUNCTION__);
    mdb_node.words[1] |= (cdtRight_ & 0x7fffffful) << 5;
    /* fail if user has passed bits that we will override */
    if(!((cdtDepth & ~0x1ful) == ((0 && (cdtDepth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cdtDepth & ~0x1ful) == ((0 && (cdtDepth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 757, __FUNCTION__);
    mdb_node.words[1] |= (cdtDepth & 0x1ful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((cdtLeft_ & ~0x7fffffful) == ((0 && (cdtLeft_ & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cdtLeft_ & ~0x7fffffful) == ((0 && (cdtLeft_ & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 760, __FUNCTION__);
    mdb_node.words[0] |= (cdtLeft_ & 0x7fffffful) << 5;
    /* fail if user has passed bits that we will override */
    if(!((cdtLevel & ~0x1ful) == ((0 && (cdtLevel & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cdtLevel & ~0x1ful) == ((0 && (cdtLevel & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 763, __FUNCTION__);
    mdb_node.words[0] |= (cdtLevel & 0x1ful) << 0;

    return mdb_node;
}

static inline uint32_t __attribute__((__const__))
mdb_node_get_cdtRight_(mdb_node_t mdb_node) {
    uint32_t ret;
    ret = (mdb_node.words[1] & 0xffffffe0ul) >> 5;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
mdb_node_ptr_set_cdtRight_(mdb_node_t *mdb_node_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xffffffe0 >> 5) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xffffffe0 >> 5) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 783, __FUNCTION__);
    mdb_node_ptr->words[1] &= ~0xffffffe0ul;
    mdb_node_ptr->words[1] |= (v << 5) & 0xffffffe0;
}

static inline uint32_t __attribute__((__const__))
mdb_node_get_cdtDepth(mdb_node_t mdb_node) {
    uint32_t ret;
    ret = (mdb_node.words[1] & 0x1ful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
mdb_node_get_cdtLeft_(mdb_node_t mdb_node) {
    uint32_t ret;
    ret = (mdb_node.words[0] & 0xffffffe0ul) >> 5;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
mdb_node_ptr_set_cdtLeft_(mdb_node_t *mdb_node_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xffffffe0 >> 5) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xffffffe0 >> 5) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 813, __FUNCTION__);
    mdb_node_ptr->words[0] &= ~0xffffffe0ul;
    mdb_node_ptr->words[0] |= (v << 5) & 0xffffffe0;
}

static inline uint32_t __attribute__((__const__))
mdb_node_get_cdtLevel(mdb_node_t mdb_node) {
    uint32_t ret;
    ret = (mdb_node.words[0] & 0x1ful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
mdb_node_ptr_set_cdtLevel(mdb_node_t *mdb_node_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x1f >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x1f >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 832, __FUNCTION__);
    mdb_node_ptr->words[0] &= ~0x1ful;
    mdb_node_ptr->words[0] |= (v << 0) & 0x1f;
}

struct apic_lvt {
    uint32_t words[1];
};
typedef struct apic_lvt apic_lvt_t;

static inline apic_lvt_t __attribute__((__const__))
apic_lvt_new(uint32_t timer_mode, uint32_t masked, uint32_t trigger_mode, uint32_t remote_irr, uint32_t pin_polarity, uint32_t delivery_status, uint32_t delivery_mode, uint32_t vector) {
    apic_lvt_t apic_lvt;

    apic_lvt.words[0] = 0;

    /* fail if user has passed bits that we will override */
    if(!((timer_mode & ~0x3ul) == ((0 && (timer_mode & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(timer_mode & ~0x3ul) == ((0 && (timer_mode & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 849, __FUNCTION__);
    apic_lvt.words[0] |= (timer_mode & 0x3ul) << 17;
    /* fail if user has passed bits that we will override */
    if(!((masked & ~0x1ul) == ((0 && (masked & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(masked & ~0x1ul) == ((0 && (masked & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 852, __FUNCTION__);
    apic_lvt.words[0] |= (masked & 0x1ul) << 16;
    /* fail if user has passed bits that we will override */
    if(!((trigger_mode & ~0x1ul) == ((0 && (trigger_mode & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(trigger_mode & ~0x1ul) == ((0 && (trigger_mode & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 855, __FUNCTION__);
    apic_lvt.words[0] |= (trigger_mode & 0x1ul) << 15;
    /* fail if user has passed bits that we will override */
    if(!((remote_irr & ~0x1ul) == ((0 && (remote_irr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(remote_irr & ~0x1ul) == ((0 && (remote_irr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 858, __FUNCTION__);
    apic_lvt.words[0] |= (remote_irr & 0x1ul) << 14;
    /* fail if user has passed bits that we will override */
    if(!((pin_polarity & ~0x1ul) == ((0 && (pin_polarity & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(pin_polarity & ~0x1ul) == ((0 && (pin_polarity & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 861, __FUNCTION__);
    apic_lvt.words[0] |= (pin_polarity & 0x1ul) << 13;
    /* fail if user has passed bits that we will override */
    if(!((delivery_status & ~0x1ul) == ((0 && (delivery_status & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(delivery_status & ~0x1ul) == ((0 && (delivery_status & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 864, __FUNCTION__);
    apic_lvt.words[0] |= (delivery_status & 0x1ul) << 12;
    /* fail if user has passed bits that we will override */
    if(!((delivery_mode & ~0x7ul) == ((0 && (delivery_mode & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(delivery_mode & ~0x7ul) == ((0 && (delivery_mode & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 867, __FUNCTION__);
    apic_lvt.words[0] |= (delivery_mode & 0x7ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!((vector & ~0xfful) == ((0 && (vector & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(vector & ~0xfful) == ((0 && (vector & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 870, __FUNCTION__);
    apic_lvt.words[0] |= (vector & 0xfful) << 0;

    return apic_lvt;
}

struct cnode_capdata {
    uint32_t words[1];
};
typedef struct cnode_capdata cnode_capdata_t;

static inline uint32_t __attribute__((__const__))
cnode_capdata_get_guard(cnode_capdata_t cnode_capdata) {
    uint32_t ret;
    ret = (cnode_capdata.words[0] & 0x3ffff00ul) >> 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cnode_capdata_get_guardSize(cnode_capdata_t cnode_capdata) {
    uint32_t ret;
    ret = (cnode_capdata.words[0] & 0xf8ul) >> 3;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct vm_attributes {
    uint32_t words[1];
};
typedef struct vm_attributes vm_attributes_t;

static inline uint32_t __attribute__((__const__))
vm_attributes_get_ia32PATBit(vm_attributes_t vm_attributes) {
    uint32_t ret;
    ret = (vm_attributes.words[0] & 0x4ul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
vm_attributes_get_ia32PCDBit(vm_attributes_t vm_attributes) {
    uint32_t ret;
    ret = (vm_attributes.words[0] & 0x2ul) >> 1;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
vm_attributes_get_ia32PWTBit(vm_attributes_t vm_attributes) {
    uint32_t ret;
    ret = (vm_attributes.words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct endpoint {
    uint32_t words[4];
};
typedef struct endpoint endpoint_t;

static inline uint32_t __attribute__((__pure__))
endpoint_ptr_get_epQueue_head(endpoint_t *endpoint_ptr) {
    uint32_t ret;
    ret = (endpoint_ptr->words[1] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
endpoint_ptr_set_epQueue_head(endpoint_t *endpoint_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xfffffff0 << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xfffffff0 << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 960, __FUNCTION__);
    endpoint_ptr->words[1] &= ~0xfffffff0ul;
    endpoint_ptr->words[1] |= (v >> 0) & 0xfffffff0;
}

static inline uint32_t __attribute__((__pure__))
endpoint_ptr_get_epQueue_tail(endpoint_t *endpoint_ptr) {
    uint32_t ret;
    ret = (endpoint_ptr->words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
endpoint_ptr_set_epQueue_tail(endpoint_t *endpoint_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0xfffffff0 << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xfffffff0 << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 979, __FUNCTION__);
    endpoint_ptr->words[0] &= ~0xfffffff0ul;
    endpoint_ptr->words[0] |= (v >> 0) & 0xfffffff0;
}

static inline uint32_t __attribute__((__pure__))
endpoint_ptr_get_state(endpoint_t *endpoint_ptr) {
    uint32_t ret;
    ret = (endpoint_ptr->words[0] & 0x3ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
endpoint_ptr_set_state(endpoint_t *endpoint_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x3 >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x3 >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 998, __FUNCTION__);
    endpoint_ptr->words[0] &= ~0x3ul;
    endpoint_ptr->words[0] |= (v << 0) & 0x3;
}

struct apic_svr {
    uint32_t words[1];
};
typedef struct apic_svr apic_svr_t;

static inline apic_svr_t __attribute__((__const__))
apic_svr_new(uint32_t focus_processor_chk, uint32_t enabled, uint32_t spurious_vector) {
    apic_svr_t apic_svr;

    apic_svr.words[0] = 0;

    /* fail if user has passed bits that we will override */
    if(!((focus_processor_chk & ~0x1ul) == ((0 && (focus_processor_chk & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(focus_processor_chk & ~0x1ul) == ((0 && (focus_processor_chk & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1015, __FUNCTION__);
    apic_svr.words[0] |= (focus_processor_chk & 0x1ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!((enabled & ~0x1ul) == ((0 && (enabled & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(enabled & ~0x1ul) == ((0 && (enabled & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1018, __FUNCTION__);
    apic_svr.words[0] |= (enabled & 0x1ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!((spurious_vector & ~0xfful) == ((0 && (spurious_vector & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(spurious_vector & ~0xfful) == ((0 && (spurious_vector & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1021, __FUNCTION__);
    apic_svr.words[0] |= (spurious_vector & 0xfful) << 0;

    return apic_svr;
}

struct io_space_capdata {
    uint32_t words[1];
};
typedef struct io_space_capdata io_space_capdata_t;

static inline uint32_t __attribute__((__const__))
io_space_capdata_get_domainID(io_space_capdata_t io_space_capdata) {
    uint32_t ret;
    ret = (io_space_capdata.words[0] & 0xffff0000ul) >> 16;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
io_space_capdata_get_PCIDevice(io_space_capdata_t io_space_capdata) {
    uint32_t ret;
    ret = (io_space_capdata.words[0] & 0xfffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct pdpte {
    uint32_t words[2];
};
typedef struct pdpte pdpte_t;

static inline pdpte_t __attribute__((__const__))
pdpte_new(uint32_t pd_base_address, uint32_t avl_cte_depth, uint32_t cache_disabled, uint32_t write_through, uint32_t present) {
    pdpte_t pdpte;

    pdpte.words[0] = 0;
    pdpte.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((pd_base_address & ~0xfffff000ul) == ((0 && (pd_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(pd_base_address & ~0xfffff000ul) == ((0 && (pd_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1067, __FUNCTION__);
    pdpte.words[0] |= (pd_base_address & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1070, __FUNCTION__);
    pdpte.words[0] |= (avl_cte_depth & 0x7ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!((cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1073, __FUNCTION__);
    pdpte.words[0] |= (cache_disabled & 0x1ul) << 4;
    /* fail if user has passed bits that we will override */
    if(!((write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1076, __FUNCTION__);
    pdpte.words[0] |= (write_through & 0x1ul) << 3;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1079, __FUNCTION__);
    pdpte.words[0] |= (present & 0x1ul) << 0;

    return pdpte;
}

static inline void
pdpte_ptr_new(pdpte_t *pdpte_ptr, uint32_t pd_base_address, uint32_t avl_cte_depth, uint32_t cache_disabled, uint32_t write_through, uint32_t present) {
    pdpte_ptr->words[0] = 0;
    pdpte_ptr->words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((pd_base_address & ~0xfffff000ul) == ((0 && (pd_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(pd_base_address & ~0xfffff000ul) == ((0 && (pd_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1091, __FUNCTION__);
    pdpte_ptr->words[0] |= (pd_base_address & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1094, __FUNCTION__);
    pdpte_ptr->words[0] |= (avl_cte_depth & 0x7ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!((cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1097, __FUNCTION__);
    pdpte_ptr->words[0] |= (cache_disabled & 0x1ul) << 4;
    /* fail if user has passed bits that we will override */
    if(!((write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1100, __FUNCTION__);
    pdpte_ptr->words[0] |= (write_through & 0x1ul) << 3;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1103, __FUNCTION__);
    pdpte_ptr->words[0] |= (present & 0x1ul) << 0;
}

static inline uint32_t __attribute__((__const__))
pdpte_get_pd_base_address(pdpte_t pdpte) {
    uint32_t ret;
    ret = (pdpte.words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pdpte_ptr_get_pd_base_address(pdpte_t *pdpte_ptr) {
    uint32_t ret;
    ret = (pdpte_ptr->words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pdpte_ptr_get_avl_cte_depth(pdpte_t *pdpte_ptr) {
    uint32_t ret;
    ret = (pdpte_ptr->words[0] & 0xe00ul) >> 9;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pdpte_ptr_get_present(pdpte_t *pdpte_ptr) {
    uint32_t ret;
    ret = (pdpte_ptr->words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct apic_version {
    uint32_t words[1];
};
typedef struct apic_version apic_version_t;

static inline uint32_t __attribute__((__const__))
apic_version_get_max_lvt_entry(apic_version_t apic_version) {
    uint32_t ret;
    ret = (apic_version.words[0] & 0xff0000ul) >> 16;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
apic_version_get_version(apic_version_t apic_version) {
    uint32_t ret;
    ret = (apic_version.words[0] & 0xfful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct ia32_pat_msr {
    uint32_t words[2];
};
typedef struct ia32_pat_msr ia32_pat_msr_t;

static inline void
ia32_pat_msr_ptr_set_pa4(ia32_pat_msr_t *ia32_pat_msr_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x7 >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x7 >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1186, __FUNCTION__);
    ia32_pat_msr_ptr->words[1] &= ~0x7ul;
    ia32_pat_msr_ptr->words[1] |= (v << 0) & 0x7;
}

static inline void
ia32_pat_msr_ptr_set_pa3(ia32_pat_msr_t *ia32_pat_msr_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x7000000 >> 24) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x7000000 >> 24) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1194, __FUNCTION__);
    ia32_pat_msr_ptr->words[0] &= ~0x7000000ul;
    ia32_pat_msr_ptr->words[0] |= (v << 24) & 0x7000000;
}

static inline void
ia32_pat_msr_ptr_set_pa2(ia32_pat_msr_t *ia32_pat_msr_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x70000 >> 16) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x70000 >> 16) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1202, __FUNCTION__);
    ia32_pat_msr_ptr->words[0] &= ~0x70000ul;
    ia32_pat_msr_ptr->words[0] |= (v << 16) & 0x70000;
}

static inline void
ia32_pat_msr_ptr_set_pa1(ia32_pat_msr_t *ia32_pat_msr_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x700 >> 8) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x700 >> 8) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1210, __FUNCTION__);
    ia32_pat_msr_ptr->words[0] &= ~0x700ul;
    ia32_pat_msr_ptr->words[0] |= (v << 8) & 0x700;
}

static inline void
ia32_pat_msr_ptr_set_pa0(ia32_pat_msr_t *ia32_pat_msr_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!(((~0x7 >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x7 >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1218, __FUNCTION__);
    ia32_pat_msr_ptr->words[0] &= ~0x7ul;
    ia32_pat_msr_ptr->words[0] |= (v << 0) & 0x7;
}

struct apic_icr1 {
    uint32_t words[1];
};
typedef struct apic_icr1 apic_icr1_t;

static inline apic_icr1_t __attribute__((__const__))
apic_icr1_new(uint32_t dest_shorthand, uint32_t trigger_mode, uint32_t level, uint32_t delivery_status, uint32_t dest_mode, uint32_t delivery_mode, uint32_t vector) {
    apic_icr1_t apic_icr1;

    apic_icr1.words[0] = 0;

    /* fail if user has passed bits that we will override */
    if(!((dest_shorthand & ~0x3ul) == ((0 && (dest_shorthand & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(dest_shorthand & ~0x3ul) == ((0 && (dest_shorthand & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1235, __FUNCTION__);
    apic_icr1.words[0] |= (dest_shorthand & 0x3ul) << 18;
    /* fail if user has passed bits that we will override */
    if(!((trigger_mode & ~0x1ul) == ((0 && (trigger_mode & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(trigger_mode & ~0x1ul) == ((0 && (trigger_mode & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1238, __FUNCTION__);
    apic_icr1.words[0] |= (trigger_mode & 0x1ul) << 15;
    /* fail if user has passed bits that we will override */
    if(!((level & ~0x1ul) == ((0 && (level & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(level & ~0x1ul) == ((0 && (level & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1241, __FUNCTION__);
    apic_icr1.words[0] |= (level & 0x1ul) << 14;
    /* fail if user has passed bits that we will override */
    if(!((delivery_status & ~0x1ul) == ((0 && (delivery_status & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(delivery_status & ~0x1ul) == ((0 && (delivery_status & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1244, __FUNCTION__);
    apic_icr1.words[0] |= (delivery_status & 0x1ul) << 12;
    /* fail if user has passed bits that we will override */
    if(!((dest_mode & ~0x1ul) == ((0 && (dest_mode & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(dest_mode & ~0x1ul) == ((0 && (dest_mode & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1247, __FUNCTION__);
    apic_icr1.words[0] |= (dest_mode & 0x1ul) << 11;
    /* fail if user has passed bits that we will override */
    if(!((delivery_mode & ~0x7ul) == ((0 && (delivery_mode & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(delivery_mode & ~0x7ul) == ((0 && (delivery_mode & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1250, __FUNCTION__);
    apic_icr1.words[0] |= (delivery_mode & 0x7ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!((vector & ~0xfful) == ((0 && (vector & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(vector & ~0xfful) == ((0 && (vector & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1253, __FUNCTION__);
    apic_icr1.words[0] |= (vector & 0xfful) << 0;

    return apic_icr1;
}

struct cap {
    uint32_t words[2];
};
typedef struct cap cap_t;

enum cap_tag {
    cap_null_cap = 0,
    cap_untyped_cap = 2,
    cap_endpoint_cap = 4,
    cap_async_endpoint_cap = 6,
    cap_reply_cap = 8,
    cap_cnode_cap = 10,
    cap_thread_cap = 12,
    cap_frame_cap = 1,
    cap_page_table_cap = 3,
    cap_page_directory_cap = 5,
    cap_pdpt_cap = 7,
    cap_io_page_table_cap = 9,
    cap_io_space_cap = 11,
    cap_ipi_cap = 13,
    cap_irq_control_cap = 14,
    cap_irq_handler_cap = 30,
    cap_zombie_cap = 46,
    cap_domain_cap = 62,
    cap_io_port_cap = 15,
    cap_vcpu_cap = 31,
    cap_ept_page_table_cap = 47,
    cap_ept_page_directory_pointer_table_cap = 63,
    cap_ept_page_directory_cap = 79
};
typedef enum cap_tag cap_tag_t;

static inline uint32_t __attribute__((__const__))
cap_get_capType(cap_t cap) {
    if ((cap.words[0] & 0xe) != 0xe)
        return (cap.words[0] >> 0) & 0xful;
    return (cap.words[0] >> 0) & 0xfful;
}

static inline int __attribute__((__const__))
cap_capType_equals(cap_t cap, uint32_t cap_type_tag) {
    if ((cap_type_tag & 0xe) != 0xe)
        return ((cap.words[0] >> 0) & 0xful) == cap_type_tag;
    return ((cap.words[0] >> 0) & 0xfful) == cap_type_tag;
}

static inline cap_t __attribute__((__const__))
cap_null_cap_new(void) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_null_cap & ~0xful) == ((0 && ((uint32_t)cap_null_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_null_cap & ~0xful) == ((0 && ((uint32_t)cap_null_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1313, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_null_cap & 0xful) << 0;

    return cap;
}

static inline cap_t __attribute__((__const__))
cap_untyped_cap_new(uint32_t capDeviceMemory, uint32_t capBlockSize, uint32_t capPtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capDeviceMemory & ~0x1ul) == ((0 && (capDeviceMemory & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capDeviceMemory & ~0x1ul) == ((0 && (capDeviceMemory & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1327, __FUNCTION__);
    cap.words[1] |= (capDeviceMemory & 0x1ul) << 5;
    /* fail if user has passed bits that we will override */
    if(!((capBlockSize & ~0x1ful) == ((0 && (capBlockSize & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capBlockSize & ~0x1ful) == ((0 && (capBlockSize & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1330, __FUNCTION__);
    cap.words[1] |= (capBlockSize & 0x1ful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((capPtr & ~0xfffffff0ul) == ((0 && (capPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPtr & ~0xfffffff0ul) == ((0 && (capPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1333, __FUNCTION__);
    cap.words[0] |= (capPtr & 0xfffffff0ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_untyped_cap & ~0xful) == ((0 && ((uint32_t)cap_untyped_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_untyped_cap & ~0xful) == ((0 && ((uint32_t)cap_untyped_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1336, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_untyped_cap & 0xful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_untyped_cap_get_capDeviceMemory(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_untyped_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_untyped_cap",
 "./arch/object/structures_gen.h"
# 1345 "./arch/object/structures_gen.h"
    ,
 1346
# 1345 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (cap.words[1] & 0x20ul) >> 5;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_untyped_cap_get_capBlockSize(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_untyped_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_untyped_cap",
 "./arch/object/structures_gen.h"
# 1359 "./arch/object/structures_gen.h"
    ,
 1360
# 1359 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (cap.words[1] & 0x1ful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
cap_untyped_cap_ptr_get_capBlockSize(cap_t *cap_ptr) {
    uint32_t ret;
    if(!(((cap_ptr->words[0] >> 0) & 0xf) == cap_untyped_cap)) _assert_fail("((cap_ptr->words[0] >> 0) & 0xf) == cap_untyped_cap",
 "./arch/object/structures_gen.h"
# 1373 "./arch/object/structures_gen.h"
    ,
 1374
# 1373 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (cap_ptr->words[1] & 0x1ful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_untyped_cap_get_capPtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_untyped_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_untyped_cap",
 "./arch/object/structures_gen.h"
# 1387 "./arch/object/structures_gen.h"
    ,
 1388
# 1387 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (cap.words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_endpoint_cap_new(uint32_t capEPBadge, uint32_t capCanGrant, uint32_t capCanSend, uint32_t capCanReceive, uint32_t capEPPtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capEPBadge & ~0xffffffful) == ((0 && (capEPBadge & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capEPBadge & ~0xffffffful) == ((0 && (capEPBadge & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1406, __FUNCTION__);
    cap.words[0] |= (capEPBadge & 0xffffffful) << 4;
    /* fail if user has passed bits that we will override */
    if(!((capCanGrant & ~0x1ul) == ((0 && (capCanGrant & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCanGrant & ~0x1ul) == ((0 && (capCanGrant & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1409, __FUNCTION__);
    cap.words[1] |= (capCanGrant & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((capCanSend & ~0x1ul) == ((0 && (capCanSend & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCanSend & ~0x1ul) == ((0 && (capCanSend & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1412, __FUNCTION__);
    cap.words[1] |= (capCanSend & 0x1ul) << 0;
    /* fail if user has passed bits that we will override */
    if(!((capCanReceive & ~0x1ul) == ((0 && (capCanReceive & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCanReceive & ~0x1ul) == ((0 && (capCanReceive & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1415, __FUNCTION__);
    cap.words[1] |= (capCanReceive & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((capEPPtr & ~0xfffffff0ul) == ((0 && (capEPPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capEPPtr & ~0xfffffff0ul) == ((0 && (capEPPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1418, __FUNCTION__);
    cap.words[1] |= (capEPPtr & 0xfffffff0ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_endpoint_cap & ~0xful) == ((0 && ((uint32_t)cap_endpoint_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_endpoint_cap & ~0xful) == ((0 && ((uint32_t)cap_endpoint_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1421, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_endpoint_cap & 0xful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_endpoint_cap_get_capEPPtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1430 "./arch/object/structures_gen.h"
    ,
 1431
# 1430 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;

    ret = (cap.words[1] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_endpoint_cap_get_capCanGrant(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1444 "./arch/object/structures_gen.h"
    ,
 1445
# 1444 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;

    ret = (cap.words[1] & 0x4ul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_endpoint_cap_set_capCanGrant(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1457 "./arch/object/structures_gen.h"
    ,
 1458
# 1457 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x4ul >> 2) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x4ul >> 2) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1460, __FUNCTION__);

    cap.words[1] &= ~0x4ul;
    cap.words[1] |= (v << 2) & 0x4ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_endpoint_cap_get_capCanReceive(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1470 "./arch/object/structures_gen.h"
    ,
 1471
# 1470 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;

    ret = (cap.words[1] & 0x2ul) >> 1;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_endpoint_cap_set_capCanReceive(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1483 "./arch/object/structures_gen.h"
    ,
 1484
# 1483 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x2ul >> 1) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x2ul >> 1) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1486, __FUNCTION__);

    cap.words[1] &= ~0x2ul;
    cap.words[1] |= (v << 1) & 0x2ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_endpoint_cap_get_capCanSend(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1496 "./arch/object/structures_gen.h"
    ,
 1497
# 1496 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;

    ret = (cap.words[1] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_endpoint_cap_set_capCanSend(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1509 "./arch/object/structures_gen.h"
    ,
 1510
# 1509 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x1ul >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x1ul >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1512, __FUNCTION__);

    cap.words[1] &= ~0x1ul;
    cap.words[1] |= (v << 0) & 0x1ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_endpoint_cap_get_capEPBadge(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1522 "./arch/object/structures_gen.h"
    ,
 1523
# 1522 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;

    ret = (cap.words[0] & 0xfffffff0ul) >> 4;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_endpoint_cap_set_capEPBadge(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1535 "./arch/object/structures_gen.h"
    ,
 1536
# 1535 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;
    /* fail if user has passed bits that we will override */
    if(!(((~0xfffffff0ul >> 4) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xfffffff0ul >> 4) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1538, __FUNCTION__);

    cap.words[0] &= ~0xfffffff0ul;
    cap.words[0] |= (v << 4) & 0xfffffff0ul;
    return cap;
}

static inline cap_t __attribute__((__const__))
cap_async_endpoint_cap_new(uint32_t capAEPBadge, uint32_t capAEPCanReceive, uint32_t capAEPCanSend, uint32_t capAEPPtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capAEPBadge & ~0xffffffful) == ((0 && (capAEPBadge & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capAEPBadge & ~0xffffffful) == ((0 && (capAEPBadge & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1553, __FUNCTION__);
    cap.words[1] |= (capAEPBadge & 0xffffffful) << 4;
    /* fail if user has passed bits that we will override */
    if(!((capAEPCanReceive & ~0x1ul) == ((0 && (capAEPCanReceive & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capAEPCanReceive & ~0x1ul) == ((0 && (capAEPCanReceive & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1556, __FUNCTION__);
    cap.words[1] |= (capAEPCanReceive & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((capAEPCanSend & ~0x1ul) == ((0 && (capAEPCanSend & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capAEPCanSend & ~0x1ul) == ((0 && (capAEPCanSend & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1559, __FUNCTION__);
    cap.words[1] |= (capAEPCanSend & 0x1ul) << 0;
    /* fail if user has passed bits that we will override */
    if(!((capAEPPtr & ~0xfffffff0ul) == ((0 && (capAEPPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capAEPPtr & ~0xfffffff0ul) == ((0 && (capAEPPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1562, __FUNCTION__);
    cap.words[0] |= (capAEPPtr & 0xfffffff0ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_async_endpoint_cap & ~0xful) == ((0 && ((uint32_t)cap_async_endpoint_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_async_endpoint_cap & ~0xful) == ((0 && ((uint32_t)cap_async_endpoint_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1565, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_async_endpoint_cap & 0xful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_async_endpoint_cap_get_capAEPBadge(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1574 "./arch/object/structures_gen.h"
    ,
 1575
# 1574 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[1] & 0xfffffff0ul) >> 4;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_async_endpoint_cap_set_capAEPBadge(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1587 "./arch/object/structures_gen.h"
    ,
 1588
# 1587 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;
    /* fail if user has passed bits that we will override */
    if(!(((~0xfffffff0ul >> 4) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xfffffff0ul >> 4) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1590, __FUNCTION__);

    cap.words[1] &= ~0xfffffff0ul;
    cap.words[1] |= (v << 4) & 0xfffffff0ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_async_endpoint_cap_get_capAEPCanReceive(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1600 "./arch/object/structures_gen.h"
    ,
 1601
# 1600 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[1] & 0x2ul) >> 1;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_async_endpoint_cap_set_capAEPCanReceive(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1613 "./arch/object/structures_gen.h"
    ,
 1614
# 1613 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x2ul >> 1) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x2ul >> 1) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1616, __FUNCTION__);

    cap.words[1] &= ~0x2ul;
    cap.words[1] |= (v << 1) & 0x2ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_async_endpoint_cap_get_capAEPCanSend(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1626 "./arch/object/structures_gen.h"
    ,
 1627
# 1626 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[1] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_async_endpoint_cap_set_capAEPCanSend(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1639 "./arch/object/structures_gen.h"
    ,
 1640
# 1639 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x1ul >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x1ul >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1642, __FUNCTION__);

    cap.words[1] &= ~0x1ul;
    cap.words[1] |= (v << 0) & 0x1ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_async_endpoint_cap_get_capAEPPtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_async_endpoint_cap",
 "./arch/object/structures_gen.h"
# 1652 "./arch/object/structures_gen.h"
    ,
 1653
# 1652 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_reply_cap_new(uint32_t capCallerSlot, uint32_t capReplyMaster, uint32_t capTCBPtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capCallerSlot & ~0xfffffff0ul) == ((0 && (capCallerSlot & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCallerSlot & ~0xfffffff0ul) == ((0 && (capCallerSlot & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1671, __FUNCTION__);
    cap.words[1] |= (capCallerSlot & 0xfffffff0ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((capReplyMaster & ~0x1ul) == ((0 && (capReplyMaster & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capReplyMaster & ~0x1ul) == ((0 && (capReplyMaster & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1674, __FUNCTION__);
    cap.words[1] |= (capReplyMaster & 0x1ul) << 0;
    /* fail if user has passed bits that we will override */
    if(!((capTCBPtr & ~0xffffffe0ul) == ((0 && (capTCBPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capTCBPtr & ~0xffffffe0ul) == ((0 && (capTCBPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1677, __FUNCTION__);
    cap.words[0] |= (capTCBPtr & 0xffffffe0ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_reply_cap & ~0xful) == ((0 && ((uint32_t)cap_reply_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_reply_cap & ~0xful) == ((0 && ((uint32_t)cap_reply_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1680, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_reply_cap & 0xful) << 0;

    return cap;
}

static inline void
cap_reply_cap_ptr_new(cap_t *cap_ptr, uint32_t capCallerSlot, uint32_t capReplyMaster, uint32_t capTCBPtr) {
    cap_ptr->words[0] = 0;
    cap_ptr->words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capCallerSlot & ~0xfffffff0ul) == ((0 && (capCallerSlot & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCallerSlot & ~0xfffffff0ul) == ((0 && (capCallerSlot & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1692, __FUNCTION__);
    cap_ptr->words[1] |= (capCallerSlot & 0xfffffff0ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((capReplyMaster & ~0x1ul) == ((0 && (capReplyMaster & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capReplyMaster & ~0x1ul) == ((0 && (capReplyMaster & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1695, __FUNCTION__);
    cap_ptr->words[1] |= (capReplyMaster & 0x1ul) << 0;
    /* fail if user has passed bits that we will override */
    if(!((capTCBPtr & ~0xffffffe0ul) == ((0 && (capTCBPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capTCBPtr & ~0xffffffe0ul) == ((0 && (capTCBPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1698, __FUNCTION__);
    cap_ptr->words[0] |= (capTCBPtr & 0xffffffe0ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_reply_cap & ~0xful) == ((0 && ((uint32_t)cap_reply_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_reply_cap & ~0xful) == ((0 && ((uint32_t)cap_reply_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1701, __FUNCTION__);
    cap_ptr->words[0] |= ((uint32_t)cap_reply_cap & 0xful) << 0;
}

static inline uint32_t __attribute__((__const__))
cap_reply_cap_get_capCallerSlot(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_reply_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_reply_cap",
 "./arch/object/structures_gen.h"
# 1708 "./arch/object/structures_gen.h"
    ,
 1709
# 1708 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
cap_reply_cap_ptr_set_capCallerSlot(cap_t *cap_ptr,
                                      uint32_t v) {
    if(!(((cap_ptr->words[0] >> 0) & 0xf) == cap_reply_cap)) _assert_fail("((cap_ptr->words[0] >> 0) & 0xf) == cap_reply_cap",
 "./arch/object/structures_gen.h"
# 1722 "./arch/object/structures_gen.h"
    ,
 1723
# 1722 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    /* fail if user has passed bits that we will override */
    if(!(((~0xfffffff0ul << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xfffffff0ul << 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1726, __FUNCTION__);

    cap_ptr->words[1] &= ~0xfffffff0ul;
    cap_ptr->words[1] |= (v >> 0) & 0xfffffff0ul;
}

static inline uint32_t __attribute__((__const__))
cap_reply_cap_get_capReplyMaster(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_reply_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_reply_cap",
 "./arch/object/structures_gen.h"
# 1735 "./arch/object/structures_gen.h"
    ,
 1736
# 1735 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_reply_cap_get_capTCBPtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_reply_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_reply_cap",
 "./arch/object/structures_gen.h"
# 1749 "./arch/object/structures_gen.h"
    ,
 1750
# 1749 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[0] & 0xffffffe0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_cnode_cap_new(uint32_t capCNodeRadix, uint32_t capCNodeGuardSize, uint32_t capCNodeGuard, uint32_t capCNodePtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capCNodeRadix & ~0x1ful) == ((0 && (capCNodeRadix & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCNodeRadix & ~0x1ful) == ((0 && (capCNodeRadix & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1768, __FUNCTION__);
    cap.words[1] |= (capCNodeRadix & 0x1ful) << 18;
    /* fail if user has passed bits that we will override */
    if(!((capCNodeGuardSize & ~0x1ful) == ((0 && (capCNodeGuardSize & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCNodeGuardSize & ~0x1ful) == ((0 && (capCNodeGuardSize & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1771, __FUNCTION__);
    cap.words[1] |= (capCNodeGuardSize & 0x1ful) << 23;
    /* fail if user has passed bits that we will override */
    if(!((capCNodeGuard & ~0x3fffful) == ((0 && (capCNodeGuard & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCNodeGuard & ~0x3fffful) == ((0 && (capCNodeGuard & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1774, __FUNCTION__);
    cap.words[1] |= (capCNodeGuard & 0x3fffful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((capCNodePtr & ~0xffffffe0ul) == ((0 && (capCNodePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCNodePtr & ~0xffffffe0ul) == ((0 && (capCNodePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1777, __FUNCTION__);
    cap.words[0] |= (capCNodePtr & 0xffffffe0ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_cnode_cap & ~0xful) == ((0 && ((uint32_t)cap_cnode_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_cnode_cap & ~0xful) == ((0 && ((uint32_t)cap_cnode_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1780, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_cnode_cap & 0xful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_cnode_cap_get_capCNodeGuardSize(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_cnode_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_cnode_cap",
 "./arch/object/structures_gen.h"
# 1789 "./arch/object/structures_gen.h"
    ,
 1790
# 1789 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0xf800000ul) >> 23;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_cnode_cap_set_capCNodeGuardSize(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_cnode_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_cnode_cap",
 "./arch/object/structures_gen.h"
# 1802 "./arch/object/structures_gen.h"
    ,
 1803
# 1802 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!(((~0xf800000ul >> 23) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xf800000ul >> 23) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1805, __FUNCTION__);

    cap.words[1] &= ~0xf800000ul;
    cap.words[1] |= (v << 23) & 0xf800000ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_cnode_cap_get_capCNodeRadix(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_cnode_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_cnode_cap",
 "./arch/object/structures_gen.h"
# 1815 "./arch/object/structures_gen.h"
    ,
 1816
# 1815 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0x7c0000ul) >> 18;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_cnode_cap_set_capCNodeGuard(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_cnode_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_cnode_cap",
 "./arch/object/structures_gen.h"
# 1828 "./arch/object/structures_gen.h"
    ,
 1829
# 1828 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x3fffful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x3fffful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1831, __FUNCTION__);

    cap.words[1] &= ~0x3fffful;
    cap.words[1] |= (v << 0) & 0x3fffful;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_cnode_cap_get_capCNodePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_cnode_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_cnode_cap",
 "./arch/object/structures_gen.h"
# 1841 "./arch/object/structures_gen.h"
    ,
 1842
# 1841 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[0] & 0xffffffe0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_thread_cap_new(uint32_t capTCBPtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capTCBPtr & ~0xfffffff0ul) == ((0 && (capTCBPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capTCBPtr & ~0xfffffff0ul) == ((0 && (capTCBPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1860, __FUNCTION__);
    cap.words[0] |= (capTCBPtr & 0xfffffff0ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_thread_cap & ~0xful) == ((0 && ((uint32_t)cap_thread_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_thread_cap & ~0xful) == ((0 && ((uint32_t)cap_thread_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1863, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_thread_cap & 0xful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_thread_cap_get_capTCBPtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_thread_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_thread_cap",
 "./arch/object/structures_gen.h"
# 1872 "./arch/object/structures_gen.h"
    ,
 1873
# 1872 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;

    ret = (cap.words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_frame_cap_new(uint32_t capFSize, uint32_t capFMappedObject, uint32_t capFMappedIndex, uint32_t capFMappedType, uint32_t capFVMRights, uint32_t capFBasePtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capFSize & ~0x1ul) == ((0 && (capFSize & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFSize & ~0x1ul) == ((0 && (capFSize & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1891, __FUNCTION__);
    cap.words[1] |= (capFSize & 0x1ul) << 31;
    /* fail if user has passed bits that we will override */
    if(!((capFMappedObject & ~0xfffff000ul) == ((0 && (capFMappedObject & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFMappedObject & ~0xfffff000ul) == ((0 && (capFMappedObject & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1894, __FUNCTION__);
    cap.words[1] |= (capFMappedObject & 0xfffff000ul) >> 2;
    /* fail if user has passed bits that we will override */
    if(!((capFMappedIndex & ~0x3fful) == ((0 && (capFMappedIndex & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFMappedIndex & ~0x3fful) == ((0 && (capFMappedIndex & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1897, __FUNCTION__);
    cap.words[1] |= (capFMappedIndex & 0x3fful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((capFMappedType & ~0x3ul) == ((0 && (capFMappedType & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFMappedType & ~0x3ul) == ((0 && (capFMappedType & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1900, __FUNCTION__);
    cap.words[0] |= (capFMappedType & 0x3ul) << 30;
    /* fail if user has passed bits that we will override */
    if(!((capFVMRights & ~0x3ul) == ((0 && (capFVMRights & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFVMRights & ~0x3ul) == ((0 && (capFVMRights & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1903, __FUNCTION__);
    cap.words[0] |= (capFVMRights & 0x3ul) << 24;
    /* fail if user has passed bits that we will override */
    if(!((capFBasePtr & ~0xfffff000ul) == ((0 && (capFBasePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFBasePtr & ~0xfffff000ul) == ((0 && (capFBasePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1906, __FUNCTION__);
    cap.words[0] |= (capFBasePtr & 0xfffff000ul) >> 8;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_frame_cap & ~0xful) == ((0 && ((uint32_t)cap_frame_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_frame_cap & ~0xful) == ((0 && ((uint32_t)cap_frame_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1909, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_frame_cap & 0xful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFSize(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
 "./arch/object/structures_gen.h"
# 1918 "./arch/object/structures_gen.h"
    ,
 1919
# 1918 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0x80000000ul) >> 31;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFMappedObject(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
 "./arch/object/structures_gen.h"
# 1932 "./arch/object/structures_gen.h"
    ,
 1933
# 1932 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0x3ffffc00ul) << 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_frame_cap_set_capFMappedObject(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
 "./arch/object/structures_gen.h"
# 1945 "./arch/object/structures_gen.h"
    ,
 1946
# 1945 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x3ffffc00ul << 2) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x3ffffc00ul << 2) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1948, __FUNCTION__);

    cap.words[1] &= ~0x3ffffc00ul;
    cap.words[1] |= (v >> 2) & 0x3ffffc00ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFMappedIndex(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
 "./arch/object/structures_gen.h"
# 1958 "./arch/object/structures_gen.h"
    ,
 1959
# 1958 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0x3fful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_frame_cap_set_capFMappedIndex(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
 "./arch/object/structures_gen.h"
# 1971 "./arch/object/structures_gen.h"
    ,
 1972
# 1971 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x3fful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x3fful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1974, __FUNCTION__);

    cap.words[1] &= ~0x3fful;
    cap.words[1] |= (v << 0) & 0x3fful;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFMappedType(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
 "./arch/object/structures_gen.h"
# 1984 "./arch/object/structures_gen.h"
    ,
 1985
# 1984 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[0] & 0xc0000000ul) >> 30;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_frame_cap_set_capFMappedType(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
 "./arch/object/structures_gen.h"
# 1997 "./arch/object/structures_gen.h"
    ,
 1998
# 1997 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!(((~0xc0000000ul >> 30) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xc0000000ul >> 30) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2000, __FUNCTION__);

    cap.words[0] &= ~0xc0000000ul;
    cap.words[0] |= (v << 30) & 0xc0000000ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFVMRights(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
 "./arch/object/structures_gen.h"
# 2010 "./arch/object/structures_gen.h"
    ,
 2011
# 2010 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[0] & 0x3000000ul) >> 24;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_frame_cap_set_capFVMRights(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
 "./arch/object/structures_gen.h"
# 2023 "./arch/object/structures_gen.h"
    ,
 2024
# 2023 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x3000000ul >> 24) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x3000000ul >> 24) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2026, __FUNCTION__);

    cap.words[0] &= ~0x3000000ul;
    cap.words[0] |= (v << 24) & 0x3000000ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFBasePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
 "./arch/object/structures_gen.h"
# 2036 "./arch/object/structures_gen.h"
    ,
 2037
# 2036 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[0] & 0xfffff0ul) << 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_page_table_cap_new(uint32_t capPTMappedObject, uint32_t capPTMappedIndex, uint32_t capPTBasePtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capPTMappedObject & ~0xfffff000ul) == ((0 && (capPTMappedObject & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPTMappedObject & ~0xfffff000ul) == ((0 && (capPTMappedObject & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2055, __FUNCTION__);
    cap.words[1] |= (capPTMappedObject & 0xfffff000ul) >> 2;
    /* fail if user has passed bits that we will override */
    if(!((capPTMappedIndex & ~0x3fful) == ((0 && (capPTMappedIndex & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPTMappedIndex & ~0x3fful) == ((0 && (capPTMappedIndex & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2058, __FUNCTION__);
    cap.words[1] |= (capPTMappedIndex & 0x3fful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((capPTBasePtr & ~0xfffff000ul) == ((0 && (capPTBasePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPTBasePtr & ~0xfffff000ul) == ((0 && (capPTBasePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2061, __FUNCTION__);
    cap.words[0] |= (capPTBasePtr & 0xfffff000ul) >> 8;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_page_table_cap & ~0xful) == ((0 && ((uint32_t)cap_page_table_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_page_table_cap & ~0xful) == ((0 && ((uint32_t)cap_page_table_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2064, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_page_table_cap & 0xful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_page_table_cap_get_capPTMappedObject(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_table_cap",
 "./arch/object/structures_gen.h"
# 2073 "./arch/object/structures_gen.h"
    ,
 2074
# 2073 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (cap.words[1] & 0x3ffffc00ul) << 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_page_table_cap_set_capPTMappedObject(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_table_cap",
 "./arch/object/structures_gen.h"
# 2086 "./arch/object/structures_gen.h"
    ,
 2087
# 2086 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x3ffffc00ul << 2) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x3ffffc00ul << 2) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2089, __FUNCTION__);

    cap.words[1] &= ~0x3ffffc00ul;
    cap.words[1] |= (v >> 2) & 0x3ffffc00ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_page_table_cap_get_capPTMappedIndex(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_table_cap",
 "./arch/object/structures_gen.h"
# 2099 "./arch/object/structures_gen.h"
    ,
 2100
# 2099 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (cap.words[1] & 0x3fful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_page_table_cap_set_capPTMappedIndex(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_table_cap",
 "./arch/object/structures_gen.h"
# 2112 "./arch/object/structures_gen.h"
    ,
 2113
# 2112 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x3fful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x3fful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2115, __FUNCTION__);

    cap.words[1] &= ~0x3fful;
    cap.words[1] |= (v << 0) & 0x3fful;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_page_table_cap_get_capPTBasePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_table_cap",
 "./arch/object/structures_gen.h"
# 2125 "./arch/object/structures_gen.h"
    ,
 2126
# 2125 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (cap.words[0] & 0xfffff0ul) << 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_page_directory_cap_new(uint32_t capPDMappedObject, uint32_t capPDMappedIndex, uint32_t capPDBasePtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capPDMappedObject & ~0xffffffe0ul) == ((0 && (capPDMappedObject & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPDMappedObject & ~0xffffffe0ul) == ((0 && (capPDMappedObject & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2144, __FUNCTION__);
    cap.words[1] |= (capPDMappedObject & 0xffffffe0ul) >> 3;
    /* fail if user has passed bits that we will override */
    if(!((capPDMappedIndex & ~0x3ul) == ((0 && (capPDMappedIndex & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPDMappedIndex & ~0x3ul) == ((0 && (capPDMappedIndex & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2147, __FUNCTION__);
    cap.words[1] |= (capPDMappedIndex & 0x3ul) << 0;
    /* fail if user has passed bits that we will override */
    if(!((capPDBasePtr & ~0xfffff000ul) == ((0 && (capPDBasePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPDBasePtr & ~0xfffff000ul) == ((0 && (capPDBasePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2150, __FUNCTION__);
    cap.words[0] |= (capPDBasePtr & 0xfffff000ul) >> 8;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_page_directory_cap & ~0xful) == ((0 && ((uint32_t)cap_page_directory_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_page_directory_cap & ~0xful) == ((0 && ((uint32_t)cap_page_directory_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2153, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_page_directory_cap & 0xful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_page_directory_cap_get_capPDMappedObject(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap",
 "./arch/object/structures_gen.h"
# 2162 "./arch/object/structures_gen.h"
    ,
 2163
# 2162 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[1] & 0x1ffffffcul) << 3;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_page_directory_cap_set_capPDMappedObject(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap",
 "./arch/object/structures_gen.h"
# 2175 "./arch/object/structures_gen.h"
    ,
 2176
# 2175 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x1ffffffcul << 3) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x1ffffffcul << 3) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2178, __FUNCTION__);

    cap.words[1] &= ~0x1ffffffcul;
    cap.words[1] |= (v >> 3) & 0x1ffffffcul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_page_directory_cap_get_capPDMappedIndex(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap",
 "./arch/object/structures_gen.h"
# 2188 "./arch/object/structures_gen.h"
    ,
 2189
# 2188 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[1] & 0x3ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_page_directory_cap_set_capPDMappedIndex(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap",
 "./arch/object/structures_gen.h"
# 2201 "./arch/object/structures_gen.h"
    ,
 2202
# 2201 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x3ul >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x3ul >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2204, __FUNCTION__);

    cap.words[1] &= ~0x3ul;
    cap.words[1] |= (v << 0) & 0x3ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_page_directory_cap_get_capPDBasePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap",
 "./arch/object/structures_gen.h"
# 2214 "./arch/object/structures_gen.h"
    ,
 2215
# 2214 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[0] & 0xfffff0ul) << 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_pdpt_cap_new(uint32_t capPDPTBasePtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capPDPTBasePtr & ~0xffffffe0ul) == ((0 && (capPDPTBasePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPDPTBasePtr & ~0xffffffe0ul) == ((0 && (capPDPTBasePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2233, __FUNCTION__);
    cap.words[0] |= (capPDPTBasePtr & 0xffffffe0ul) >> 1;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_pdpt_cap & ~0xful) == ((0 && ((uint32_t)cap_pdpt_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_pdpt_cap & ~0xful) == ((0 && ((uint32_t)cap_pdpt_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2236, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_pdpt_cap & 0xful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_pdpt_cap_get_capPDPTBasePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_pdpt_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_pdpt_cap",
 "./arch/object/structures_gen.h"
# 2245 "./arch/object/structures_gen.h"
    ,
 2246
# 2245 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                        ;

    ret = (cap.words[0] & 0x7ffffff0ul) << 1;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_io_page_table_cap_new(uint32_t capIOPTLevel, uint32_t capIOPTMappedObject, uint32_t capIOPTMappedIndex, uint32_t capIOPTBasePtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capIOPTLevel & ~0x7ul) == ((0 && (capIOPTLevel & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capIOPTLevel & ~0x7ul) == ((0 && (capIOPTLevel & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2264, __FUNCTION__);
    cap.words[1] |= (capIOPTLevel & 0x7ul) << 29;
    /* fail if user has passed bits that we will override */
    if(!((capIOPTMappedObject & ~0xfffff000ul) == ((0 && (capIOPTMappedObject & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capIOPTMappedObject & ~0xfffff000ul) == ((0 && (capIOPTMappedObject & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2267, __FUNCTION__);
    cap.words[1] |= (capIOPTMappedObject & 0xfffff000ul) >> 3;
    /* fail if user has passed bits that we will override */
    if(!((capIOPTMappedIndex & ~0x1fful) == ((0 && (capIOPTMappedIndex & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capIOPTMappedIndex & ~0x1fful) == ((0 && (capIOPTMappedIndex & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2270, __FUNCTION__);
    cap.words[1] |= (capIOPTMappedIndex & 0x1fful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((capIOPTBasePtr & ~0xfffff000ul) == ((0 && (capIOPTBasePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capIOPTBasePtr & ~0xfffff000ul) == ((0 && (capIOPTBasePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2273, __FUNCTION__);
    cap.words[0] |= (capIOPTBasePtr & 0xfffff000ul) >> 8;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_io_page_table_cap & ~0xful) == ((0 && ((uint32_t)cap_io_page_table_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_io_page_table_cap & ~0xful) == ((0 && ((uint32_t)cap_io_page_table_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2276, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_io_page_table_cap & 0xful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_io_page_table_cap_get_capIOPTLevel(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap",
 "./arch/object/structures_gen.h"
# 2285 "./arch/object/structures_gen.h"
    ,
 2286
# 2285 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                 ;

    ret = (cap.words[1] & 0xe0000000ul) >> 29;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_io_page_table_cap_set_capIOPTLevel(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap",
 "./arch/object/structures_gen.h"
# 2298 "./arch/object/structures_gen.h"
    ,
 2299
# 2298 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                 ;
    /* fail if user has passed bits that we will override */
    if(!(((~0xe0000000ul >> 29) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xe0000000ul >> 29) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2301, __FUNCTION__);

    cap.words[1] &= ~0xe0000000ul;
    cap.words[1] |= (v << 29) & 0xe0000000ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_io_page_table_cap_get_capIOPTMappedObject(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap",
 "./arch/object/structures_gen.h"
# 2311 "./arch/object/structures_gen.h"
    ,
 2312
# 2311 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                 ;

    ret = (cap.words[1] & 0x1ffffe00ul) << 3;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_io_page_table_cap_set_capIOPTMappedObject(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap",
 "./arch/object/structures_gen.h"
# 2324 "./arch/object/structures_gen.h"
    ,
 2325
# 2324 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                 ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x1ffffe00ul << 3) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x1ffffe00ul << 3) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2327, __FUNCTION__);

    cap.words[1] &= ~0x1ffffe00ul;
    cap.words[1] |= (v >> 3) & 0x1ffffe00ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_io_page_table_cap_get_capIOPTMappedIndex(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap",
 "./arch/object/structures_gen.h"
# 2337 "./arch/object/structures_gen.h"
    ,
 2338
# 2337 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                 ;

    ret = (cap.words[1] & 0x1fful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_io_page_table_cap_set_capIOPTMappedIndex(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap",
 "./arch/object/structures_gen.h"
# 2350 "./arch/object/structures_gen.h"
    ,
 2351
# 2350 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                 ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x1fful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x1fful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2353, __FUNCTION__);

    cap.words[1] &= ~0x1fful;
    cap.words[1] |= (v << 0) & 0x1fful;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_io_page_table_cap_get_capIOPTBasePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_io_page_table_cap",
 "./arch/object/structures_gen.h"
# 2363 "./arch/object/structures_gen.h"
    ,
 2364
# 2363 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                 ;

    ret = (cap.words[0] & 0xfffff0ul) << 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_io_space_cap_new(uint32_t capDomainID, uint32_t capPCIDevice) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capDomainID & ~0xfffful) == ((0 && (capDomainID & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capDomainID & ~0xfffful) == ((0 && (capDomainID & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2382, __FUNCTION__);
    cap.words[1] |= (capDomainID & 0xfffful) << 16;
    /* fail if user has passed bits that we will override */
    if(!((capPCIDevice & ~0xfffful) == ((0 && (capPCIDevice & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPCIDevice & ~0xfffful) == ((0 && (capPCIDevice & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2385, __FUNCTION__);
    cap.words[1] |= (capPCIDevice & 0xfffful) << 0;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_io_space_cap & ~0xful) == ((0 && ((uint32_t)cap_io_space_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_io_space_cap & ~0xful) == ((0 && ((uint32_t)cap_io_space_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2388, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_io_space_cap & 0xful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_io_space_cap_get_capDomainID(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_io_space_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_io_space_cap",
 "./arch/object/structures_gen.h"
# 2397 "./arch/object/structures_gen.h"
    ,
 2398
# 2397 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;

    ret = (cap.words[1] & 0xffff0000ul) >> 16;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_io_space_cap_get_capPCIDevice(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_io_space_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_io_space_cap",
 "./arch/object/structures_gen.h"
# 2411 "./arch/object/structures_gen.h"
    ,
 2412
# 2411 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;

    ret = (cap.words[1] & 0xfffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_ipi_cap_new(void) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_ipi_cap & ~0xful) == ((0 && ((uint32_t)cap_ipi_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_ipi_cap & ~0xful) == ((0 && ((uint32_t)cap_ipi_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2430, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_ipi_cap & 0xful) << 0;

    return cap;
}

static inline cap_t __attribute__((__const__))
cap_irq_control_cap_new(void) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_irq_control_cap & ~0xfful) == ((0 && ((uint32_t)cap_irq_control_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_irq_control_cap & ~0xfful) == ((0 && ((uint32_t)cap_irq_control_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2444, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_irq_control_cap & 0xfful) << 0;

    return cap;
}

static inline cap_t __attribute__((__const__))
cap_irq_handler_cap_new(uint32_t capIRQ) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capIRQ & ~0xfful) == ((0 && (capIRQ & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capIRQ & ~0xfful) == ((0 && (capIRQ & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2458, __FUNCTION__);
    cap.words[1] |= (capIRQ & 0xfful) << 0;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_irq_handler_cap & ~0xfful) == ((0 && ((uint32_t)cap_irq_handler_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_irq_handler_cap & ~0xfful) == ((0 && ((uint32_t)cap_irq_handler_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2461, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_irq_handler_cap & 0xfful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_irq_handler_cap_get_capIRQ(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_irq_handler_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_irq_handler_cap",
 "./arch/object/structures_gen.h"
# 2470 "./arch/object/structures_gen.h"
    ,
 2471
# 2470 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;

    ret = (cap.words[1] & 0xfful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_zombie_cap_new(uint32_t capZombieID, uint32_t capZombieType) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

       cap.words[1] |= capZombieID << 0;
    /* fail if user has passed bits that we will override */
    if(!((capZombieType & ~0x3ful) == ((0 && (capZombieType & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capZombieType & ~0x3ful) == ((0 && (capZombieType & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2490, __FUNCTION__);
    cap.words[0] |= (capZombieType & 0x3ful) << 8;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_zombie_cap & ~0xfful) == ((0 && ((uint32_t)cap_zombie_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_zombie_cap & ~0xfful) == ((0 && ((uint32_t)cap_zombie_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2493, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_zombie_cap & 0xfful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_zombie_cap_get_capZombieID(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_zombie_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_zombie_cap",
 "./arch/object/structures_gen.h"
# 2502 "./arch/object/structures_gen.h"
    ,
 2503
# 2502 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;

    ret = (cap.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_zombie_cap_set_capZombieID(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xff) == cap_zombie_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_zombie_cap",
 "./arch/object/structures_gen.h"
# 2515 "./arch/object/structures_gen.h"
    ,
 2516
# 2515 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;
    /* fail if user has passed bits that we will override */
    if(!(((~0xfffffffful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xfffffffful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2518, __FUNCTION__);

    cap.words[1] &= ~0xfffffffful;
    cap.words[1] |= (v << 0) & 0xfffffffful;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_zombie_cap_get_capZombieType(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_zombie_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_zombie_cap",
 "./arch/object/structures_gen.h"
# 2528 "./arch/object/structures_gen.h"
    ,
 2529
# 2528 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;

    ret = (cap.words[0] & 0x3f00ul) >> 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_domain_cap_new(void) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_domain_cap & ~0xfful) == ((0 && ((uint32_t)cap_domain_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_domain_cap & ~0xfful) == ((0 && ((uint32_t)cap_domain_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2547, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_domain_cap & 0xfful) << 0;

    return cap;
}

static inline cap_t __attribute__((__const__))
cap_io_port_cap_new(uint32_t capIOPortFirstPort, uint32_t capIOPortLastPort) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capIOPortFirstPort & ~0xfffful) == ((0 && (capIOPortFirstPort & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capIOPortFirstPort & ~0xfffful) == ((0 && (capIOPortFirstPort & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2561, __FUNCTION__);
    cap.words[1] |= (capIOPortFirstPort & 0xfffful) << 16;
    /* fail if user has passed bits that we will override */
    if(!((capIOPortLastPort & ~0xfffful) == ((0 && (capIOPortLastPort & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capIOPortLastPort & ~0xfffful) == ((0 && (capIOPortLastPort & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2564, __FUNCTION__);
    cap.words[1] |= (capIOPortLastPort & 0xfffful) << 0;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_io_port_cap & ~0xfful) == ((0 && ((uint32_t)cap_io_port_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_io_port_cap & ~0xfful) == ((0 && ((uint32_t)cap_io_port_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2567, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_io_port_cap & 0xfful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_io_port_cap_get_capIOPortFirstPort(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_io_port_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_io_port_cap",
 "./arch/object/structures_gen.h"
# 2576 "./arch/object/structures_gen.h"
    ,
 2577
# 2576 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (cap.words[1] & 0xffff0000ul) >> 16;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_io_port_cap_get_capIOPortLastPort(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_io_port_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_io_port_cap",
 "./arch/object/structures_gen.h"
# 2590 "./arch/object/structures_gen.h"
    ,
 2591
# 2590 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (cap.words[1] & 0xfffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_vcpu_cap_new(uint32_t capVCPUPtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capVCPUPtr & ~0xffffff00ul) == ((0 && (capVCPUPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capVCPUPtr & ~0xffffff00ul) == ((0 && (capVCPUPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2609, __FUNCTION__);
    cap.words[0] |= (capVCPUPtr & 0xffffff00ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_vcpu_cap & ~0xfful) == ((0 && ((uint32_t)cap_vcpu_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_vcpu_cap & ~0xfful) == ((0 && ((uint32_t)cap_vcpu_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2612, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_vcpu_cap & 0xfful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_vcpu_cap_get_capVCPUPtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_vcpu_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_vcpu_cap",
 "./arch/object/structures_gen.h"
# 2621 "./arch/object/structures_gen.h"
    ,
 2622
# 2621 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                        ;

    ret = (cap.words[0] & 0xffffff00ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_ept_page_table_cap_new(uint32_t capPTMappedObject, uint32_t capPTMappedIndex, uint32_t capPTBasePtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capPTMappedObject & ~0xfffff000ul) == ((0 && (capPTMappedObject & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPTMappedObject & ~0xfffff000ul) == ((0 && (capPTMappedObject & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2640, __FUNCTION__);
    cap.words[1] |= (capPTMappedObject & 0xfffff000ul) >> 3;
    /* fail if user has passed bits that we will override */
    if(!((capPTMappedIndex & ~0x1fful) == ((0 && (capPTMappedIndex & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPTMappedIndex & ~0x1fful) == ((0 && (capPTMappedIndex & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2643, __FUNCTION__);
    cap.words[1] |= (capPTMappedIndex & 0x1fful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((capPTBasePtr & ~0xfffff000ul) == ((0 && (capPTBasePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPTBasePtr & ~0xfffff000ul) == ((0 && (capPTBasePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2646, __FUNCTION__);
    cap.words[0] |= (capPTBasePtr & 0xfffff000ul) >> 4;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_ept_page_table_cap & ~0xfful) == ((0 && ((uint32_t)cap_ept_page_table_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_ept_page_table_cap & ~0xfful) == ((0 && ((uint32_t)cap_ept_page_table_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2649, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_ept_page_table_cap & 0xfful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_ept_page_table_cap_get_capPTMappedObject(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_ept_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_ept_page_table_cap",
 "./arch/object/structures_gen.h"
# 2658 "./arch/object/structures_gen.h"
    ,
 2659
# 2658 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[1] & 0x1ffffe00ul) << 3;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_ept_page_table_cap_set_capPTMappedObject(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xff) == cap_ept_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_ept_page_table_cap",
 "./arch/object/structures_gen.h"
# 2671 "./arch/object/structures_gen.h"
    ,
 2672
# 2671 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x1ffffe00ul << 3) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x1ffffe00ul << 3) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2674, __FUNCTION__);

    cap.words[1] &= ~0x1ffffe00ul;
    cap.words[1] |= (v >> 3) & 0x1ffffe00ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_ept_page_table_cap_get_capPTMappedIndex(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_ept_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_ept_page_table_cap",
 "./arch/object/structures_gen.h"
# 2684 "./arch/object/structures_gen.h"
    ,
 2685
# 2684 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[1] & 0x1fful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_ept_page_table_cap_set_capPTMappedIndex(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xff) == cap_ept_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_ept_page_table_cap",
 "./arch/object/structures_gen.h"
# 2697 "./arch/object/structures_gen.h"
    ,
 2698
# 2697 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x1fful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x1fful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2700, __FUNCTION__);

    cap.words[1] &= ~0x1fful;
    cap.words[1] |= (v << 0) & 0x1fful;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_ept_page_table_cap_get_capPTBasePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_ept_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_ept_page_table_cap",
 "./arch/object/structures_gen.h"
# 2710 "./arch/object/structures_gen.h"
    ,
 2711
# 2710 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[0] & 0xfffff00ul) << 4;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_ept_page_directory_pointer_table_cap_new(uint32_t capPDPTBasePtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capPDPTBasePtr & ~0xfffff000ul) == ((0 && (capPDPTBasePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPDPTBasePtr & ~0xfffff000ul) == ((0 && (capPDPTBasePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2729, __FUNCTION__);
    cap.words[0] |= (capPDPTBasePtr & 0xfffff000ul) >> 4;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_ept_page_directory_pointer_table_cap & ~0xfful) == ((0 && ((uint32_t)cap_ept_page_directory_pointer_table_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_ept_page_directory_pointer_table_cap & ~0xfful) == ((0 && ((uint32_t)cap_ept_page_directory_pointer_table_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2732, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_ept_page_directory_pointer_table_cap & 0xfful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_ept_page_directory_pointer_table_cap_get_capPDPTBasePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_ept_page_directory_pointer_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_ept_page_directory_pointer_table_cap",
 "./arch/object/structures_gen.h"
# 2741 "./arch/object/structures_gen.h"
    ,
 2742
# 2741 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                                    ;

    ret = (cap.words[0] & 0xfffff00ul) << 4;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_ept_page_directory_cap_new(uint32_t capPDMappedObject, uint32_t capPDMappedIndex, uint32_t capPDBasePtr) {
    cap_t cap;

    cap.words[0] = 0;
    cap.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((capPDMappedObject & ~0xfffff000ul) == ((0 && (capPDMappedObject & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPDMappedObject & ~0xfffff000ul) == ((0 && (capPDMappedObject & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2760, __FUNCTION__);
    cap.words[1] |= (capPDMappedObject & 0xfffff000ul) >> 3;
    /* fail if user has passed bits that we will override */
    if(!((capPDMappedIndex & ~0x1fful) == ((0 && (capPDMappedIndex & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPDMappedIndex & ~0x1fful) == ((0 && (capPDMappedIndex & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2763, __FUNCTION__);
    cap.words[1] |= (capPDMappedIndex & 0x1fful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((capPDBasePtr & ~0xfffff000ul) == ((0 && (capPDBasePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPDBasePtr & ~0xfffff000ul) == ((0 && (capPDBasePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2766, __FUNCTION__);
    cap.words[0] |= (capPDBasePtr & 0xfffff000ul) >> 4;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_ept_page_directory_cap & ~0xfful) == ((0 && ((uint32_t)cap_ept_page_directory_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_ept_page_directory_cap & ~0xfful) == ((0 && ((uint32_t)cap_ept_page_directory_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2769, __FUNCTION__);
    cap.words[0] |= ((uint32_t)cap_ept_page_directory_cap & 0xfful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_ept_page_directory_cap_get_capPDMappedObject(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_ept_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_ept_page_directory_cap",
 "./arch/object/structures_gen.h"
# 2778 "./arch/object/structures_gen.h"
    ,
 2779
# 2778 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                      ;

    ret = (cap.words[1] & 0x1ffffe00ul) << 3;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_ept_page_directory_cap_set_capPDMappedObject(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xff) == cap_ept_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_ept_page_directory_cap",
 "./arch/object/structures_gen.h"
# 2791 "./arch/object/structures_gen.h"
    ,
 2792
# 2791 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                      ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x1ffffe00ul << 3) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x1ffffe00ul << 3) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2794, __FUNCTION__);

    cap.words[1] &= ~0x1ffffe00ul;
    cap.words[1] |= (v >> 3) & 0x1ffffe00ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_ept_page_directory_cap_get_capPDMappedIndex(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_ept_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_ept_page_directory_cap",
 "./arch/object/structures_gen.h"
# 2804 "./arch/object/structures_gen.h"
    ,
 2805
# 2804 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                      ;

    ret = (cap.words[1] & 0x1fful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_ept_page_directory_cap_set_capPDMappedIndex(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xff) == cap_ept_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_ept_page_directory_cap",
 "./arch/object/structures_gen.h"
# 2817 "./arch/object/structures_gen.h"
    ,
 2818
# 2817 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                      ;
    /* fail if user has passed bits that we will override */
    if(!(((~0x1fful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0x1fful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2820, __FUNCTION__);

    cap.words[1] &= ~0x1fful;
    cap.words[1] |= (v << 0) & 0x1fful;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_ept_page_directory_cap_get_capPDBasePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_ept_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_ept_page_directory_cap",
 "./arch/object/structures_gen.h"
# 2830 "./arch/object/structures_gen.h"
    ,
 2831
# 2830 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                      ;

    ret = (cap.words[0] & 0xfffff00ul) << 4;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct lookup_fault {
    uint32_t words[2];
};
typedef struct lookup_fault lookup_fault_t;

enum lookup_fault_tag {
    lookup_fault_invalid_root = 0,
    lookup_fault_missing_capability = 1,
    lookup_fault_depth_mismatch = 2,
    lookup_fault_guard_mismatch = 3
};
typedef enum lookup_fault_tag lookup_fault_tag_t;

static inline uint32_t __attribute__((__const__))
lookup_fault_get_lufType(lookup_fault_t lookup_fault) {
    return (lookup_fault.words[0] >> 0) & 0x3ul;
}

static inline lookup_fault_t __attribute__((__const__))
lookup_fault_invalid_root_new(void) {
    lookup_fault_t lookup_fault;

    lookup_fault.words[0] = 0;
    lookup_fault.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)lookup_fault_invalid_root & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_invalid_root & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)lookup_fault_invalid_root & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_invalid_root & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2867, __FUNCTION__);
    lookup_fault.words[0] |= ((uint32_t)lookup_fault_invalid_root & 0x3ul) << 0;

    return lookup_fault;
}

static inline lookup_fault_t __attribute__((__const__))
lookup_fault_missing_capability_new(uint32_t bitsLeft) {
    lookup_fault_t lookup_fault;

    lookup_fault.words[0] = 0;
    lookup_fault.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((bitsLeft & ~0x3ful) == ((0 && (bitsLeft & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(bitsLeft & ~0x3ful) == ((0 && (bitsLeft & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2881, __FUNCTION__);
    lookup_fault.words[0] |= (bitsLeft & 0x3ful) << 2;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)lookup_fault_missing_capability & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_missing_capability & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)lookup_fault_missing_capability & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_missing_capability & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2884, __FUNCTION__);
    lookup_fault.words[0] |= ((uint32_t)lookup_fault_missing_capability & 0x3ul) << 0;

    return lookup_fault;
}

static inline uint32_t __attribute__((__const__))
lookup_fault_missing_capability_get_bitsLeft(lookup_fault_t lookup_fault) {
    uint32_t ret;
    if(!(((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_missing_capability)) _assert_fail("((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_missing_capability",
 "./arch/object/structures_gen.h"
# 2893 "./arch/object/structures_gen.h"
    ,
 2894
# 2893 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                           ;

    ret = (lookup_fault.words[0] & 0xfcul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline lookup_fault_t __attribute__((__const__))
lookup_fault_depth_mismatch_new(uint32_t bitsFound, uint32_t bitsLeft) {
    lookup_fault_t lookup_fault;

    lookup_fault.words[0] = 0;
    lookup_fault.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((bitsFound & ~0x3ful) == ((0 && (bitsFound & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(bitsFound & ~0x3ful) == ((0 && (bitsFound & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2912, __FUNCTION__);
    lookup_fault.words[0] |= (bitsFound & 0x3ful) << 8;
    /* fail if user has passed bits that we will override */
    if(!((bitsLeft & ~0x3ful) == ((0 && (bitsLeft & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(bitsLeft & ~0x3ful) == ((0 && (bitsLeft & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2915, __FUNCTION__);
    lookup_fault.words[0] |= (bitsLeft & 0x3ful) << 2;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)lookup_fault_depth_mismatch & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_depth_mismatch & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)lookup_fault_depth_mismatch & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_depth_mismatch & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2918, __FUNCTION__);
    lookup_fault.words[0] |= ((uint32_t)lookup_fault_depth_mismatch & 0x3ul) << 0;

    return lookup_fault;
}

static inline uint32_t __attribute__((__const__))
lookup_fault_depth_mismatch_get_bitsFound(lookup_fault_t lookup_fault) {
    uint32_t ret;
    if(!(((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_depth_mismatch)) _assert_fail("((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_depth_mismatch",
 "./arch/object/structures_gen.h"
# 2927 "./arch/object/structures_gen.h"
    ,
 2928
# 2927 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                       ;

    ret = (lookup_fault.words[0] & 0x3f00ul) >> 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
lookup_fault_depth_mismatch_get_bitsLeft(lookup_fault_t lookup_fault) {
    uint32_t ret;
    if(!(((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_depth_mismatch)) _assert_fail("((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_depth_mismatch",
 "./arch/object/structures_gen.h"
# 2941 "./arch/object/structures_gen.h"
    ,
 2942
# 2941 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                       ;

    ret = (lookup_fault.words[0] & 0xfcul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline lookup_fault_t __attribute__((__const__))
lookup_fault_guard_mismatch_new(uint32_t guardFound, uint32_t bitsLeft, uint32_t bitsFound) {
    lookup_fault_t lookup_fault;

    lookup_fault.words[0] = 0;
    lookup_fault.words[1] = 0;

       lookup_fault.words[1] |= guardFound << 0;
    /* fail if user has passed bits that we will override */
    if(!((bitsLeft & ~0x3ful) == ((0 && (bitsLeft & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(bitsLeft & ~0x3ful) == ((0 && (bitsLeft & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2961, __FUNCTION__);
    lookup_fault.words[0] |= (bitsLeft & 0x3ful) << 8;
    /* fail if user has passed bits that we will override */
    if(!((bitsFound & ~0x3ful) == ((0 && (bitsFound & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(bitsFound & ~0x3ful) == ((0 && (bitsFound & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2964, __FUNCTION__);
    lookup_fault.words[0] |= (bitsFound & 0x3ful) << 2;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)lookup_fault_guard_mismatch & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_guard_mismatch & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)lookup_fault_guard_mismatch & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_guard_mismatch & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2967, __FUNCTION__);
    lookup_fault.words[0] |= ((uint32_t)lookup_fault_guard_mismatch & 0x3ul) << 0;

    return lookup_fault;
}

static inline uint32_t __attribute__((__const__))
lookup_fault_guard_mismatch_get_guardFound(lookup_fault_t lookup_fault) {
    uint32_t ret;
    if(!(((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_guard_mismatch)) _assert_fail("((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_guard_mismatch",
 "./arch/object/structures_gen.h"
# 2976 "./arch/object/structures_gen.h"
    ,
 2977
# 2976 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                       ;

    ret = (lookup_fault.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
lookup_fault_guard_mismatch_get_bitsLeft(lookup_fault_t lookup_fault) {
    uint32_t ret;
    if(!(((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_guard_mismatch)) _assert_fail("((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_guard_mismatch",
 "./arch/object/structures_gen.h"
# 2990 "./arch/object/structures_gen.h"
    ,
 2991
# 2990 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                       ;

    ret = (lookup_fault.words[0] & 0x3f00ul) >> 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
lookup_fault_guard_mismatch_get_bitsFound(lookup_fault_t lookup_fault) {
    uint32_t ret;
    if(!(((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_guard_mismatch)) _assert_fail("((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_guard_mismatch",
 "./arch/object/structures_gen.h"
# 3004 "./arch/object/structures_gen.h"
    ,
 3005
# 3004 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                       ;

    ret = (lookup_fault.words[0] & 0xfcul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct idt_entry {
    uint32_t words[2];
};
typedef struct idt_entry idt_entry_t;

enum idt_entry_tag {
    idt_entry_task_gate = 5,
    idt_entry_interrupt_gate = 6,
    idt_entry_trap_gate = 7
};
typedef enum idt_entry_tag idt_entry_tag_t;

static inline idt_entry_t __attribute__((__const__))
idt_entry_interrupt_gate_new(uint32_t offset_high, uint32_t present, uint32_t dpl, uint32_t gate_size, uint32_t seg_selector, uint32_t offset_low) {
    idt_entry_t idt_entry;

    idt_entry.words[0] = 0;
    idt_entry.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((offset_high & ~0xfffful) == ((0 && (offset_high & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(offset_high & ~0xfffful) == ((0 && (offset_high & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3035, __FUNCTION__);
    idt_entry.words[1] |= (offset_high & 0xfffful) << 16;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3038, __FUNCTION__);
    idt_entry.words[1] |= (present & 0x1ul) << 15;
    /* fail if user has passed bits that we will override */
    if(!((dpl & ~0x3ul) == ((0 && (dpl & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(dpl & ~0x3ul) == ((0 && (dpl & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3041, __FUNCTION__);
    idt_entry.words[1] |= (dpl & 0x3ul) << 13;
    /* fail if user has passed bits that we will override */
    if(!((gate_size & ~0x1ul) == ((0 && (gate_size & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(gate_size & ~0x1ul) == ((0 && (gate_size & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3044, __FUNCTION__);
    idt_entry.words[1] |= (gate_size & 0x1ul) << 11;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)idt_entry_interrupt_gate & ~0x7ul) == ((0 && ((uint32_t)idt_entry_interrupt_gate & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)idt_entry_interrupt_gate & ~0x7ul) == ((0 && ((uint32_t)idt_entry_interrupt_gate & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3047, __FUNCTION__);
    idt_entry.words[1] |= ((uint32_t)idt_entry_interrupt_gate & 0x7ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!((seg_selector & ~0xfffful) == ((0 && (seg_selector & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(seg_selector & ~0xfffful) == ((0 && (seg_selector & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3050, __FUNCTION__);
    idt_entry.words[0] |= (seg_selector & 0xfffful) << 16;
    /* fail if user has passed bits that we will override */
    if(!((offset_low & ~0xfffful) == ((0 && (offset_low & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(offset_low & ~0xfffful) == ((0 && (offset_low & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3053, __FUNCTION__);
    idt_entry.words[0] |= (offset_low & 0xfffful) << 0;

    return idt_entry;
}

struct fault {
    uint32_t words[2];
};
typedef struct fault fault_t;

enum fault_tag {
    fault_null_fault = 0,
    fault_cap_fault = 1,
    fault_vm_fault = 2,
    fault_unknown_syscall = 3,
    fault_user_exception = 4
};
typedef enum fault_tag fault_tag_t;

static inline uint32_t __attribute__((__const__))
fault_get_faultType(fault_t fault) {
    return (fault.words[0] >> 0) & 0x7ul;
}

static inline uint32_t __attribute__((__pure__))
fault_ptr_get_faultType(fault_t *fault_ptr) {
    return (fault_ptr->words[0] >> 0) & 0x7ul;
}

static inline void
fault_null_fault_ptr_new(fault_t *fault_ptr) {
    fault_ptr->words[0] = 0;
    fault_ptr->words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)fault_null_fault & ~0x7ul) == ((0 && ((uint32_t)fault_null_fault & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)fault_null_fault & ~0x7ul) == ((0 && ((uint32_t)fault_null_fault & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3089, __FUNCTION__);
    fault_ptr->words[0] |= ((uint32_t)fault_null_fault & 0x7ul) << 0;
}

static inline fault_t __attribute__((__const__))
fault_cap_fault_new(uint32_t address, uint32_t inReceivePhase) {
    fault_t fault;

    fault.words[0] = 0;
    fault.words[1] = 0;

       fault.words[1] |= address << 0;
    /* fail if user has passed bits that we will override */
    if(!((inReceivePhase & ~0x1ul) == ((0 && (inReceivePhase & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(inReceivePhase & ~0x1ul) == ((0 && (inReceivePhase & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3102, __FUNCTION__);
    fault.words[0] |= (inReceivePhase & 0x1ul) << 31;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)fault_cap_fault & ~0x7ul) == ((0 && ((uint32_t)fault_cap_fault & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)fault_cap_fault & ~0x7ul) == ((0 && ((uint32_t)fault_cap_fault & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3105, __FUNCTION__);
    fault.words[0] |= ((uint32_t)fault_cap_fault & 0x7ul) << 0;

    return fault;
}

static inline uint32_t __attribute__((__const__))
fault_cap_fault_get_address(fault_t fault) {
    uint32_t ret;
    if(!(((fault.words[0] >> 0) & 0x7) == fault_cap_fault)) _assert_fail("((fault.words[0] >> 0) & 0x7) == fault_cap_fault",
 "./arch/object/structures_gen.h"
# 3114 "./arch/object/structures_gen.h"
    ,
 3115
# 3114 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (fault.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
fault_cap_fault_get_inReceivePhase(fault_t fault) {
    uint32_t ret;
    if(!(((fault.words[0] >> 0) & 0x7) == fault_cap_fault)) _assert_fail("((fault.words[0] >> 0) & 0x7) == fault_cap_fault",
 "./arch/object/structures_gen.h"
# 3128 "./arch/object/structures_gen.h"
    ,
 3129
# 3128 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (fault.words[0] & 0x80000000ul) >> 31;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline fault_t __attribute__((__const__))
fault_vm_fault_new(uint32_t address, uint32_t FSR, uint32_t instructionFault) {
    fault_t fault;

    fault.words[0] = 0;
    fault.words[1] = 0;

       fault.words[1] |= address << 0;
    /* fail if user has passed bits that we will override */
    if(!((FSR & ~0x1ful) == ((0 && (FSR & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(FSR & ~0x1ful) == ((0 && (FSR & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3148, __FUNCTION__);
    fault.words[0] |= (FSR & 0x1ful) << 27;
    /* fail if user has passed bits that we will override */
    if(!((instructionFault & ~0x1ul) == ((0 && (instructionFault & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(instructionFault & ~0x1ul) == ((0 && (instructionFault & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3151, __FUNCTION__);
    fault.words[0] |= (instructionFault & 0x1ul) << 19;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)fault_vm_fault & ~0x7ul) == ((0 && ((uint32_t)fault_vm_fault & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)fault_vm_fault & ~0x7ul) == ((0 && ((uint32_t)fault_vm_fault & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3154, __FUNCTION__);
    fault.words[0] |= ((uint32_t)fault_vm_fault & 0x7ul) << 0;

    return fault;
}

static inline uint32_t __attribute__((__const__))
fault_vm_fault_get_address(fault_t fault) {
    uint32_t ret;
    if(!(((fault.words[0] >> 0) & 0x7) == fault_vm_fault)) _assert_fail("((fault.words[0] >> 0) & 0x7) == fault_vm_fault",
 "./arch/object/structures_gen.h"
# 3163 "./arch/object/structures_gen.h"
    ,
 3164
# 3163 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;

    ret = (fault.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
fault_vm_fault_get_FSR(fault_t fault) {
    uint32_t ret;
    if(!(((fault.words[0] >> 0) & 0x7) == fault_vm_fault)) _assert_fail("((fault.words[0] >> 0) & 0x7) == fault_vm_fault",
 "./arch/object/structures_gen.h"
# 3177 "./arch/object/structures_gen.h"
    ,
 3178
# 3177 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;

    ret = (fault.words[0] & 0xf8000000ul) >> 27;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
fault_vm_fault_get_instructionFault(fault_t fault) {
    uint32_t ret;
    if(!(((fault.words[0] >> 0) & 0x7) == fault_vm_fault)) _assert_fail("((fault.words[0] >> 0) & 0x7) == fault_vm_fault",
 "./arch/object/structures_gen.h"
# 3191 "./arch/object/structures_gen.h"
    ,
 3192
# 3191 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;

    ret = (fault.words[0] & 0x80000ul) >> 19;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline fault_t __attribute__((__const__))
fault_unknown_syscall_new(uint32_t syscallNumber) {
    fault_t fault;

    fault.words[0] = 0;
    fault.words[1] = 0;

       fault.words[1] |= syscallNumber << 0;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)fault_unknown_syscall & ~0x7ul) == ((0 && ((uint32_t)fault_unknown_syscall & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)fault_unknown_syscall & ~0x7ul) == ((0 && ((uint32_t)fault_unknown_syscall & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3211, __FUNCTION__);
    fault.words[0] |= ((uint32_t)fault_unknown_syscall & 0x7ul) << 0;

    return fault;
}

static inline uint32_t __attribute__((__const__))
fault_unknown_syscall_get_syscallNumber(fault_t fault) {
    uint32_t ret;
    if(!(((fault.words[0] >> 0) & 0x7) == fault_unknown_syscall)) _assert_fail("((fault.words[0] >> 0) & 0x7) == fault_unknown_syscall",
 "./arch/object/structures_gen.h"
# 3220 "./arch/object/structures_gen.h"
    ,
 3221
# 3220 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                 ;

    ret = (fault.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline fault_t __attribute__((__const__))
fault_user_exception_new(uint32_t number, uint32_t code) {
    fault_t fault;

    fault.words[0] = 0;
    fault.words[1] = 0;

       fault.words[1] |= number << 0;
    /* fail if user has passed bits that we will override */
    if(!((code & ~0x1ffffffful) == ((0 && (code & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(code & ~0x1ffffffful) == ((0 && (code & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3240, __FUNCTION__);
    fault.words[0] |= (code & 0x1ffffffful) << 3;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)fault_user_exception & ~0x7ul) == ((0 && ((uint32_t)fault_user_exception & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)fault_user_exception & ~0x7ul) == ((0 && ((uint32_t)fault_user_exception & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3243, __FUNCTION__);
    fault.words[0] |= ((uint32_t)fault_user_exception & 0x7ul) << 0;

    return fault;
}

static inline uint32_t __attribute__((__const__))
fault_user_exception_get_number(fault_t fault) {
    uint32_t ret;
    if(!(((fault.words[0] >> 0) & 0x7) == fault_user_exception)) _assert_fail("((fault.words[0] >> 0) & 0x7) == fault_user_exception",
 "./arch/object/structures_gen.h"
# 3252 "./arch/object/structures_gen.h"
    ,
 3253
# 3252 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                ;

    ret = (fault.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
fault_user_exception_get_code(fault_t fault) {
    uint32_t ret;
    if(!(((fault.words[0] >> 0) & 0x7) == fault_user_exception)) _assert_fail("((fault.words[0] >> 0) & 0x7) == fault_user_exception",
 "./arch/object/structures_gen.h"
# 3266 "./arch/object/structures_gen.h"
    ,
 3267
# 3266 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                ;

    ret = (fault.words[0] & 0xfffffff8ul) >> 3;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct pde {
    uint32_t words[1];
};
typedef struct pde pde_t;

enum pde_tag {
    pde_pde_small = 0,
    pde_pde_large = 1
};
typedef enum pde_tag pde_tag_t;

static inline uint32_t __attribute__((__const__))
pde_get_page_size(pde_t pde) {
    return (pde.words[0] >> 7) & 0x1ul;
}

static inline uint32_t __attribute__((__pure__))
pde_ptr_get_page_size(pde_t *pde_ptr) {
    return (pde_ptr->words[0] >> 7) & 0x1ul;
}

static inline pde_t __attribute__((__const__))
pde_pde_small_new(uint32_t pt_base_address, uint32_t avl_cte_depth, uint32_t accessed, uint32_t cache_disabled, uint32_t write_through, uint32_t super_user, uint32_t read_write, uint32_t present) {
    pde_t pde;

    pde.words[0] = 0;

    /* fail if user has passed bits that we will override */
    if(!((pt_base_address & ~0xfffff000ul) == ((0 && (pt_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(pt_base_address & ~0xfffff000ul) == ((0 && (pt_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3305, __FUNCTION__);
    pde.words[0] |= (pt_base_address & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3308, __FUNCTION__);
    pde.words[0] |= (avl_cte_depth & 0x7ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)pde_pde_small & ~0x1ul) == ((0 && ((uint32_t)pde_pde_small & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pde_pde_small & ~0x1ul) == ((0 && ((uint32_t)pde_pde_small & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3311, __FUNCTION__);
    pde.words[0] |= ((uint32_t)pde_pde_small & 0x1ul) << 7;
    /* fail if user has passed bits that we will override */
    if(!((accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3314, __FUNCTION__);
    pde.words[0] |= (accessed & 0x1ul) << 5;
    /* fail if user has passed bits that we will override */
    if(!((cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3317, __FUNCTION__);
    pde.words[0] |= (cache_disabled & 0x1ul) << 4;
    /* fail if user has passed bits that we will override */
    if(!((write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3320, __FUNCTION__);
    pde.words[0] |= (write_through & 0x1ul) << 3;
    /* fail if user has passed bits that we will override */
    if(!((super_user & ~0x1ul) == ((0 && (super_user & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(super_user & ~0x1ul) == ((0 && (super_user & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3323, __FUNCTION__);
    pde.words[0] |= (super_user & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((read_write & ~0x1ul) == ((0 && (read_write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read_write & ~0x1ul) == ((0 && (read_write & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3326, __FUNCTION__);
    pde.words[0] |= (read_write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3329, __FUNCTION__);
    pde.words[0] |= (present & 0x1ul) << 0;

    return pde;
}

static inline void
pde_pde_small_ptr_new(pde_t *pde_ptr, uint32_t pt_base_address, uint32_t avl_cte_depth, uint32_t accessed, uint32_t cache_disabled, uint32_t write_through, uint32_t super_user, uint32_t read_write, uint32_t present) {
    pde_ptr->words[0] = 0;

    /* fail if user has passed bits that we will override */
    if(!((pt_base_address & ~0xfffff000ul) == ((0 && (pt_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(pt_base_address & ~0xfffff000ul) == ((0 && (pt_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3340, __FUNCTION__);
    pde_ptr->words[0] |= (pt_base_address & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3343, __FUNCTION__);
    pde_ptr->words[0] |= (avl_cte_depth & 0x7ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)pde_pde_small & ~0x1ul) == ((0 && ((uint32_t)pde_pde_small & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pde_pde_small & ~0x1ul) == ((0 && ((uint32_t)pde_pde_small & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3346, __FUNCTION__);
    pde_ptr->words[0] |= ((uint32_t)pde_pde_small & 0x1ul) << 7;
    /* fail if user has passed bits that we will override */
    if(!((accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3349, __FUNCTION__);
    pde_ptr->words[0] |= (accessed & 0x1ul) << 5;
    /* fail if user has passed bits that we will override */
    if(!((cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3352, __FUNCTION__);
    pde_ptr->words[0] |= (cache_disabled & 0x1ul) << 4;
    /* fail if user has passed bits that we will override */
    if(!((write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3355, __FUNCTION__);
    pde_ptr->words[0] |= (write_through & 0x1ul) << 3;
    /* fail if user has passed bits that we will override */
    if(!((super_user & ~0x1ul) == ((0 && (super_user & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(super_user & ~0x1ul) == ((0 && (super_user & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3358, __FUNCTION__);
    pde_ptr->words[0] |= (super_user & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((read_write & ~0x1ul) == ((0 && (read_write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read_write & ~0x1ul) == ((0 && (read_write & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3361, __FUNCTION__);
    pde_ptr->words[0] |= (read_write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3364, __FUNCTION__);
    pde_ptr->words[0] |= (present & 0x1ul) << 0;
}

static inline uint32_t __attribute__((__const__))
pde_pde_small_get_pt_base_address(pde_t pde) {
    uint32_t ret;
    if(!(((pde.words[0] >> 7) & 0x1) == pde_pde_small)) _assert_fail("((pde.words[0] >> 7) & 0x1) == pde_pde_small",
 "./arch/object/structures_gen.h"
# 3371 "./arch/object/structures_gen.h"
    ,
 3372
# 3371 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pde.words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pde_pde_small_ptr_get_pt_base_address(pde_t *pde_ptr) {
    uint32_t ret;
    if(!(((pde_ptr->words[0] >> 7) & 0x1) == pde_pde_small)) _assert_fail("((pde_ptr->words[0] >> 7) & 0x1) == pde_pde_small",
 "./arch/object/structures_gen.h"
# 3385 "./arch/object/structures_gen.h"
    ,
 3386
# 3385 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pde_ptr->words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pde_pde_small_ptr_get_avl_cte_depth(pde_t *pde_ptr) {
    uint32_t ret;
    if(!(((pde_ptr->words[0] >> 7) & 0x1) == pde_pde_small)) _assert_fail("((pde_ptr->words[0] >> 7) & 0x1) == pde_pde_small",
 "./arch/object/structures_gen.h"
# 3399 "./arch/object/structures_gen.h"
    ,
 3400
# 3399 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pde_ptr->words[0] & 0xe00ul) >> 9;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
pde_pde_small_get_super_user(pde_t pde) {
    uint32_t ret;
    if(!(((pde.words[0] >> 7) & 0x1) == pde_pde_small)) _assert_fail("((pde.words[0] >> 7) & 0x1) == pde_pde_small",
 "./arch/object/structures_gen.h"
# 3413 "./arch/object/structures_gen.h"
    ,
 3414
# 3413 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pde.words[0] & 0x4ul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
pde_pde_small_get_present(pde_t pde) {
    uint32_t ret;
    if(!(((pde.words[0] >> 7) & 0x1) == pde_pde_small)) _assert_fail("((pde.words[0] >> 7) & 0x1) == pde_pde_small",
 "./arch/object/structures_gen.h"
# 3427 "./arch/object/structures_gen.h"
    ,
 3428
# 3427 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pde.words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pde_pde_small_ptr_get_present(pde_t *pde_ptr) {
    uint32_t ret;
    if(!(((pde_ptr->words[0] >> 7) & 0x1) == pde_pde_small)) _assert_fail("((pde_ptr->words[0] >> 7) & 0x1) == pde_pde_small",
 "./arch/object/structures_gen.h"
# 3441 "./arch/object/structures_gen.h"
    ,
 3442
# 3441 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pde_ptr->words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline pde_t __attribute__((__const__))
pde_pde_large_new(uint32_t page_base_address, uint32_t pat, uint32_t avl_cte_depth, uint32_t global, uint32_t dirty, uint32_t accessed, uint32_t cache_disabled, uint32_t write_through, uint32_t super_user, uint32_t read_write, uint32_t present) {
    pde_t pde;

    pde.words[0] = 0;

    /* fail if user has passed bits that we will override */
    if(!((page_base_address & ~0xffe00000ul) == ((0 && (page_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(page_base_address & ~0xffe00000ul) == ((0 && (page_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3459, __FUNCTION__);
    pde.words[0] |= (page_base_address & 0xffe00000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((pat & ~0x1ul) == ((0 && (pat & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(pat & ~0x1ul) == ((0 && (pat & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3462, __FUNCTION__);
    pde.words[0] |= (pat & 0x1ul) << 12;
    /* fail if user has passed bits that we will override */
    if(!((avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3465, __FUNCTION__);
    pde.words[0] |= (avl_cte_depth & 0x7ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!((global & ~0x1ul) == ((0 && (global & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(global & ~0x1ul) == ((0 && (global & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3468, __FUNCTION__);
    pde.words[0] |= (global & 0x1ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)pde_pde_large & ~0x1ul) == ((0 && ((uint32_t)pde_pde_large & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pde_pde_large & ~0x1ul) == ((0 && ((uint32_t)pde_pde_large & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3471, __FUNCTION__);
    pde.words[0] |= ((uint32_t)pde_pde_large & 0x1ul) << 7;
    /* fail if user has passed bits that we will override */
    if(!((dirty & ~0x1ul) == ((0 && (dirty & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(dirty & ~0x1ul) == ((0 && (dirty & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3474, __FUNCTION__);
    pde.words[0] |= (dirty & 0x1ul) << 6;
    /* fail if user has passed bits that we will override */
    if(!((accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3477, __FUNCTION__);
    pde.words[0] |= (accessed & 0x1ul) << 5;
    /* fail if user has passed bits that we will override */
    if(!((cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3480, __FUNCTION__);
    pde.words[0] |= (cache_disabled & 0x1ul) << 4;
    /* fail if user has passed bits that we will override */
    if(!((write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3483, __FUNCTION__);
    pde.words[0] |= (write_through & 0x1ul) << 3;
    /* fail if user has passed bits that we will override */
    if(!((super_user & ~0x1ul) == ((0 && (super_user & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(super_user & ~0x1ul) == ((0 && (super_user & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3486, __FUNCTION__);
    pde.words[0] |= (super_user & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((read_write & ~0x1ul) == ((0 && (read_write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read_write & ~0x1ul) == ((0 && (read_write & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3489, __FUNCTION__);
    pde.words[0] |= (read_write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3492, __FUNCTION__);
    pde.words[0] |= (present & 0x1ul) << 0;

    return pde;
}

static inline void
pde_pde_large_ptr_new(pde_t *pde_ptr, uint32_t page_base_address, uint32_t pat, uint32_t avl_cte_depth, uint32_t global, uint32_t dirty, uint32_t accessed, uint32_t cache_disabled, uint32_t write_through, uint32_t super_user, uint32_t read_write, uint32_t present) {
    pde_ptr->words[0] = 0;

    /* fail if user has passed bits that we will override */
    if(!((page_base_address & ~0xffe00000ul) == ((0 && (page_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(page_base_address & ~0xffe00000ul) == ((0 && (page_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3503, __FUNCTION__);
    pde_ptr->words[0] |= (page_base_address & 0xffe00000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((pat & ~0x1ul) == ((0 && (pat & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(pat & ~0x1ul) == ((0 && (pat & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3506, __FUNCTION__);
    pde_ptr->words[0] |= (pat & 0x1ul) << 12;
    /* fail if user has passed bits that we will override */
    if(!((avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3509, __FUNCTION__);
    pde_ptr->words[0] |= (avl_cte_depth & 0x7ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!((global & ~0x1ul) == ((0 && (global & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(global & ~0x1ul) == ((0 && (global & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3512, __FUNCTION__);
    pde_ptr->words[0] |= (global & 0x1ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)pde_pde_large & ~0x1ul) == ((0 && ((uint32_t)pde_pde_large & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pde_pde_large & ~0x1ul) == ((0 && ((uint32_t)pde_pde_large & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3515, __FUNCTION__);
    pde_ptr->words[0] |= ((uint32_t)pde_pde_large & 0x1ul) << 7;
    /* fail if user has passed bits that we will override */
    if(!((dirty & ~0x1ul) == ((0 && (dirty & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(dirty & ~0x1ul) == ((0 && (dirty & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3518, __FUNCTION__);
    pde_ptr->words[0] |= (dirty & 0x1ul) << 6;
    /* fail if user has passed bits that we will override */
    if(!((accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3521, __FUNCTION__);
    pde_ptr->words[0] |= (accessed & 0x1ul) << 5;
    /* fail if user has passed bits that we will override */
    if(!((cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cache_disabled & ~0x1ul) == ((0 && (cache_disabled & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3524, __FUNCTION__);
    pde_ptr->words[0] |= (cache_disabled & 0x1ul) << 4;
    /* fail if user has passed bits that we will override */
    if(!((write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write_through & ~0x1ul) == ((0 && (write_through & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3527, __FUNCTION__);
    pde_ptr->words[0] |= (write_through & 0x1ul) << 3;
    /* fail if user has passed bits that we will override */
    if(!((super_user & ~0x1ul) == ((0 && (super_user & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(super_user & ~0x1ul) == ((0 && (super_user & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3530, __FUNCTION__);
    pde_ptr->words[0] |= (super_user & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((read_write & ~0x1ul) == ((0 && (read_write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read_write & ~0x1ul) == ((0 && (read_write & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3533, __FUNCTION__);
    pde_ptr->words[0] |= (read_write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3536, __FUNCTION__);
    pde_ptr->words[0] |= (present & 0x1ul) << 0;
}

static inline uint32_t __attribute__((__const__))
pde_pde_large_get_page_base_address(pde_t pde) {
    uint32_t ret;
    if(!(((pde.words[0] >> 7) & 0x1) == pde_pde_large)) _assert_fail("((pde.words[0] >> 7) & 0x1) == pde_pde_large",
 "./arch/object/structures_gen.h"
# 3543 "./arch/object/structures_gen.h"
    ,
 3544
# 3543 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pde.words[0] & 0xffe00000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pde_pde_large_ptr_get_page_base_address(pde_t *pde_ptr) {
    uint32_t ret;
    if(!(((pde_ptr->words[0] >> 7) & 0x1) == pde_pde_large)) _assert_fail("((pde_ptr->words[0] >> 7) & 0x1) == pde_pde_large",
 "./arch/object/structures_gen.h"
# 3557 "./arch/object/structures_gen.h"
    ,
 3558
# 3557 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pde_ptr->words[0] & 0xffe00000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pde_pde_large_ptr_get_avl_cte_depth(pde_t *pde_ptr) {
    uint32_t ret;
    if(!(((pde_ptr->words[0] >> 7) & 0x1) == pde_pde_large)) _assert_fail("((pde_ptr->words[0] >> 7) & 0x1) == pde_pde_large",
 "./arch/object/structures_gen.h"
# 3571 "./arch/object/structures_gen.h"
    ,
 3572
# 3571 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pde_ptr->words[0] & 0xe00ul) >> 9;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
pde_pde_large_get_super_user(pde_t pde) {
    uint32_t ret;
    if(!(((pde.words[0] >> 7) & 0x1) == pde_pde_large)) _assert_fail("((pde.words[0] >> 7) & 0x1) == pde_pde_large",
 "./arch/object/structures_gen.h"
# 3585 "./arch/object/structures_gen.h"
    ,
 3586
# 3585 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pde.words[0] & 0x4ul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
pde_pde_large_get_present(pde_t pde) {
    uint32_t ret;
    if(!(((pde.words[0] >> 7) & 0x1) == pde_pde_large)) _assert_fail("((pde.words[0] >> 7) & 0x1) == pde_pde_large",
 "./arch/object/structures_gen.h"
# 3599 "./arch/object/structures_gen.h"
    ,
 3600
# 3599 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pde.words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pde_pde_large_ptr_get_present(pde_t *pde_ptr) {
    uint32_t ret;
    if(!(((pde_ptr->words[0] >> 7) & 0x1) == pde_pde_large)) _assert_fail("((pde_ptr->words[0] >> 7) & 0x1) == pde_pde_large",
 "./arch/object/structures_gen.h"
# 3613 "./arch/object/structures_gen.h"
    ,
 3614
# 3613 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pde_ptr->words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct gdt_entry {
    uint32_t words[2];
};
typedef struct gdt_entry gdt_entry_t;

enum gdt_entry_tag {
    gdt_entry_gdt_null = 0,
    gdt_entry_gdt_tss = 2,
    gdt_entry_gdt_data = 4,
    gdt_entry_gdt_code = 6
};
typedef enum gdt_entry_tag gdt_entry_tag_t;

static inline gdt_entry_t __attribute__((__const__))
gdt_entry_gdt_null_new(void) {
    gdt_entry_t gdt_entry;

    gdt_entry.words[0] = 0;
    gdt_entry.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)gdt_entry_gdt_null & ~0x7ul) == ((0 && ((uint32_t)gdt_entry_gdt_null & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)gdt_entry_gdt_null & ~0x7ul) == ((0 && ((uint32_t)gdt_entry_gdt_null & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3645, __FUNCTION__);
    gdt_entry.words[1] |= ((uint32_t)gdt_entry_gdt_null & 0x7ul) << 10;

    return gdt_entry;
}

static inline gdt_entry_t __attribute__((__const__))
gdt_entry_gdt_tss_new(uint32_t base_high, uint32_t granularity, uint32_t avl, uint32_t limit_high, uint32_t present, uint32_t dpl, uint32_t busy, uint32_t always_1, uint32_t base_mid, uint32_t base_low, uint32_t limit_low) {
    gdt_entry_t gdt_entry;

    gdt_entry.words[0] = 0;
    gdt_entry.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((base_high & ~0xfful) == ((0 && (base_high & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(base_high & ~0xfful) == ((0 && (base_high & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3659, __FUNCTION__);
    gdt_entry.words[1] |= (base_high & 0xfful) << 24;
    /* fail if user has passed bits that we will override */
    if(!((granularity & ~0x1ul) == ((0 && (granularity & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(granularity & ~0x1ul) == ((0 && (granularity & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3662, __FUNCTION__);
    gdt_entry.words[1] |= (granularity & 0x1ul) << 23;
    /* fail if user has passed bits that we will override */
    if(!((avl & ~0x1ul) == ((0 && (avl & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl & ~0x1ul) == ((0 && (avl & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3665, __FUNCTION__);
    gdt_entry.words[1] |= (avl & 0x1ul) << 20;
    /* fail if user has passed bits that we will override */
    if(!((limit_high & ~0xful) == ((0 && (limit_high & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(limit_high & ~0xful) == ((0 && (limit_high & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3668, __FUNCTION__);
    gdt_entry.words[1] |= (limit_high & 0xful) << 16;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3671, __FUNCTION__);
    gdt_entry.words[1] |= (present & 0x1ul) << 15;
    /* fail if user has passed bits that we will override */
    if(!((dpl & ~0x3ul) == ((0 && (dpl & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(dpl & ~0x3ul) == ((0 && (dpl & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3674, __FUNCTION__);
    gdt_entry.words[1] |= (dpl & 0x3ul) << 13;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)gdt_entry_gdt_tss & ~0x7ul) == ((0 && ((uint32_t)gdt_entry_gdt_tss & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)gdt_entry_gdt_tss & ~0x7ul) == ((0 && ((uint32_t)gdt_entry_gdt_tss & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3677, __FUNCTION__);
    gdt_entry.words[1] |= ((uint32_t)gdt_entry_gdt_tss & 0x7ul) << 10;
    /* fail if user has passed bits that we will override */
    if(!((busy & ~0x1ul) == ((0 && (busy & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(busy & ~0x1ul) == ((0 && (busy & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3680, __FUNCTION__);
    gdt_entry.words[1] |= (busy & 0x1ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!((always_1 & ~0x1ul) == ((0 && (always_1 & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(always_1 & ~0x1ul) == ((0 && (always_1 & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3683, __FUNCTION__);
    gdt_entry.words[1] |= (always_1 & 0x1ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!((base_mid & ~0xfful) == ((0 && (base_mid & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(base_mid & ~0xfful) == ((0 && (base_mid & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3686, __FUNCTION__);
    gdt_entry.words[1] |= (base_mid & 0xfful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((base_low & ~0xfffful) == ((0 && (base_low & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(base_low & ~0xfffful) == ((0 && (base_low & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3689, __FUNCTION__);
    gdt_entry.words[0] |= (base_low & 0xfffful) << 16;
    /* fail if user has passed bits that we will override */
    if(!((limit_low & ~0xfffful) == ((0 && (limit_low & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(limit_low & ~0xfffful) == ((0 && (limit_low & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3692, __FUNCTION__);
    gdt_entry.words[0] |= (limit_low & 0xfffful) << 0;

    return gdt_entry;
}

static inline gdt_entry_t __attribute__((__const__))
gdt_entry_gdt_data_new(uint32_t base_high, uint32_t granularity, uint32_t operation_size, uint32_t avl, uint32_t seg_limit_high, uint32_t present, uint32_t dpl, uint32_t writable, uint32_t accessed, uint32_t base_mid, uint32_t base_low, uint32_t seg_limit_low) {
    gdt_entry_t gdt_entry;

    gdt_entry.words[0] = 0;
    gdt_entry.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((base_high & ~0xfful) == ((0 && (base_high & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(base_high & ~0xfful) == ((0 && (base_high & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3706, __FUNCTION__);
    gdt_entry.words[1] |= (base_high & 0xfful) << 24;
    /* fail if user has passed bits that we will override */
    if(!((granularity & ~0x1ul) == ((0 && (granularity & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(granularity & ~0x1ul) == ((0 && (granularity & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3709, __FUNCTION__);
    gdt_entry.words[1] |= (granularity & 0x1ul) << 23;
    /* fail if user has passed bits that we will override */
    if(!((operation_size & ~0x1ul) == ((0 && (operation_size & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(operation_size & ~0x1ul) == ((0 && (operation_size & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3712, __FUNCTION__);
    gdt_entry.words[1] |= (operation_size & 0x1ul) << 22;
    /* fail if user has passed bits that we will override */
    if(!((avl & ~0x1ul) == ((0 && (avl & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl & ~0x1ul) == ((0 && (avl & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3715, __FUNCTION__);
    gdt_entry.words[1] |= (avl & 0x1ul) << 20;
    /* fail if user has passed bits that we will override */
    if(!((seg_limit_high & ~0xful) == ((0 && (seg_limit_high & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(seg_limit_high & ~0xful) == ((0 && (seg_limit_high & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3718, __FUNCTION__);
    gdt_entry.words[1] |= (seg_limit_high & 0xful) << 16;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3721, __FUNCTION__);
    gdt_entry.words[1] |= (present & 0x1ul) << 15;
    /* fail if user has passed bits that we will override */
    if(!((dpl & ~0x3ul) == ((0 && (dpl & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(dpl & ~0x3ul) == ((0 && (dpl & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3724, __FUNCTION__);
    gdt_entry.words[1] |= (dpl & 0x3ul) << 13;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)gdt_entry_gdt_data & ~0x7ul) == ((0 && ((uint32_t)gdt_entry_gdt_data & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)gdt_entry_gdt_data & ~0x7ul) == ((0 && ((uint32_t)gdt_entry_gdt_data & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3727, __FUNCTION__);
    gdt_entry.words[1] |= ((uint32_t)gdt_entry_gdt_data & 0x7ul) << 10;
    /* fail if user has passed bits that we will override */
    if(!((writable & ~0x1ul) == ((0 && (writable & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(writable & ~0x1ul) == ((0 && (writable & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3730, __FUNCTION__);
    gdt_entry.words[1] |= (writable & 0x1ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!((accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3733, __FUNCTION__);
    gdt_entry.words[1] |= (accessed & 0x1ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!((base_mid & ~0xfful) == ((0 && (base_mid & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(base_mid & ~0xfful) == ((0 && (base_mid & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3736, __FUNCTION__);
    gdt_entry.words[1] |= (base_mid & 0xfful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((base_low & ~0xfffful) == ((0 && (base_low & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(base_low & ~0xfffful) == ((0 && (base_low & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3739, __FUNCTION__);
    gdt_entry.words[0] |= (base_low & 0xfffful) << 16;
    /* fail if user has passed bits that we will override */
    if(!((seg_limit_low & ~0xfffful) == ((0 && (seg_limit_low & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(seg_limit_low & ~0xfffful) == ((0 && (seg_limit_low & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3742, __FUNCTION__);
    gdt_entry.words[0] |= (seg_limit_low & 0xfffful) << 0;

    return gdt_entry;
}

static inline void
gdt_entry_gdt_data_ptr_set_base_high(gdt_entry_t *gdt_entry_ptr,
                                      uint32_t v) {
    if(!(((gdt_entry_ptr->words[1] >> 10) & 0x7) == gdt_entry_gdt_data)) _assert_fail("((gdt_entry_ptr->words[1] >> 10) & 0x7) == gdt_entry_gdt_data",
 "./arch/object/structures_gen.h"
# 3751 "./arch/object/structures_gen.h"
    ,
 3752
# 3751 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    /* fail if user has passed bits that we will override */
    if(!(((~0xff000000ul >> 24) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xff000000ul >> 24) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3755, __FUNCTION__);

    gdt_entry_ptr->words[1] &= ~0xff000000ul;
    gdt_entry_ptr->words[1] |= (v << 24) & 0xff000000ul;
}

static inline void
gdt_entry_gdt_data_ptr_set_base_mid(gdt_entry_t *gdt_entry_ptr,
                                      uint32_t v) {
    if(!(((gdt_entry_ptr->words[1] >> 10) & 0x7) == gdt_entry_gdt_data)) _assert_fail("((gdt_entry_ptr->words[1] >> 10) & 0x7) == gdt_entry_gdt_data",
 "./arch/object/structures_gen.h"
# 3764 "./arch/object/structures_gen.h"
    ,
 3765
# 3764 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    /* fail if user has passed bits that we will override */
    if(!(((~0xfful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xfful >> 0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3768, __FUNCTION__);

    gdt_entry_ptr->words[1] &= ~0xfful;
    gdt_entry_ptr->words[1] |= (v << 0) & 0xfful;
}

static inline void
gdt_entry_gdt_data_ptr_set_base_low(gdt_entry_t *gdt_entry_ptr,
                                      uint32_t v) {
    if(!(((gdt_entry_ptr->words[1] >> 10) & 0x7) == gdt_entry_gdt_data)) _assert_fail("((gdt_entry_ptr->words[1] >> 10) & 0x7) == gdt_entry_gdt_data",
 "./arch/object/structures_gen.h"
# 3777 "./arch/object/structures_gen.h"
    ,
 3778
# 3777 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    /* fail if user has passed bits that we will override */
    if(!(((~0xffff0000ul >> 16) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("((~0xffff0000ul >> 16) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3781, __FUNCTION__);

    gdt_entry_ptr->words[0] &= ~0xffff0000ul;
    gdt_entry_ptr->words[0] |= (v << 16) & 0xffff0000ul;
}

static inline gdt_entry_t __attribute__((__const__))
gdt_entry_gdt_code_new(uint32_t base_high, uint32_t granularity, uint32_t operation_size, uint32_t avl, uint32_t seg_limit_high, uint32_t present, uint32_t dpl, uint32_t readable, uint32_t accessed, uint32_t base_mid, uint32_t base_low, uint32_t seg_limit_low) {
    gdt_entry_t gdt_entry;

    gdt_entry.words[0] = 0;
    gdt_entry.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((base_high & ~0xfful) == ((0 && (base_high & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(base_high & ~0xfful) == ((0 && (base_high & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3795, __FUNCTION__);
    gdt_entry.words[1] |= (base_high & 0xfful) << 24;
    /* fail if user has passed bits that we will override */
    if(!((granularity & ~0x1ul) == ((0 && (granularity & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(granularity & ~0x1ul) == ((0 && (granularity & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3798, __FUNCTION__);
    gdt_entry.words[1] |= (granularity & 0x1ul) << 23;
    /* fail if user has passed bits that we will override */
    if(!((operation_size & ~0x1ul) == ((0 && (operation_size & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(operation_size & ~0x1ul) == ((0 && (operation_size & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3801, __FUNCTION__);
    gdt_entry.words[1] |= (operation_size & 0x1ul) << 22;
    /* fail if user has passed bits that we will override */
    if(!((avl & ~0x1ul) == ((0 && (avl & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl & ~0x1ul) == ((0 && (avl & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3804, __FUNCTION__);
    gdt_entry.words[1] |= (avl & 0x1ul) << 20;
    /* fail if user has passed bits that we will override */
    if(!((seg_limit_high & ~0xful) == ((0 && (seg_limit_high & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(seg_limit_high & ~0xful) == ((0 && (seg_limit_high & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3807, __FUNCTION__);
    gdt_entry.words[1] |= (seg_limit_high & 0xful) << 16;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3810, __FUNCTION__);
    gdt_entry.words[1] |= (present & 0x1ul) << 15;
    /* fail if user has passed bits that we will override */
    if(!((dpl & ~0x3ul) == ((0 && (dpl & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(dpl & ~0x3ul) == ((0 && (dpl & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3813, __FUNCTION__);
    gdt_entry.words[1] |= (dpl & 0x3ul) << 13;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)gdt_entry_gdt_code & ~0x7ul) == ((0 && ((uint32_t)gdt_entry_gdt_code & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)gdt_entry_gdt_code & ~0x7ul) == ((0 && ((uint32_t)gdt_entry_gdt_code & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3816, __FUNCTION__);
    gdt_entry.words[1] |= ((uint32_t)gdt_entry_gdt_code & 0x7ul) << 10;
    /* fail if user has passed bits that we will override */
    if(!((readable & ~0x1ul) == ((0 && (readable & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(readable & ~0x1ul) == ((0 && (readable & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3819, __FUNCTION__);
    gdt_entry.words[1] |= (readable & 0x1ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!((accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(accessed & ~0x1ul) == ((0 && (accessed & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3822, __FUNCTION__);
    gdt_entry.words[1] |= (accessed & 0x1ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!((base_mid & ~0xfful) == ((0 && (base_mid & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(base_mid & ~0xfful) == ((0 && (base_mid & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3825, __FUNCTION__);
    gdt_entry.words[1] |= (base_mid & 0xfful) << 0;
    /* fail if user has passed bits that we will override */
    if(!((base_low & ~0xfffful) == ((0 && (base_low & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(base_low & ~0xfffful) == ((0 && (base_low & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3828, __FUNCTION__);
    gdt_entry.words[0] |= (base_low & 0xfffful) << 16;
    /* fail if user has passed bits that we will override */
    if(!((seg_limit_low & ~0xfffful) == ((0 && (seg_limit_low & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(seg_limit_low & ~0xfffful) == ((0 && (seg_limit_low & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3831, __FUNCTION__);
    gdt_entry.words[0] |= (seg_limit_low & 0xfffful) << 0;

    return gdt_entry;
}

struct ept_pde {
    uint32_t words[2];
};
typedef struct ept_pde ept_pde_t;

enum ept_pde_tag {
    ept_pde_ept_pde_4k = 0,
    ept_pde_ept_pde_2m = 1
};
typedef enum ept_pde_tag ept_pde_tag_t;

static inline uint32_t __attribute__((__pure__))
ept_pde_ptr_get_page_size(ept_pde_t *ept_pde_ptr) {
    return (ept_pde_ptr->words[0] >> 7) & 0x1ul;
}

static inline ept_pde_t __attribute__((__const__))
ept_pde_ept_pde_4k_new(uint32_t pt_base_address, uint32_t avl_cte_depth, uint32_t execute, uint32_t write, uint32_t read) {
    ept_pde_t ept_pde;

    ept_pde.words[0] = 0;
    ept_pde.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((pt_base_address & ~0xfffff000ul) == ((0 && (pt_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(pt_base_address & ~0xfffff000ul) == ((0 && (pt_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3861, __FUNCTION__);
    ept_pde.words[0] |= (pt_base_address & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl_cte_depth & ~0x7ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3864, __FUNCTION__);
    ept_pde.words[0] |= (avl_cte_depth & 0x7ul) << 9;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)ept_pde_ept_pde_4k & ~0x1ul) == ((0 && ((uint32_t)ept_pde_ept_pde_4k & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)ept_pde_ept_pde_4k & ~0x1ul) == ((0 && ((uint32_t)ept_pde_ept_pde_4k & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3867, __FUNCTION__);
    ept_pde.words[0] |= ((uint32_t)ept_pde_ept_pde_4k & 0x1ul) << 7;
    /* fail if user has passed bits that we will override */
    if(!((execute & ~0x1ul) == ((0 && (execute & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(execute & ~0x1ul) == ((0 && (execute & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3870, __FUNCTION__);
    ept_pde.words[0] |= (execute & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3873, __FUNCTION__);
    ept_pde.words[0] |= (write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3876, __FUNCTION__);
    ept_pde.words[0] |= (read & 0x1ul) << 0;

    return ept_pde;
}

static inline uint32_t __attribute__((__pure__))
ept_pde_ept_pde_4k_ptr_get_pt_base_address(ept_pde_t *ept_pde_ptr) {
    uint32_t ret;
    if(!(((ept_pde_ptr->words[0] >> 7) & 0x1) == ept_pde_ept_pde_4k)) _assert_fail("((ept_pde_ptr->words[0] >> 7) & 0x1) == ept_pde_ept_pde_4k",
 "./arch/object/structures_gen.h"
# 3885 "./arch/object/structures_gen.h"
    ,
 3886
# 3885 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (ept_pde_ptr->words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
ept_pde_ept_pde_4k_ptr_get_avl_cte_depth(ept_pde_t *ept_pde_ptr) {
    uint32_t ret;
    if(!(((ept_pde_ptr->words[0] >> 7) & 0x1) == ept_pde_ept_pde_4k)) _assert_fail("((ept_pde_ptr->words[0] >> 7) & 0x1) == ept_pde_ept_pde_4k",
 "./arch/object/structures_gen.h"
# 3899 "./arch/object/structures_gen.h"
    ,
 3900
# 3899 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (ept_pde_ptr->words[0] & 0xe00ul) >> 9;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
ept_pde_ept_pde_4k_ptr_get_read(ept_pde_t *ept_pde_ptr) {
    uint32_t ret;
    if(!(((ept_pde_ptr->words[0] >> 7) & 0x1) == ept_pde_ept_pde_4k)) _assert_fail("((ept_pde_ptr->words[0] >> 7) & 0x1) == ept_pde_ept_pde_4k",
 "./arch/object/structures_gen.h"
# 3913 "./arch/object/structures_gen.h"
    ,
 3914
# 3913 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (ept_pde_ptr->words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline ept_pde_t __attribute__((__const__))
ept_pde_ept_pde_2m_new(uint32_t page_base_address, uint32_t avl_cte_depth, uint32_t ignore_pat, uint32_t type, uint32_t execute, uint32_t write, uint32_t read) {
    ept_pde_t ept_pde;

    ept_pde.words[0] = 0;
    ept_pde.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((page_base_address & ~0xfff00000ul) == ((0 && (page_base_address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(page_base_address & ~0xfff00000ul) == ((0 && (page_base_address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3932, __FUNCTION__);
    ept_pde.words[0] |= (page_base_address & 0xfff00000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((avl_cte_depth & ~0x3ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(avl_cte_depth & ~0x3ul) == ((0 && (avl_cte_depth & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3935, __FUNCTION__);
    ept_pde.words[0] |= (avl_cte_depth & 0x3ul) << 10;
    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)ept_pde_ept_pde_2m & ~0x1ul) == ((0 && ((uint32_t)ept_pde_ept_pde_2m & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)ept_pde_ept_pde_2m & ~0x1ul) == ((0 && ((uint32_t)ept_pde_ept_pde_2m & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3938, __FUNCTION__);
    ept_pde.words[0] |= ((uint32_t)ept_pde_ept_pde_2m & 0x1ul) << 7;
    /* fail if user has passed bits that we will override */
    if(!((ignore_pat & ~0x1ul) == ((0 && (ignore_pat & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(ignore_pat & ~0x1ul) == ((0 && (ignore_pat & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3941, __FUNCTION__);
    ept_pde.words[0] |= (ignore_pat & 0x1ul) << 6;
    /* fail if user has passed bits that we will override */
    if(!((type & ~0x7ul) == ((0 && (type & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(type & ~0x7ul) == ((0 && (type & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3944, __FUNCTION__);
    ept_pde.words[0] |= (type & 0x7ul) << 3;
    /* fail if user has passed bits that we will override */
    if(!((execute & ~0x1ul) == ((0 && (execute & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(execute & ~0x1ul) == ((0 && (execute & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3947, __FUNCTION__);
    ept_pde.words[0] |= (execute & 0x1ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3950, __FUNCTION__);
    ept_pde.words[0] |= (write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 3953, __FUNCTION__);
    ept_pde.words[0] |= (read & 0x1ul) << 0;

    return ept_pde;
}

static inline uint32_t __attribute__((__pure__))
ept_pde_ept_pde_2m_ptr_get_page_base_address(ept_pde_t *ept_pde_ptr) {
    uint32_t ret;
    if(!(((ept_pde_ptr->words[0] >> 7) & 0x1) == ept_pde_ept_pde_2m)) _assert_fail("((ept_pde_ptr->words[0] >> 7) & 0x1) == ept_pde_ept_pde_2m",
 "./arch/object/structures_gen.h"
# 3962 "./arch/object/structures_gen.h"
    ,
 3963
# 3962 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (ept_pde_ptr->words[0] & 0xfff00000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
ept_pde_ept_pde_2m_ptr_get_avl_cte_depth(ept_pde_t *ept_pde_ptr) {
    uint32_t ret;
    if(!(((ept_pde_ptr->words[0] >> 7) & 0x1) == ept_pde_ept_pde_2m)) _assert_fail("((ept_pde_ptr->words[0] >> 7) & 0x1) == ept_pde_ept_pde_2m",
 "./arch/object/structures_gen.h"
# 3976 "./arch/object/structures_gen.h"
    ,
 3977
# 3976 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (ept_pde_ptr->words[0] & 0xc00ul) >> 10;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
ept_pde_ept_pde_2m_ptr_get_read(ept_pde_t *ept_pde_ptr) {
    uint32_t ret;
    if(!(((ept_pde_ptr->words[0] >> 7) & 0x1) == ept_pde_ept_pde_2m)) _assert_fail("((ept_pde_ptr->words[0] >> 7) & 0x1) == ept_pde_ept_pde_2m",
 "./arch/object/structures_gen.h"
# 3990 "./arch/object/structures_gen.h"
    ,
 3991
# 3990 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (ept_pde_ptr->words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 2

enum irq_state {
    IRQInactive = 0,
    IRQNotifyAEP = 1,
    IRQTimer = 2,
    IRQReserved = 3,
};
typedef uint32_t irq_state_t;

typedef struct dschedule {
    dom_t domain;
    uint32_t length;
} dschedule_t;

/* Arch-independent object types */

enum endpoint_state {
    EPState_Idle = 0,
    EPState_Send = 1,
    EPState_Recv = 2
};
typedef uint32_t endpoint_state_t;





enum async_endpoint_state {
    AEPState_Idle = 0,
    AEPState_Waiting = 1,
    AEPState_Active = 2
};
typedef uint32_t async_endpoint_state_t;

/* Declare object casts. As the sizes of objects may
 * differ by architecture, they are declared in the
 * arch structures.h
 */
# 72 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h"
/* Generate a tcb_t or cte_t pointer from a tcb block reference */




/* Generate a cte_t pointer from a tcb_t pointer */
# 88 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h"
static inline cap_t __attribute__((__const__))
Zombie_new(uint32_t number, uint32_t type, uint32_t ptr)
{
    uint32_t mask;

    if (type == (1ul<<(5))) {
        mask = ((1ul<<(4 + 1))-1ul);
    } else {
        mask = ((1ul<<(type + 1))-1ul);
    }

    return cap_zombie_cap_new((ptr & ~mask) | (number & mask), type);
}

static inline uint32_t __attribute__((__const__))
cap_zombie_cap_get_capZombieBits(cap_t cap)
{
    uint32_t type = cap_zombie_cap_get_capZombieType(cap);
    if (type == (1ul<<(5))) {
        return 4;
    }
    return ((type) & ((1ul<<(5))-1ul)); /* cnode radix */
}

static inline uint32_t __attribute__((__const__))
cap_zombie_cap_get_capZombieNumber(cap_t cap)
{
    uint32_t radix = cap_zombie_cap_get_capZombieBits(cap);
    return cap_zombie_cap_get_capZombieID(cap) & ((1ul<<(radix + 1))-1ul);
}

static inline uint32_t __attribute__((__const__))
cap_zombie_cap_get_capZombiePtr(cap_t cap)
{
    uint32_t radix = cap_zombie_cap_get_capZombieBits(cap);
    return cap_zombie_cap_get_capZombieID(cap) & ~((1ul<<(radix + 1))-1ul);
}

static inline cap_t __attribute__((__const__))
cap_zombie_cap_set_capZombieNumber(cap_t cap, uint32_t n)
{
    uint32_t radix = cap_zombie_cap_get_capZombieBits(cap);
    uint32_t ptr = cap_zombie_cap_get_capZombieID(cap) & ~((1ul<<(radix + 1))-1ul);
    return cap_zombie_cap_set_capZombieID(cap, ptr | (n & ((1ul<<(radix + 1))-1ul)));
}

/* Capability table entry (CTE) */
struct cte {
    cap_t cap;
    mdb_node_t cteMDBNode;
};
typedef struct cte cte_t;



/* Thread state */
enum _thread_state {
    ThreadState_Inactive = 0,
    ThreadState_Running,
    ThreadState_Restart,
    ThreadState_BlockedOnReceive,
    ThreadState_BlockedOnSend,
    ThreadState_BlockedOnReply,
    ThreadState_BlockedOnAsyncEvent,
    ThreadState_RunningVM,
    ThreadState_IdleThreadState
};
typedef uint32_t _thread_state_t;

/* A TCB CNode and a TCB are always allocated together, and adjacently,
 *  * such that they fill a 1024-byte aligned block. The CNode comes first. */
enum tcb_cnode_index {
    /* CSpace root, 16 bytes */
    tcbCTable = 0,

    /* VSpace root, 16 bytes */
    tcbVTable = 1,

    /* Reply cap slot, 16 bytes */
    tcbReply = 2,

    /* TCB of most recent IPC sender, 16 bytes */
    tcbCaller = 3,

    /* IPC buffer cap slot, 16 bytes */
    tcbBuffer = 4,

    tcbCNodeEntries
};
typedef uint32_t tcb_cnode_index_t;



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 2

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/hardware.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/hardware.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/hardware.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 2

/* code that is linked to physical addresses */


/* data that is linked to physical addresses */


/* code that is only used during kernel bootstrapping */


/* node-local data that is only used during kernel bootstrapping */


/* global data (shared by all nodes) but only used during kernel bootstrapping */


/* global data (shared by all nodes) */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/hardware.h" 2

enum vm_fault_type {
    IA32DataFault = 0,
    IA32InstructionFault = 1
};
typedef uint32_t vm_fault_type_t;

enum vm_page_size {
    IA32_SmallPage,
    IA32_LargePage
};
typedef uint32_t vm_page_size_t;

enum vm_page_map_type {
    IA32_MAPPING_PD = 0,
    IA32_MAPPING_EPT,
    IA32_MAPPING_IO
};
typedef uint32_t vm_page_map_type_t;

enum frameSizeConstants {
    IA32_4K_bits = 12,
    IA32_2M_bits = 21,
    IA32_4M_bits = 22,
    IA32_1G_bits = 30
};
# 53 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/hardware.h"
/* Any changes to this function need to be replicated in pageBitsForSize_phys.
 */
static inline unsigned int __attribute__((__const__))
pageBitsForSize(vm_page_size_t pagesize)
{
    switch (pagesize) {
    case IA32_SmallPage:
        return IA32_4K_bits;

    case IA32_LargePage:
        return IA32_4M_bits;

    default:
        _fail("Invalid page size", "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/hardware.h", 66, __func__);
    }
}

/* This function is a duplicate of pageBitsForSize, needed for calls that occur
 * before the MMU is turned on. Note that any changes to this function need to
 * be replicated in pageBitsForSize.
 */
__attribute__((__section__(".phys.text")))
static inline unsigned int __attribute__((__const__))
pageBitsForSize_phys(vm_page_size_t pagesize)
{
    switch (pagesize) {
    case IA32_SmallPage:
        return IA32_4K_bits;

    case IA32_LargePage:
        return IA32_4M_bits;

    default:
        _fail("Invalid page size", "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/hardware.h", 86, __func__);
    }
}

/* Returns the size of CPU's cacheline */
uint32_t __attribute__((__const__)) getCacheLineSize(void);
uint32_t __attribute__((__const__)) getCacheLineSizeBits(void);

/* Flushes a specific memory range from the CPU cache */
static inline void flushCacheLine(void* vaddr)
{
    __asm__ volatile("clflush %[vaddr]" : [vaddr] "+m"(*(volatile char *)vaddr));
}

void flushCacheRange(void* vaddr, uint32_t size_bits);

/* Disables a variety of prefetchers */
bool_t disablePrefetchers(void);
# 21 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/registerset.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/registerset.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/registerset.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/registerset.h" 2

/* Number of bytes required to store FPU state. */


/* Minimum hardware-enforced alignment needed for FPU state. */


/* These are the indices of the registers in the
 * saved thread context. The values are determined
 * by the order in which they're saved in the trap
 * handler.
 *
 * BEWARE:
 * You will have to adapt traps.S extensively if
 * you change anything in this enum!
 */
enum _register {
    /* general purpose registers */

    /* 0x00 */ EAX = 0,
    /* 0x04 */ EBX = 1,
    capRegister = 1,
    badgeRegister = 1,
    /* 0x08 */ ECX = 2,
    /* 0x0C */ EDX = 3,
    /* 0x10 */ ESI = 4,
    msgInfoRegister = 4,
    /* 0x14 */ EDI = 5,
    /* 0x18 */ EBP = 6,

    /* segment registers */

    /* 0x1C */ DS = 7,
    /* 0x20 */ ES = 8,
    /* 0x24 */ FS = 9,
    /* 0x28 */ GS = 10,

    /* virtual registers (not actually present in hardware) */

    /* 0x2C */ FaultEIP = 11,
    /* 0x30 */ TLS_BASE = 12,

    /* values pushed by the CPU directly */

    /* 0x34 */ Error = 13,
    /* 0x38 */ NextEIP = 14,
    /* 0x3C */ CS = 15,
    /* 0x40 */ EFLAGS = 16,
    /* 0x44 */ ESP = 17,
    /* 0x48 */ SS = 18,

    /* 0x4C */ n_contextRegisters = 19
};

typedef uint32_t register_t;

enum messageSizes {
    n_msgRegisters = 2,
    n_frameRegisters = 10,
    n_gpRegisters = 3,
    n_exceptionMessage = 3,
    n_syscallMessage = 10
};

extern const register_t msgRegisters[];
extern const register_t frameRegisters[];
extern const register_t gpRegisters[];
extern const register_t exceptionMessage[];
extern const register_t syscallMessage[];

extern const register_t crExitRegs[];


/* IA32 FPU context. */
struct user_fpu_state {
    uint8_t state[512];
};
typedef struct user_fpu_state user_fpu_state_t;

/* IA32 user-code context */
struct user_context {
    /* 76 bytes */
    word_t registers[n_contextRegisters];

    /*
     * Padding to 16-byte boundary, required by the IA32 FPU state saving
     * and restoring commands.
     */
    word_t padding;

    /* 512 bytes. */
    user_fpu_state_t fpuState;
};
typedef struct user_context user_context_t;

void Arch_initContext(user_context_t* context);
word_t sanitiseRegister(register_t reg, word_t v);

/* Ensure FPU state is aligned within user context. */
typedef int __assert_failed_fpu_state_alignment_valid[(__builtin_offsetof(user_context_t, fpuState) % 16 == 0) ? 1 : -1];
# 22 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 2
# 1 "./plat/machine/hardware_gen.h" 1



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 5 "./plat/machine/hardware_gen.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 6 "./plat/machine/hardware_gen.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 7 "./plat/machine/hardware_gen.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 8 "./plat/machine/hardware_gen.h" 2
struct vtd_pte {
    uint32_t words[2];
};
typedef struct vtd_pte vtd_pte_t;

static inline vtd_pte_t __attribute__((__const__))
vtd_pte_new(uint32_t addr, uint32_t cte_depth, uint32_t write, uint32_t read) {
    vtd_pte_t vtd_pte;

    vtd_pte.words[0] = 0;
    vtd_pte.words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((addr & ~0xfffff000ul) == ((0 && (addr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(addr & ~0xfffff000ul) == ((0 && (addr & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 21, __FUNCTION__);
    vtd_pte.words[0] |= (addr & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((cte_depth & ~0x7ul) == ((0 && (cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cte_depth & ~0x7ul) == ((0 && (cte_depth & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 24, __FUNCTION__);
    vtd_pte.words[0] |= (cte_depth & 0x7ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!((write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 27, __FUNCTION__);
    vtd_pte.words[0] |= (write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 30, __FUNCTION__);
    vtd_pte.words[0] |= (read & 0x1ul) << 0;

    return vtd_pte;
}

static inline void
vtd_pte_ptr_new(vtd_pte_t *vtd_pte_ptr, uint32_t addr, uint32_t cte_depth, uint32_t write, uint32_t read) {
    vtd_pte_ptr->words[0] = 0;
    vtd_pte_ptr->words[1] = 0;

    /* fail if user has passed bits that we will override */
    if(!((addr & ~0xfffff000ul) == ((0 && (addr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(addr & ~0xfffff000ul) == ((0 && (addr & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 42, __FUNCTION__);
    vtd_pte_ptr->words[0] |= (addr & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((cte_depth & ~0x7ul) == ((0 && (cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cte_depth & ~0x7ul) == ((0 && (cte_depth & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 45, __FUNCTION__);
    vtd_pte_ptr->words[0] |= (cte_depth & 0x7ul) << 8;
    /* fail if user has passed bits that we will override */
    if(!((write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(write & ~0x1ul) == ((0 && (write & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 48, __FUNCTION__);
    vtd_pte_ptr->words[0] |= (write & 0x1ul) << 1;
    /* fail if user has passed bits that we will override */
    if(!((read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(read & ~0x1ul) == ((0 && (read & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 51, __FUNCTION__);
    vtd_pte_ptr->words[0] |= (read & 0x1ul) << 0;
}

static inline uint32_t __attribute__((__const__))
vtd_pte_get_addr(vtd_pte_t vtd_pte) {
    uint32_t ret;
    ret = (vtd_pte.words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
vtd_pte_ptr_get_addr(vtd_pte_t *vtd_pte_ptr) {
    uint32_t ret;
    ret = (vtd_pte_ptr->words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
vtd_pte_ptr_get_cte_depth(vtd_pte_t *vtd_pte_ptr) {
    uint32_t ret;
    ret = (vtd_pte_ptr->words[0] & 0x700ul) >> 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
vtd_pte_ptr_get_write(vtd_pte_t *vtd_pte_ptr) {
    uint32_t ret;
    ret = (vtd_pte_ptr->words[0] & 0x2ul) >> 1;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
vtd_pte_ptr_get_read(vtd_pte_t *vtd_pte_ptr) {
    uint32_t ret;
    ret = (vtd_pte_ptr->words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct vtd_cte {
    uint32_t words[4];
};
typedef struct vtd_cte vtd_cte_t;

static inline void
vtd_cte_ptr_new(vtd_cte_t *vtd_cte_ptr, uint32_t did, uint32_t cte_depth, uint32_t rmrr, uint32_t aw, uint32_t asr, uint32_t translation_type, uint32_t present) {
    vtd_cte_ptr->words[0] = 0;
    vtd_cte_ptr->words[1] = 0;
    vtd_cte_ptr->words[2] = 0;
    vtd_cte_ptr->words[3] = 0;

    /* fail if user has passed bits that we will override */
    if(!((did & ~0xfffful) == ((0 && (did & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(did & ~0xfffful) == ((0 && (did & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 123, __FUNCTION__);
    vtd_cte_ptr->words[2] |= (did & 0xfffful) << 8;
    /* fail if user has passed bits that we will override */
    if(!((cte_depth & ~0x7ul) == ((0 && (cte_depth & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(cte_depth & ~0x7ul) == ((0 && (cte_depth & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 126, __FUNCTION__);
    vtd_cte_ptr->words[2] |= (cte_depth & 0x7ul) << 4;
    /* fail if user has passed bits that we will override */
    if(!((rmrr & ~0x1ul) == ((0 && (rmrr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(rmrr & ~0x1ul) == ((0 && (rmrr & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 129, __FUNCTION__);
    vtd_cte_ptr->words[2] |= (rmrr & 0x1ul) << 3;
    /* fail if user has passed bits that we will override */
    if(!((aw & ~0x7ul) == ((0 && (aw & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(aw & ~0x7ul) == ((0 && (aw & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 132, __FUNCTION__);
    vtd_cte_ptr->words[2] |= (aw & 0x7ul) << 0;
    /* fail if user has passed bits that we will override */
    if(!((asr & ~0xfffff000ul) == ((0 && (asr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(asr & ~0xfffff000ul) == ((0 && (asr & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 135, __FUNCTION__);
    vtd_cte_ptr->words[0] |= (asr & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((translation_type & ~0x3ul) == ((0 && (translation_type & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(translation_type & ~0x3ul) == ((0 && (translation_type & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 138, __FUNCTION__);
    vtd_cte_ptr->words[0] |= (translation_type & 0x3ul) << 2;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 141, __FUNCTION__);
    vtd_cte_ptr->words[0] |= (present & 0x1ul) << 0;
}

static inline uint32_t __attribute__((__pure__))
vtd_cte_ptr_get_cte_depth(vtd_cte_t *vtd_cte_ptr) {
    uint32_t ret;
    ret = (vtd_cte_ptr->words[2] & 0x70ul) >> 4;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
vtd_cte_ptr_get_rmrr(vtd_cte_t *vtd_cte_ptr) {
    uint32_t ret;
    ret = (vtd_cte_ptr->words[2] & 0x8ul) >> 3;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
vtd_cte_ptr_get_asr(vtd_cte_t *vtd_cte_ptr) {
    uint32_t ret;
    ret = (vtd_cte_ptr->words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
vtd_cte_ptr_get_present(vtd_cte_t *vtd_cte_ptr) {
    uint32_t ret;
    ret = (vtd_cte_ptr->words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct vtd_rte {
    uint32_t words[4];
};
typedef struct vtd_rte vtd_rte_t;

static inline vtd_rte_t __attribute__((__const__))
vtd_rte_new(uint32_t ctp, uint32_t present) {
    vtd_rte_t vtd_rte;

    vtd_rte.words[0] = 0;
    vtd_rte.words[1] = 0;
    vtd_rte.words[2] = 0;
    vtd_rte.words[3] = 0;

    /* fail if user has passed bits that we will override */
    if(!((ctp & ~0xfffff000ul) == ((0 && (ctp & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(ctp & ~0xfffff000ul) == ((0 && (ctp & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 204, __FUNCTION__);
    vtd_rte.words[0] |= (ctp & 0xfffff000ul) >> 0;
    /* fail if user has passed bits that we will override */
    if(!((present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(present & ~0x1ul) == ((0 && (present & (1ul << 31))) ? 0x0 : 0)", "./plat/machine/hardware_gen.h", 207, __FUNCTION__);
    vtd_rte.words[0] |= (present & 0x1ul) << 0;

    return vtd_rte;
}

static inline uint32_t __attribute__((__pure__))
vtd_rte_ptr_get_ctp(vtd_rte_t *vtd_rte_ptr) {
    uint32_t ret;
    ret = (vtd_rte_ptr->words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct pci_bar {
    uint32_t words[1];
};
typedef struct pci_bar pci_bar_t;

enum pci_bar_tag {
    pci_bar_pci_bar_mem = 0,
    pci_bar_pci_bar_io = 1
};
typedef enum pci_bar_tag pci_bar_tag_t;
# 23 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 2

/* Object sizes*/




enum tcb_arch_cnode_index {
    /* VSpace root for running any associated VCPU in */
    tcbArchEPTRoot = tcbCNodeEntries,
    tcbArchCNodeEntries
};

typedef struct arch_tcb {
    user_context_t tcbContext;


    /* Pointer to associated VCPU. NULL if not associated.
     * tcb->vcpu->tcb == tcb. */
    struct vcpu *vcpu;

} arch_tcb_t;

/* Access to the VCPU element of the tcb is done through a hard coded offset in traps.S
 * this assert makes sure they remain consistent. If this assert fails update the
 * offset in traps.S, and match it here */
typedef int __assert_failed_vcpu_offset_correct[(__builtin_offsetof(struct arch_tcb, vcpu) == 0x250) ? 1 : -1];;
# 165 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h"
/* Generate a vcpu_t pointer from a vcpu block reference */




/* helper structure for filling descriptor registers */
typedef struct gdt_idt_ptr {
    uint16_t limit;
    uint16_t basel;
    uint16_t baseh;
} gdt_idt_ptr_t;

typedef int __assert_failed_gdt_idt_ptr_packed[(sizeof(gdt_idt_ptr_t) == sizeof(uint16_t) * 3) ? 1 : -1];




enum vm_rights {
    VMKernelOnly = 1,
    VMReadOnly = 2,
    VMReadWrite = 3
};
typedef uint32_t vm_rights_t;

static inline unsigned int __attribute__((__const__))
cap_get_archCapSizeBits(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);

    switch (ctag) {
    case cap_frame_cap:
        return pageBitsForSize(cap_frame_cap_get_capFSize(cap));

    case cap_page_table_cap:
        return (10 + 2);

    case cap_page_directory_cap:
        return (10 + 2);

    case cap_pdpt_cap:
        return (0 + 0);


    case cap_vcpu_cap:
        return 14;

    case cap_io_port_cap:
        return 0;

    case cap_io_space_cap:
        return 0;

    case cap_io_page_table_cap:
        return (9 + 3);


    case cap_ipi_cap:
        return 0;


    case cap_ept_page_directory_pointer_table_cap:
        return ((9 +3)+1);

    case cap_ept_page_directory_cap:
        return (10 +2);

    case cap_ept_page_table_cap:
        return (10 +2);



    default:
        _fail("Invalid arch cap type", "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h", 239, __func__);
    }
}

static inline void * __attribute__((__const__))
cap_get_archCapPtr(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);

    switch (ctag) {

    case cap_frame_cap:
        return (void *)(cap_frame_cap_get_capFBasePtr(cap));

    case cap_page_table_cap:
        return ((pde_t *)(cap_page_table_cap_get_capPTBasePtr(cap)));

    case cap_page_directory_cap:
        return ((pte_t *)(cap_page_directory_cap_get_capPDBasePtr(cap)));

    case cap_pdpt_cap:
        return ((pdpte_t*)(cap_pdpt_cap_get_capPDPTBasePtr(cap)));


    case cap_vcpu_cap:
        return (void*)(cap_vcpu_cap_get_capVCPUPtr(cap));


    case cap_io_port_cap:
        return ((void *)0);

    case cap_io_space_cap:
        return ((void *)0);

    case cap_io_page_table_cap:
        return (void *)(cap_io_page_table_cap_get_capIOPTBasePtr(cap));


    case cap_ipi_cap:
        return ((void *)0);


    case cap_ept_page_directory_pointer_table_cap:
        return ((ept_pdpte_t *)((uint32_t)cap_ept_page_directory_pointer_table_cap_get_capPDPTBasePtr(cap) - (1 << (9 +3))));

    case cap_ept_page_directory_cap:
        return ((ept_pde_t *)(cap_ept_page_directory_cap_get_capPDBasePtr(cap)));

    case cap_ept_page_table_cap:
        return ((ept_pte_t *)(cap_ept_page_table_cap_get_capPTBasePtr(cap)));


    default:
        _fail("Invalid arch cap type", "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h", 294, __func__);
    }
}
# 182 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 2

static inline word_t __attribute__((__const__))
wordFromVMRights(vm_rights_t vm_rights)
{
    return (word_t)vm_rights;
}

static inline vm_rights_t __attribute__((__const__))
vmRightsFromWord(word_t w)
{
    return (vm_rights_t)w;
}

static inline vm_attributes_t __attribute__((__const__))
vmAttributesFromWord(word_t w)
{
    vm_attributes_t attr;

    attr.words[0] = w;
    return attr;
}

/* Ensure object sizes are sane */
typedef int __assert_failed_cte_size_sane[(sizeof(cte_t) <= (1 << 4)) ? 1 : -1];
typedef int __assert_failed_ep_size_sane[(sizeof(endpoint_t) <= (1 << 4)) ? 1 : -1];
typedef int __assert_failed_aep_size_sane[(sizeof(async_endpoint_t) <= (1 << 4)) ? 1 : -1];

static inline word_t mdb_node_get_cdtLeft(mdb_node_t mdb)
{
    word_t cte = mdb_node_get_cdtLeft_(mdb) << 2;
    return cte == 0 ? 0 : cte | 0xE0000000;
}

static inline word_t mdb_node_get_cdtRight(mdb_node_t mdb)
{
    word_t cte = mdb_node_get_cdtRight_(mdb) << 2;
    return cte == 0 ? 0 : cte | 0xE0000000;
}

static inline void mdb_node_ptr_set_cdtLeft(mdb_node_t *mdb, word_t cte)
{
    if(!((cte & ((1ul<<(2))-1ul)) == 0)) _assert_fail("(cte & MASK(2)) == 0", "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h", 223, __FUNCTION__);
    mdb_node_ptr_set_cdtLeft_(mdb, (cte & 0x1FFFFFFF) >> 2);
}

static inline void mdb_node_ptr_set_cdtRight(mdb_node_t *mdb, word_t cte)
{
    if(!((cte & ((1ul<<(2))-1ul)) == 0)) _assert_fail("(cte & MASK(2)) == 0", "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h", 229, __FUNCTION__);
    mdb_node_ptr_set_cdtRight_(mdb, (cte & 0x1FFFFFFF) >> 2);
}

/* TCB: size 64 bytes + sizeof(arch_tcb_t) (aligned to nearest power of 2) */
struct tcb {
    /* arch specific tcb state (including context)*/
    arch_tcb_t tcbArch;

    /* Thread state, 12 bytes */
    thread_state_t tcbState;

    /* Bound AEP 4 bytes */
    async_endpoint_t *boundAsyncEndpoint;

    /* Current fault, 8 bytes */
    fault_t tcbFault;

    /* Current lookup failure, 8 bytes */
    lookup_fault_t tcbLookupFailure;

    /* Domain, 1 byte (packed to 4) */
    uint32_t tcbDomain;

    /* Priority, 1 byte (packed to 4) */
    uint32_t tcbPriority;

    /* Timeslice remaining, 4 bytes */
    word_t tcbTimeSlice;

    /* Capability pointer to thread fault handler, 4 bytes */
    cptr_t tcbFaultHandler;

    /* userland virtual address of thread IPC buffer, 4 bytes */
    word_t tcbIPCBuffer;

    /* Previous and next pointers for endpoint & scheduler queues, 16 bytes */
    struct tcb* tcbSchedNext;
    struct tcb* tcbSchedPrev;
    struct tcb* tcbEPNext;
    struct tcb* tcbEPPrev;


    /* Use any remaining space for a thread name */
    char tcbName[];

};
typedef struct tcb tcb_t;

/* Ensure TCB size is sane. */
typedef int __assert_failed_tcb_size_sane[((1 << (4 + 4)) + sizeof(tcb_t) <= (1 << 10)) ? 1 : -1];



/* helper functions */

static inline word_t __attribute__((__const__))
isArchCap(cap_t cap)
{
    return (cap_get_capType(cap) % 2);
}

static inline unsigned int __attribute__((__const__))
cap_get_capSizeBits(cap_t cap)
{

    cap_tag_t ctag;

    ctag = cap_get_capType(cap);

    switch (ctag) {
    case cap_untyped_cap:
        return cap_untyped_cap_get_capBlockSize(cap);

    case cap_endpoint_cap:
        return 4;

    case cap_async_endpoint_cap:
        return 4;

    case cap_cnode_cap:
        return cap_cnode_cap_get_capCNodeRadix(cap) + 4;

    case cap_thread_cap:
        return 10;

    case cap_zombie_cap: {
        uint32_t type = cap_zombie_cap_get_capZombieType(cap);
        if (type == (1ul<<(5))) {
            return 10;
        }
        return ((type) & ((1ul<<(5))-1ul)) + 4;
    }

    case cap_null_cap:
        return 0;

    case cap_domain_cap:
        return 0;

    case cap_reply_cap:
        return 0;

    case cap_irq_control_cap:
        return 0;

    case cap_irq_handler_cap:
        return 0;

    default:
        return cap_get_archCapSizeBits(cap);
    }

}

static inline void * __attribute__((__const__))
cap_get_capPtr(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);

    switch (ctag) {
    case cap_untyped_cap:
        return ((word_t *)(cap_untyped_cap_get_capPtr(cap)));

    case cap_endpoint_cap:
        return ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(cap)));

    case cap_async_endpoint_cap:
        return ((async_endpoint_t *)(cap_async_endpoint_cap_get_capAEPPtr(cap)));

    case cap_cnode_cap:
        return ((cte_t *)(cap_cnode_cap_get_capCNodePtr(cap)));

    case cap_thread_cap:
        return (((cte_t *)((unsigned int)(cap_thread_cap_get_capTCBPtr(cap))&~((1ul<<(10))-1ul)))+(0));

    case cap_zombie_cap:
        return ((cte_t *)(cap_zombie_cap_get_capZombiePtr(cap)));

    case cap_domain_cap:
        return ((void *)0);

    case cap_reply_cap:
        return ((void *)0);

    case cap_irq_control_cap:
        return ((void *)0);

    case cap_irq_handler_cap:
        return ((void *)0);
    default:
        return cap_get_archCapPtr(cap);

    }
}

static inline unsigned int __attribute__((__const__))
cap_get_capBadge(cap_t cap)
{
    switch (cap_get_capType(cap)) {
    case cap_endpoint_cap:
        return cap_endpoint_cap_get_capEPBadge(cap);
    case cap_async_endpoint_cap:
        return cap_async_endpoint_cap_get_capAEPBadge(cap);
    }
    return 0;
}

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/capspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/capspace.h" 2

enum capSpaceType {
    /* Start at 1 so we can detected unitialized elements in debug mode when doing array lookups */
    capSpaceUntypedMemory = 1,
    capSpaceTypedMemory,
    capSpaceIRQ,
    capSpaceIOPort,

    capSpaceIOSpace,

    capSpaceIPI,
    capSpaceDomain,
};

static inline int __attribute__((__const__))
cap_get_capSpaceType(cap_t cap)
{
    cap_tag_t c_type;
    int type;
    static const int spaceType[] = {
        [cap_endpoint_cap] = capSpaceTypedMemory,
        [cap_async_endpoint_cap] = capSpaceTypedMemory,
        [cap_cnode_cap] = capSpaceTypedMemory,
        [cap_thread_cap] = capSpaceTypedMemory,
        [cap_frame_cap] = capSpaceTypedMemory,
        [cap_page_table_cap] = capSpaceTypedMemory,
        [cap_page_directory_cap] = capSpaceTypedMemory,
        [cap_pdpt_cap] = capSpaceTypedMemory,
        [cap_zombie_cap] = capSpaceTypedMemory,
        [cap_domain_cap] = capSpaceDomain,
        [cap_untyped_cap] = capSpaceUntypedMemory,
        [cap_irq_control_cap] = capSpaceIRQ,
        [cap_irq_handler_cap] = capSpaceIRQ,

        [cap_vcpu_cap] = capSpaceTypedMemory,

        [cap_io_port_cap] = capSpaceIOPort,

        [cap_io_space_cap] = capSpaceIOSpace,
        [cap_io_page_table_cap] = capSpaceTypedMemory,


        [cap_ept_page_directory_pointer_table_cap] = capSpaceTypedMemory,
        [cap_ept_page_directory_cap] = capSpaceTypedMemory,
        [cap_ept_page_table_cap] = capSpaceTypedMemory,

        [cap_ipi_cap] = capSpaceIPI,
    };
    c_type = cap_get_capType(cap);
    if(!(c_type < (sizeof(typeof(spaceType))/sizeof(typeof((spaceType)[0]))))) _assert_fail("c_type < ARRAY_SIZE(spaceType)", "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/capspace.h", 64, __FUNCTION__);
    type = spaceType[c_type];
    /* if type is 0 then it means the value returned by cap_get_capType was not
     * defined in the lookup table and got a default value of 0 */
    if(!(type != 0)) _assert_fail("type != 0", "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/capspace.h", 68, __FUNCTION__);
    return type;
}

static inline void * __attribute__((__const__))
cap_get_capSpacePtr(cap_t cap)
{
    switch (cap_get_capType(cap)) {
    case cap_domain_cap:
        return (void*)0;
    case cap_irq_control_cap:
        return (void*)0;
    case cap_irq_handler_cap:
        return (void*)cap_irq_handler_cap_get_capIRQ(cap);
    case cap_reply_cap:
        return (void*)cap_reply_cap_get_capTCBPtr(cap);
    case cap_io_port_cap:
        return (void*)cap_io_port_cap_get_capIOPortFirstPort(cap);

    case cap_io_space_cap:
        return (void*)cap_io_space_cap_get_capPCIDevice(cap);

    case cap_ipi_cap:
        return (void*)0;
    default:
        return cap_get_capPtr(cap);
    }
}

static inline unsigned int __attribute__((__const__))
cap_get_capSpaceSize(cap_t cap)
{
    switch (cap_get_capType(cap)) {
    case cap_irq_control_cap:
        return 0xff;
    case cap_irq_handler_cap:
        return 1;
    case cap_reply_cap:
        return 1;
    case cap_domain_cap:
        return 1;
    case cap_io_port_cap:
        return cap_io_port_cap_get_capIOPortLastPort(cap) - cap_io_port_cap_get_capIOPortFirstPort(cap);

    case cap_io_space_cap:
        return 1;

    case cap_ipi_cap:
        return 1;
    default:
        return (1ul<<(cap_get_capSizeBits(cap)));
    }
}

static inline unsigned int __attribute__((__const__))
cap_get_capExtraComp(cap_t cap)
{
    switch (cap_get_capType(cap)) {
    case cap_frame_cap:
        if (!cap_frame_cap_get_capFMappedObject(cap)) {
            return 0;
        }
        switch (cap_frame_cap_get_capFMappedType(cap)) {
        case IA32_MAPPING_PD:
            switch (cap_frame_cap_get_capFSize(cap)) {
            case IA32_SmallPage:
                return ((unsigned int)(((pte_t *)(cap_frame_cap_get_capFMappedObject(cap))) + cap_frame_cap_get_capFMappedIndex(cap)));
            case IA32_LargePage:
                return ((unsigned int)(((pde_t *)(cap_frame_cap_get_capFMappedObject(cap))) + cap_frame_cap_get_capFMappedIndex(cap)));
            default:
                _fail("Unknown frame size", "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/capspace.h", 138, __func__);
            }

        case IA32_MAPPING_EPT:
            switch (cap_frame_cap_get_capFSize(cap)) {
            case IA32_SmallPage:
                return ((unsigned int)(((ept_pte_t *)(cap_frame_cap_get_capFMappedObject(cap))) + cap_frame_cap_get_capFMappedIndex(cap)));
            case IA32_LargePage:
                return ((unsigned int)(((ept_pde_t *)(cap_frame_cap_get_capFMappedObject(cap))) + cap_frame_cap_get_capFMappedIndex(cap)));
            default:
                _fail("Unknown frame size", "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/capspace.h", 148, __func__);
            }


        case IA32_MAPPING_IO:
            switch (cap_frame_cap_get_capFSize(cap)) {
            case IA32_SmallPage:
                return ((unsigned int)(((vtd_pte_t*)(cap_frame_cap_get_capFMappedObject(cap))) + cap_frame_cap_get_capFMappedIndex(cap)));
            case IA32_LargePage:
                return ((unsigned int)(((vtd_pte_t*)(cap_frame_cap_get_capFMappedObject(cap))) + cap_frame_cap_get_capFMappedIndex(cap)));
            default:
                _fail("Unknown frame size", "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/capspace.h", 159, __func__);
            }

        default:
            _fail("Unknown mapping type for frame", "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/capspace.h", 163, __func__);
        }
    case cap_page_table_cap:
        if (!cap_page_table_cap_get_capPTMappedObject(cap)) {
            return 0;
        }
        return ((unsigned int)(((pde_t *)(cap_page_table_cap_get_capPTMappedObject(cap))) + cap_page_table_cap_get_capPTMappedIndex(cap)));
    case cap_page_directory_cap:
        if (!cap_page_directory_cap_get_capPDMappedObject(cap)) {
            return 0;
        }
        return ((unsigned int)(((pde_t *)(cap_page_directory_cap_get_capPDMappedObject(cap))) + cap_page_directory_cap_get_capPDMappedIndex(cap)));

    case cap_ept_page_directory_cap:
        if (!cap_ept_page_directory_cap_get_capPDMappedObject(cap)) {
            return 0;
        }
        return ((unsigned int)(((ept_pdpte_t *)(cap_ept_page_directory_cap_get_capPDMappedObject(cap))) + cap_ept_page_directory_cap_get_capPDMappedIndex(cap)))
                                                                                    ;
    case cap_ept_page_table_cap:
        if (!cap_ept_page_table_cap_get_capPTMappedObject(cap)) {
            return 0;
        }
        return ((unsigned int)(((ept_pde_t *)(cap_ept_page_table_cap_get_capPTMappedObject(cap))) + cap_ept_page_table_cap_get_capPTMappedIndex(cap)))
                                                                              ;


    case cap_io_space_cap:
        return cap_io_space_cap_get_capDomainID(cap);
    case cap_io_page_table_cap:
        if (!cap_io_page_table_cap_get_capIOPTMappedObject(cap)) {
            return 0;
        }
        if (cap_io_page_table_cap_get_capIOPTLevel(cap) == 0) {
            return ((unsigned int)(((vtd_cte_t*)(cap_io_page_table_cap_get_capIOPTMappedObject(cap))) + cap_io_page_table_cap_get_capIOPTMappedIndex(cap)))
                                                                                   ;
        } else {
            return ((unsigned int)(((vtd_pte_t*)(cap_io_page_table_cap_get_capIOPTMappedObject(cap))) + cap_io_page_table_cap_get_capIOPTMappedIndex(cap)))
                                                                                   ;
        }

    default:
        return 0;
    }
}

static inline unsigned int const
cte_depth_bits_type(cap_tag_t ctag)
{

    switch (ctag) {

    case cap_ept_page_directory_cap:
    case cap_ept_page_table_cap:
        return 3;


    case cap_io_page_table_cap:
        return 3;

    case cap_page_directory_cap:
        return 3;
    case cap_page_table_cap:
        return 3;
    case cap_frame_cap:

        /* EPT paging strucutures only have 3 bits free, and we do not
         * know in advance where this will get mapped */
        return 2;



    default:
        return 5;

    }

}

static inline unsigned int const
cte_depth_bits_cap(cap_t cap)
{
    return cte_depth_bits_type(cap_get_capType(cap));
}
# 400 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 2
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/compound_types.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/compound_types.h" 2

struct pde_range {
    pde_t *pd;
    unsigned int start;
    unsigned int length;
};
typedef struct pde_range pde_range_t;

struct pte_range {
    pte_t *pt;
    unsigned int start;
    unsigned int length;
};
typedef struct pte_range pte_range_t;

typedef cte_t *cte_ptr_t;

struct extra_caps {
    cte_ptr_t excaprefs[((1ul<<(seL4_MsgExtraCapBits))-1)];
};
typedef struct extra_caps extra_caps_t;
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 2
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/benchmark.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/benchmark.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/benchmark.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/benchmark.h" 2
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/benchmark.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/io.h" 2

void out8(uint16_t port, uint8_t value);
void out16(uint16_t port, uint16_t value);
void out32(uint16_t port, uint32_t value);
uint8_t in8(uint16_t port);
uint16_t in16(uint16_t port);
uint32_t in32(uint16_t port);

/* these versions are linked to physical addresses */
static inline void __attribute__((__section__(".phys.text")))
out8_phys(uint16_t port, uint8_t value)
{
    __asm__ volatile("outb %[value], %[port]" :: [port] "d"(port), [value] "a"(value));
}

static inline uint8_t __attribute__((__section__(".phys.text")))
in8_phys(uint16_t port)
{
    uint8_t value;
    __asm__ volatile("inb %[port], %[value]" : [value] "=a"(value) : [port] "d" (port));
    return value;
}



void serial_init(uint16_t port);
void console_putchar(char c);
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 2


unsigned int puts(const char *s) __attribute__((externally_visible));
/* for prints that you want enabled in both DEBUG and RELEASE_PRINTF modes,
   use kprintf directly */
unsigned int kprintf(const char *format, ...) __attribute__((externally_visible));
unsigned int print_unsigned_long(unsigned long x, unsigned int ui_base) __attribute__((externally_visible));



/* printf will result in output */
# 40 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h"
/* release_printfs will NOT result in output */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/benchmark.h" 2
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/pat.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/cpu_registers.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/cpu_registers.h"
/* We use a dummy variable to synchronize reads and writes to the control registers.
 * this allows us to write inline asm blocks that do not have enforced memory
 * clobbers for ordering. */
static unsigned long __control_reg_order;

static inline unsigned long read_cr3(void)
{
    unsigned long val;
    __asm__ volatile("movl %%cr3, %0" : "=r"(val), "=m"(__control_reg_order));
    return val;
}

static inline void write_cr3(unsigned long val)
{
    __asm__ volatile("movl %0, %%cr3" :: "r"(val), "m"(__control_reg_order));
}

static inline unsigned long read_cr0(void)
{
    unsigned long val;
    __asm__ volatile("movl %%cr0, %0" : "=r"(val), "=m"(__control_reg_order));
    return val;
}

static inline void write_cr0(unsigned long val)
{
    __asm__ volatile("movl %0, %%cr0" :: "r"(val), "m"(__control_reg_order));
}

static inline unsigned long read_cr2(void)
{
    unsigned long val;
    __asm__ volatile("movl %%cr2, %0" : "=r"(val), "=m"(__control_reg_order));
    return val;
}

static inline unsigned long read_cr4(void)
{
    unsigned long val;
    __asm__ volatile("movl %%cr4, %0" : "=r"(val), "=m"(__control_reg_order));
    return val;
}

static inline void write_cr4(unsigned long value)
{
    __asm__ volatile("movl %0, %%cr4" :: "r"(value), "m"(__control_reg_order));
}
# 20 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/devices.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/devices.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/hardware.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/hardware.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */







/* interrupt vectors (corresponds to IDT entries) */



typedef enum _interrupt_t {
    int_invalid = -1,
    int_unimpl_dev = 0x07,
    int_page_fault = 0x0e,
    int_irq_min = 0x20, /* First IRQ. */




    int_irq_isa_min = int_irq_min,
    int_irq_isa_max = int_irq_min + 16 - 1,

    int_irq_msi_min,
    int_irq_msi_max = int_irq_msi_min + 0xd,
    int_iommu,
    int_timer,
    int_irq_ipi_min,
    int_irq_ipi_max = int_irq_ipi_min + 0xf,
    int_irq_max = int_timer, /* Last IRQ. */
    int_trap_min,
    int_trap_max = 0xfe,
    int_spurious = 0xff,
    int_max = 0xff
} interrupt_t;

/* Construction of most of the interrupt numbers was relative by padding
 * off previous values. Therefore to ensure we didn't overflow just need
 * to ensure int_trap_min is less than int_trap_max */
typedef int __assert_failed_interrupt_numbers_not_overflow[(int_trap_min < int_trap_max) ? 1 : -1];;


typedef enum _irq_t {
    irqInvalid = -1,






    irq_isa_min = int_irq_isa_min - 0x20,
    irq_controller_min = irq_isa_min,
    irq_isa_max = int_irq_isa_max - 0x20,
    irq_controller_max = irq_isa_max,

    irq_msi_min = int_irq_msi_min - 0x20,
    irq_msi_max = int_irq_msi_max - 0x20,
    irq_iommu = int_iommu - 0x20,
    irq_timer = int_timer - 0x20,
    irq_ipi_min = int_irq_ipi_min - 0x20,
    irq_ipi_max = int_irq_ipi_max - 0x20,
    maxIRQ = int_timer - 0x20
} irq_t;





/* The text mode framebuffer exists part way into the video ram region */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/hardware.h" 2


/* WARNING: some of these constants are also defined in linker.lds */
# 40 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/hardware.h"
void handleReservedIRQ(irq_t irq);
void maskInterrupt(bool_t mask, irq_t irq);
void ackInterrupt(irq_t irq);
irq_t getActiveIRQ(void);
bool_t isIRQPending(void);
void setInterruptMode(irq_t irq, bool_t levelTrigger, bool_t polarityLow);
void resetTimer(void);

void handleSpuriousIRQ(void);
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/devices.h" 2



/* Whether the IOAPIC exists or not will determine where we start mapping
 * the IOMMUs. It is fine to define the DRHU_START even if CONFIG_IOMMU is not
 * set as it will just pollute the preprocessor namespace */
# 20 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 2


# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/iospace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/iospace.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/errors.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




typedef enum {
    seL4_NoError = 0,
    seL4_InvalidArgument,
    seL4_InvalidCapability,
    seL4_IllegalOperation,
    seL4_RangeError,
    seL4_AlignmentError,
    seL4_FailedLookup,
    seL4_TruncatedMessage,
    seL4_DeleteFirst,
    seL4_RevokeFirst,
    seL4_NotEnoughMemory,
} seL4_Error;
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 2
/* These datatypes differ markedly from haskell, due to the
 * different implementation of the various fault monads */


enum exception {
    EXCEPTION_NONE,
    EXCEPTION_FAULT,
    EXCEPTION_LOOKUP_FAULT,
    EXCEPTION_SYSCALL_ERROR,
    EXCEPTION_PREEMPTED
};
typedef uint32_t exception_t;

typedef uint32_t syscall_error_type_t;

struct syscall_error {
    unsigned int invalidArgumentNumber;
    unsigned int invalidCapNumber;
    word_t rangeErrorMin;
    word_t rangeErrorMax;
    word_t memoryLeft;
    bool_t failedLookupWasSource;

    syscall_error_type_t type;
};
typedef struct syscall_error syscall_error_t;

extern lookup_fault_t current_lookup_fault;
extern fault_t current_fault;
extern syscall_error_t current_syscall_error;
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/iospace.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/iospace.h" 2

static inline int vtd_get_root_index(dev_id_t dev)
{
    return (dev >> 8) & 0xff;
}

static inline int vtd_get_context_index(dev_id_t dev)
{
    return dev & 0xff;
}

struct lookupIOPTSlot_ret {
    exception_t status;
    vtd_pte_t* iopt;
    int index;
    int level;
};
typedef struct lookupIOPTSlot_ret lookupIOPTSlot_ret_t;

cap_t master_iospace_cap(void);
exception_t decodeIA32IOPTInvocation(word_t label, uint32_t length, cte_t* slot, cap_t cap, extra_caps_t extraCaps, word_t* buffer);
exception_t decodeIA32IOMapInvocation(word_t label, uint32_t length, cte_t* slot, cap_t cap, extra_caps_t extraCaps, word_t* buffer);
void unmapIOPage(cap_t cap);
vtd_cte_t *lookupVTDContextSlot(cap_t cap);
void unmapVTDContextEntry(cap_t cap);
void unmapVTDPT(vtd_pte_t *parent, vtd_pte_t *child, uint32_t index);
void unmapAllIOPT(vtd_pte_t *pt, int level);
void unmapIOPTCap(cap_t cap);
# 23 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 2


extern interrupt_t ia32KScurInterrupt;
extern tss_t ia32KStss;
extern gdt_entry_t ia32KSgdt[];
extern tcb_t *ia32KSfpuOwner;
extern pdpte_t *ia32KSkernelPDPT;
extern pde_t* ia32KSkernelPD;
extern pte_t* ia32KSkernelPT;
extern uint32_t ia32KScacheLineSizeBits;
extern idt_entry_t ia32KSidt[];
extern user_fpu_state_t ia32KSnullFpuState __attribute__((__aligned__(16)));
extern paddr_t ia32KSCurrentPD;


extern uint32_t ia32KSnumDrhu;
extern vtd_rte_t* ia32KSvtdRootTable;
extern uint32_t ia32KSnumIOPTLevels;
extern uint32_t ia32KSnumIODomainIDBits;
extern int ia32KSFirstValidIODomain;



extern uint16_t ia32KSconsolePort;
extern uint16_t ia32KSdebugPort;


extern node_id_t ia32KSNodeID;
extern uint32_t ia32KSNumNodes;
extern cpu_id_t* ia32KSCPUList;
# 21 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 2
# 43 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h"
/* This article discloses prefetcher control on Intel processors; Nehalem, Westmere, Sandy Bridge,
   Ivy Bridge, Haswell, and Broadwell. It is currently undocumented in the regular intel manuals.
   https://software.intel.com/en-us/articles/disclosure-of-hw-prefetcher-control-on-some-intel-processors */






word_t __attribute__((__pure__)) getRestartPC(tcb_t *thread);
void setNextPC(tcb_t *thread, word_t v);

/* Address space control */
static inline paddr_t getCurrentPD(void)
{
    return ia32KSCurrentPD;
}

static inline void setCurrentPD(paddr_t addr)
{
    ia32KSCurrentPD = addr;
    write_cr3(addr);
}

/* TLB control */
static inline void invalidateTLB(void)
{
    /* rewrite the current page directory */
    write_cr3(ia32KSCurrentPD);
}

static inline void invalidateTLBentry(vptr_t vptr)
{
    __asm__ volatile("invlpg (%[vptr])" :: [vptr] "r"(vptr));
}

/* Invalidates page structures cache */
static inline void invalidatePageStructureCache(void)
{
    /* invalidate an arbitrary line to invalidate the page structure cache */
    invalidateTLBentry(0);
}

/* Flushes entire CPU Cache */
static inline void ia32_wbinvd(void)
{
    __asm__ volatile("wbinvd" ::: "memory");
}

/* GDT installation */
void ia32_install_gdt(gdt_idt_ptr_t* gdt_idt_ptr);

/* IDT installation */
void ia32_install_idt(gdt_idt_ptr_t* gdt_idt_ptr);

/* LDT installation */
void ia32_install_ldt(uint32_t ldt_sel);

/* TSS installation */
void ia32_install_tss(uint32_t tss_sel);

/* Get page fault address from CR2 register */
static inline uint32_t getFaultAddr(void)
{
    return read_cr2();
}

/* Get current stack pointer */
static inline void* get_current_esp(void)
{
    uint32_t stack;
    void *result;
    __asm__ volatile("movl %[stack_address], %[result]" : [result] "=r"(result) : [stack_address] "r"(&stack));
    return result;
}

/* Cleaning memory before user-level access */
static inline void clearMemory(void* ptr, unsigned int bits)
{
    memzero(ptr, (1ul<<(bits)));
    /* no cleaning of caches necessary on IA-32 */
}

/* Initialises MSRs required to setup sysenter and sysexit */
void init_sysenter_msrs(void);

static uint64_t ia32_rdmsr(const uint32_t reg)
{
    uint64_t value;
    __asm__ volatile("rdmsr" : "=A"(value) : "c"(reg));
    return value;
}

/* Read model specific register */
static inline uint32_t ia32_rdmsr_low(const uint32_t reg)
{
    return (uint32_t)ia32_rdmsr(reg);
}

static inline uint32_t ia32_rdmsr_high(const uint32_t reg)
{
    return (uint32_t)(ia32_rdmsr(reg) >> 32ull);
}

/* Write model specific register */
static inline void ia32_wrmsr(const uint32_t reg, const uint32_t val_high, const uint32_t val_low)
{
    uint64_t val = ((uint64_t)val_high << 32ull) | (uint64_t)val_low;
    __asm__ volatile("wrmsr" :: "A"(val), "c"(reg));
}

/* Read different parts of CPUID */
static inline uint32_t ia32_cpuid_edx(uint32_t eax, uint32_t ecx)
{
    uint32_t edx, ebx;
    __asm__ volatile("cpuid"
                 : "=a" (eax),
                 "=b" (ebx),
                 "=c" (ecx),
                 "=d" (edx)
                 : "a" (eax), "c" (ecx)
                 : "memory");
    return edx;
}

static inline uint32_t ia32_cpuid_eax(uint32_t eax, uint32_t ecx)
{
    uint32_t edx, ebx;
    __asm__ volatile("cpuid"
                 : "=a" (eax),
                 "=b" (ebx),
                 "=c" (ecx),
                 "=d" (edx)
                 : "a" (eax), "c" (ecx)
                 : "memory");
    return eax;
}

/* Read/write memory fence */
static inline void ia32_mfence(void)
{
    __asm__ volatile("mfence" ::: "memory");
}


void handle_vmexit(void);


/* sysenter entry point */
void handle_syscall(void);

void int_00(void);
void int_01(void);
void int_02(void);
void int_03(void);
void int_04(void);
void int_05(void);
void int_06(void);
void int_07(void);
void int_08(void);
void int_09(void);
void int_0a(void);
void int_0b(void);
void int_0c(void);
void int_0d(void);
void int_0e(void);
void int_0f(void);

void int_10(void);
void int_11(void);
void int_12(void);
void int_13(void);
void int_14(void);
void int_15(void);
void int_16(void);
void int_17(void);
void int_18(void);
void int_19(void);
void int_1a(void);
void int_1b(void);
void int_1c(void);
void int_1d(void);
void int_1e(void);
void int_1f(void);

void int_20(void);
void int_21(void);
void int_22(void);
void int_23(void);
void int_24(void);
void int_25(void);
void int_26(void);
void int_27(void);
void int_28(void);
void int_29(void);
void int_2a(void);
void int_2b(void);
void int_2c(void);
void int_2d(void);
void int_2e(void);
void int_2f(void);

void int_30(void);
void int_31(void);
void int_32(void);
void int_33(void);
void int_34(void);
void int_35(void);
void int_36(void);
void int_37(void);
void int_38(void);
void int_39(void);
void int_3a(void);
void int_3b(void);
void int_3c(void);
void int_3d(void);
void int_3e(void);
void int_3f(void);

void int_40(void);
void int_41(void);
void int_42(void);
void int_43(void);
void int_44(void);
void int_45(void);
void int_46(void);
void int_47(void);
void int_48(void);
void int_49(void);
void int_4a(void);
void int_4b(void);
void int_4c(void);
void int_4d(void);
void int_4e(void);
void int_4f(void);

void int_50(void);
void int_51(void);
void int_52(void);
void int_53(void);
void int_54(void);
void int_55(void);
void int_56(void);
void int_57(void);
void int_58(void);
void int_59(void);
void int_5a(void);
void int_5b(void);
void int_5c(void);
void int_5d(void);
void int_5e(void);
void int_5f(void);

void int_60(void);
void int_61(void);
void int_62(void);
void int_63(void);
void int_64(void);
void int_65(void);
void int_66(void);
void int_67(void);
void int_68(void);
void int_69(void);
void int_6a(void);
void int_6b(void);
void int_6c(void);
void int_6d(void);
void int_6e(void);
void int_6f(void);

void int_70(void);
void int_71(void);
void int_72(void);
void int_73(void);
void int_74(void);
void int_75(void);
void int_76(void);
void int_77(void);
void int_78(void);
void int_79(void);
void int_7a(void);
void int_7b(void);
void int_7c(void);
void int_7d(void);
void int_7e(void);
void int_7f(void);

void int_80(void);
void int_81(void);
void int_82(void);
void int_83(void);
void int_84(void);
void int_85(void);
void int_86(void);
void int_87(void);
void int_88(void);
void int_89(void);
void int_8a(void);
void int_8b(void);
void int_8c(void);
void int_8d(void);
void int_8e(void);
void int_8f(void);

void int_90(void);
void int_91(void);
void int_92(void);
void int_93(void);
void int_94(void);
void int_95(void);
void int_96(void);
void int_97(void);
void int_98(void);
void int_99(void);
void int_9a(void);
void int_9b(void);
void int_9c(void);
void int_9d(void);
void int_9e(void);
void int_9f(void);

void int_a0(void);
void int_a1(void);
void int_a2(void);
void int_a3(void);
void int_a4(void);
void int_a5(void);
void int_a6(void);
void int_a7(void);
void int_a8(void);
void int_a9(void);
void int_aa(void);
void int_ab(void);
void int_ac(void);
void int_ad(void);
void int_ae(void);
void int_af(void);

void int_b0(void);
void int_b1(void);
void int_b2(void);
void int_b3(void);
void int_b4(void);
void int_b5(void);
void int_b6(void);
void int_b7(void);
void int_b8(void);
void int_b9(void);
void int_ba(void);
void int_bb(void);
void int_bc(void);
void int_bd(void);
void int_be(void);
void int_bf(void);

void int_c0(void);
void int_c1(void);
void int_c2(void);
void int_c3(void);
void int_c4(void);
void int_c5(void);
void int_c6(void);
void int_c7(void);
void int_c8(void);
void int_c9(void);
void int_ca(void);
void int_cb(void);
void int_cc(void);
void int_cd(void);
void int_ce(void);
void int_cf(void);

void int_d0(void);
void int_d1(void);
void int_d2(void);
void int_d3(void);
void int_d4(void);
void int_d5(void);
void int_d6(void);
void int_d7(void);
void int_d8(void);
void int_d9(void);
void int_da(void);
void int_db(void);
void int_dc(void);
void int_dd(void);
void int_de(void);
void int_df(void);

void int_e0(void);
void int_e1(void);
void int_e2(void);
void int_e3(void);
void int_e4(void);
void int_e5(void);
void int_e6(void);
void int_e7(void);
void int_e8(void);
void int_e9(void);
void int_ea(void);
void int_eb(void);
void int_ec(void);
void int_ed(void);
void int_ee(void);
void int_ef(void);

void int_f0(void);
void int_f1(void);
void int_f2(void);
void int_f3(void);
void int_f4(void);
void int_f5(void);
void int_f6(void);
void int_f7(void);
void int_f8(void);
void int_f9(void);
void int_fa(void);
void int_fb(void);
void int_fc(void);
void int_fd(void);
void int_fe(void);
void int_ff(void);
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/machine/registerset.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/machine/registerset.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/machine/registerset.h" 2

static inline void
setRegister(tcb_t *thread, register_t reg, word_t w)
{
    thread->tcbArch.tcbContext.registers[reg] = w;
}

static inline word_t __attribute__((__pure__))
getRegister(tcb_t *thread, register_t reg)
{
    return thread->tcbArch.tcbContext.registers[reg];
}
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/machine/hardware.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/machine/hardware.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/machine/hardware.h" 2
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 2

/* platform independent functions */

static inline void *__attribute__((__const__))
paddr_to_pptr(paddr_t paddr)
{
    return (void *)(paddr + (0xe0000000 - 0x00000000));
}

static inline paddr_t __attribute__((__const__))
pptr_to_paddr(void *pptr)
{
    return (paddr_t)pptr - (0xe0000000 - 0x00000000);
}

static inline region_t __attribute__((__const__))
paddr_to_pptr_reg(p_region_t p_reg)
{
    return (region_t) {
        p_reg.start + (0xe0000000 - 0x00000000), p_reg.end + (0xe0000000 - 0x00000000)
    };
}

static inline p_region_t __attribute__((__const__))
pptr_to_paddr_reg(region_t reg)
{
    return (p_region_t) {
        reg.start - (0xe0000000 - 0x00000000), reg.end - (0xe0000000 - 0x00000000)
    };
}

static inline bool_t __attribute__((__const__))
inKernelWindow(void *pptr)
{
    paddr_t paddr = pptr_to_paddr(pptr);
    return ((paddr >= 0x00000000) && (paddr < ((-(1ul<<(IA32_4M_bits))) - (0xe0000000 - 0x00000000))));
}
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 2

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/tcb.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/tcb.h" 2

unsigned int setMRs_fault(tcb_t *sender, tcb_t* receiver, word_t *receiveIPCBuffer);
unsigned int setMRs_syscall_error(tcb_t *thread, word_t *receiveIPCBuffer);
void Arch_leaveVMAsyncTransfer(tcb_t *tcb);
word_t __attribute__((__const__)) Arch_decodeTransfer(word_t flags);
exception_t __attribute__((__const__)) Arch_performTransfer(word_t arch, tcb_t *tcb_src, tcb_t *tcb_dest);
# 19 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 2

struct slot_range {
    cte_t *cnode;
    unsigned int offset;
    unsigned int length;
};
typedef struct slot_range slot_range_t;

exception_t decodeCNodeInvocation(word_t label, unsigned int length,
                                  cap_t cap, extra_caps_t extraCaps,
                                  word_t *buffer);
exception_t invokeCNodeRevoke(cte_t *destSlot);
exception_t invokeCNodeDelete(cte_t *destSlot);
exception_t invokeCNodeRecycle(cte_t *destSlot);
exception_t invokeCNodeInsert(cap_t cap, cte_t *srcSlot, cte_t *destSlot);
exception_t invokeCNodeMove(cap_t cap, cte_t *srcSlot, cte_t *destSlot);
exception_t invokeCNodeRotate(cap_t cap1, cap_t cap2, cte_t *slot1,
                              cte_t *slot2, cte_t *slot3);
exception_t invokeCNodeSaveCaller(cte_t *destSlot);
void cteInsert(cap_t newCap, cte_t *srcSlot, cte_t *destSlot);
void cteMove(cap_t newCap, cte_t *srcSlot, cte_t *destSlot);
void capSwapForDelete(cte_t *slot1, cte_t *slot2);
void cteSwap(cap_t cap1, cte_t *slot1, cap_t cap2, cte_t *slot2);
exception_t cteRevoke(cte_t *slot);
exception_t cteDelete(cte_t *slot, bool_t exposed);
void cteDeleteOne(cte_t* slot);
exception_t cteRecycle(cte_t *slot);
void insertNewCap(cte_t *parent, cte_t *slot, cap_t cap);
void setupReplyMaster(tcb_t *thread);
bool_t __attribute__((__pure__)) isMDBParentOf(cte_t *cte_a, cte_t *cte_b);
exception_t ensureNoChildren(cte_t *slot);
exception_t ensureEmptySlot(cte_t *slot);
bool_t __attribute__((__pure__)) slotCapLongRunningDelete(cte_t *slot);
cte_t *getReceiveSlots(tcb_t *thread, word_t *buffer);
cap_transfer_t __attribute__((__pure__)) loadCapTransfer(word_t *buffer);
# 20 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 2


/* Maximum length of the tcb name, including null terminator */



struct tcb_queue {
    tcb_t *head;
    tcb_t *end;
};
typedef struct tcb_queue tcb_queue_t;

void tcbSchedEnqueue(tcb_t *tcb);
void tcbSchedAppend(tcb_t *tcb);
void tcbSchedDequeue(tcb_t *tcb);

tcb_queue_t tcbEPAppend(tcb_t *tcb, tcb_queue_t queue);
tcb_queue_t tcbEPDequeue(tcb_t *tcb, tcb_queue_t queue);

void setupCallerCap(tcb_t *sender, tcb_t *receiver);
void deleteCallerCap(tcb_t *receiver);

unsigned int copyMRs(tcb_t *sender, word_t *sendBuf, tcb_t *receiver,
                     word_t *recvBuf, unsigned int n);
exception_t decodeTCBInvocation(word_t label, unsigned int length, cap_t cap,
                                cte_t* slot, extra_caps_t extraCaps, bool_t call,
                                word_t *buffer);
exception_t decodeCopyRegisters(cap_t cap, unsigned int length,
                                extra_caps_t extraCaps, word_t *buffer);
exception_t decodeReadRegisters(cap_t cap, unsigned int length, bool_t call,
                                word_t *buffer);
exception_t decodeWriteRegisters(cap_t cap, unsigned int length, word_t *buffer);
exception_t decodeTCBConfigure(cap_t cap, unsigned int length,
                               cte_t* slot, extra_caps_t rootCaps, word_t *buffer);
exception_t decodeSetPriority(cap_t cap, unsigned int length, word_t *buffer);
exception_t decodeSetIPCBuffer(cap_t cap, unsigned int length,
                               cte_t* slot, extra_caps_t extraCaps, word_t *buffer);
exception_t decodeSetSpace(cap_t cap, unsigned int length,
                           cte_t* slot, extra_caps_t extraCaps, word_t *buffer);
exception_t decodeBindAEP(cap_t cap, extra_caps_t extraCaps);
exception_t decodeUnbindAEP(cap_t cap);
exception_t decodeSetEPTRoot(cap_t cap, extra_caps_t extraCaps);
exception_t decodeDomainInvocation(word_t label, unsigned int length,
                                   extra_caps_t extraCaps, word_t *buffer);

enum thread_control_flag {
    thread_control_update_priority = 0x1,
    thread_control_update_ipc_buffer = 0x2,
    thread_control_update_space = 0x4,
    thread_control_update_all = 0x7,
};

typedef uint32_t thread_control_flag_t;

exception_t invokeTCB_Suspend(tcb_t *thread);
exception_t invokeTCB_Resume(tcb_t *thread);
exception_t invokeTCB_ThreadControl(tcb_t *target, cte_t* slot, cptr_t faultep,
                                    prio_t priority, cap_t cRoot_newCap,
                                    cte_t *cRoot_srcSlot, cap_t vRoot_newCap,
                                    cte_t *vRoot_srcSlot, word_t bufferAddr,
                                    cap_t bufferCap, cte_t *bufferSrcSlot,
                                    thread_control_flag_t updateFlags);
exception_t invokeTCB_CopyRegisters(tcb_t *dest, tcb_t *src,
                                    bool_t suspendSource, bool_t resumeTarget,
                                    bool_t transferFrame, bool_t transferInteger,
                                    word_t transferArch);
exception_t invokeTCB_ReadRegisters(tcb_t *src, bool_t suspendSource,
                                    unsigned int n, word_t arch, bool_t call);
exception_t invokeTCB_WriteRegisters(tcb_t *dest, bool_t resumeTarget,
                                     unsigned int n, word_t arch, word_t *buffer);
exception_t invokeTCB_AEPControl(tcb_t *tcb, async_endpoint_t *aepptr);

cptr_t __attribute__((__pure__)) getExtraCPtr(word_t *bufferPtr, unsigned int i);
void setExtraBadge(word_t *bufferPtr, word_t badge, unsigned int i);

exception_t lookupExtraCaps(tcb_t* thread, word_t *bufferPtr, message_info_t info);

void setThreadName(tcb_t *thread, const char *name);
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 2

extern tcb_queue_t ksReadyQueues[] __attribute__((externally_visible));
extern word_t ksReadyQueuesL1Bitmap[1] __attribute__((externally_visible));
extern word_t ksReadyQueuesL2Bitmap[1][(256 / 32) + 1] __attribute__((externally_visible));
extern tcb_t *ksCurThread __attribute__((externally_visible));
extern tcb_t *ksIdleThread __attribute__((externally_visible));
extern tcb_t *ksSchedulerAction __attribute__((externally_visible));
extern word_t ksWorkUnitsCompleted;
extern cte_t *ksRootCTE __attribute__((externally_visible));
extern irq_state_t intStateIRQTable[] __attribute__((externally_visible));
extern cte_t *intStateIRQNode __attribute__((externally_visible));
extern const dschedule_t ksDomSchedule[];
extern const unsigned int ksDomScheduleLength;
extern uint32_t ksDomScheduleIdx;
extern dom_t ksCurDomain;
extern word_t ksDomainTime;
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/vspace.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/vspace.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/vspace.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/vspace.h" 2

struct lookupPDSlot_ret {
    exception_t status;
    pde_t* pdSlot;
    pde_t* pd;
    unsigned int pdIndex;
};
typedef struct lookupPDSlot_ret lookupPDSlot_ret_t;

void init_boot_pd(void);
void enable_paging(void);
bool_t map_kernel_window(
    pdpte_t* pdpt,
    pde_t* pd,
    pte_t* pt,
    p_region_t ndks_p_reg





    , uint32_t num_drhu,
    paddr_t* drhu_list

);

void *getValidNativeRoot(cap_t vspace_cap);
pde_t *get_boot_pd(void);
void* map_temp_boot_page(void* entry, uint32_t large_pages);
bool_t init_vm_state(pdpte_t *kernel_pdpt, pde_t* kernel_pd, pte_t* kernel_pt);
void init_dtrs(void);
void map_it_pt_cap(cap_t pt_cap);
void map_it_pd_cap(cap_t pd_cap);
void map_it_frame_cap(cap_t frame_cap);
bool_t init_pat_msr(void);

/* ==================== BOOT CODE FINISHES HERE ==================== */

void idle_thread(void);


bool_t isVTableRoot(cap_t cap);
lookupPDSlot_ret_t lookupPDSlot(void *vspace, vptr_t vptr);
void copyGlobalMappings(void* new_vspace);
word_t* __attribute__((__pure__)) lookupIPCBuffer(bool_t isReceiver, tcb_t *thread);
exception_t handleVMFault(tcb_t *thread, vm_fault_type_t vm_faultType);
void flushAllPageTables(pde_t *pd);
void unmapAllPageDirectories(pdpte_t *pdpt);
void flushAllPageDirectories(pdpte_t *pdpt);
void unmapPageDirectory(pdpte_t *pdpt, uint32_t pdptIndex, pde_t *pd);
void unmapAllPageTables(pde_t *pd);
void unmapPageTable(pde_t *pd, uint32_t pdIndex);
void unmapAllPages(pte_t *pt);
void unmapPageSmall(pte_t *pt, uint32_t ptIndex);
void flushPageSmall(pte_t *pt, uint32_t ptIndex);
void unmapPageLarge(pde_t *pd, uint32_t pdIndex);
void flushPageLarge(pde_t *pd, uint32_t pdIndex);
void flushPageDirectory(pdpte_t *pdpt, uint32_t pdptIndex, pde_t *pd);
void setVMRoot(tcb_t *tcb);
bool_t __attribute__((__const__)) isValidVTableRoot(cap_t cap);
bool_t __attribute__((__const__)) isValidNativeRoot(cap_t cap);
exception_t checkValidIPCBuffer(vptr_t vptr, cap_t cap);
vm_rights_t __attribute__((__const__)) maskVMRights(vm_rights_t vm_rights, cap_rights_t cap_rights_mask);
exception_t decodeIA32MMUInvocation(word_t label, unsigned int length, cptr_t cptr, cte_t *cte, cap_t cap, extra_caps_t extraCaps, word_t* buffer);
void *mapSpare4MFrame(paddr_t phys);
exception_t decodeIA32PageDirectoryInvocation(word_t label, unsigned int length, cte_t* cte, cap_t cap, extra_caps_t extraCaps, word_t* buffer);
void unmapSpare4MFrame(void);
void *mapSpare4KFrame(paddr_t phyS);
void unmapSpare4KFrame(void);


void unmapEPTPD(ept_pdpte_t *pdpt, uint32_t index, ept_pde_t *pd);
void unmapEPTPT(ept_pde_t *pd, uint32_t index, ept_pte_t *pt);
exception_t decodeIA32EPTInvocation( word_t label, unsigned int length, cptr_t cptr, cte_t* cte, cap_t cap, extra_caps_t extraCaps, word_t* buffer);
exception_t decodeIA32EPTPageDirectoryInvocation( word_t label, unsigned int length, cte_t* cte, cap_t cap, extra_caps_t extraCaps, word_t* buffer);
exception_t decodeIA32EPTPageTableInvocation( word_t label, unsigned int length, cte_t* cte, cap_t cap, extra_caps_t extraCaps, word_t* buffer);
void IA32EptPdpt_Init(ept_pml4e_t *pdpt);
ept_pdpte_t *lookupEPTPDPTFromPD(ept_pde_t *pt);
void IA32PageUnmapEPT(cap_t cap);
void unmapAllEPTPD(ept_pdpte_t *pdpt);
void unmapAllEPTPT(ept_pde_t *pd);
void unmapAllEPTPages(ept_pte_t *pt);
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/vspace.h" 2
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 2
# 1 "./arch/api/syscall.h" 1
/* @LICENSE(OKL_CORE) */

/* This header was generated by kernel/tools/syscall_header_gen.py.
 *
 * To add a system call number, edit kernel/include/api/syscall.xml
 *
 */
# 31 "./arch/api/syscall.h"
enum syscall {
    SysCall = -1,
    SysReplyWait = -2,
    SysSend = -3,
    SysNBSend = -4,
    SysWait = -5,
    SysReply = -6,
    SysYield = -7,
    SysPoll = -8,

    SysVMEnter = -9,


    SysDebugPutChar = -10,
    SysDebugHalt = -11,
    SysDebugCapIdentify = -12,
    SysDebugSnapshot = -13,
    SysDebugNameThread = -14,
# 58 "./arch/api/syscall.h"
};
typedef uint32_t syscall_t;
# 19 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 2

exception_t handleSyscall(syscall_t syscall) __attribute__((externally_visible));
exception_t handleInterruptEntry(void) __attribute__((externally_visible));
exception_t handleUnknownSyscall(word_t w) __attribute__((externally_visible));
exception_t handleUserLevelFault(word_t w_a, word_t w_b) __attribute__((externally_visible));
exception_t handleVMFaultEvent(vm_fault_type_t vm_faultType) __attribute__((externally_visible));

static inline word_t __attribute__((__pure__))
getSyscallArg(unsigned int i, word_t* ipc_buffer)
{
    if (i < n_msgRegisters) {
        return getRegister(ksCurThread, msgRegisters[i]);
    }

    if(!(ipc_buffer != ((void *)0))) _assert_fail("ipc_buffer != NULL", "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h", 33, __FUNCTION__);
    return ipc_buffer[i + 1];
}

extern extra_caps_t current_extra_caps;
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/faults.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/api/faults.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 2

struct deriveCap_ret {
    exception_t status;
    cap_t cap;
};
typedef struct deriveCap_ret deriveCap_ret_t;

struct finaliseCap_ret {
    cap_t remainder;
    irq_t irq;
};
typedef struct finaliseCap_ret finaliseCap_ret_t;

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/objecttype.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/objecttype.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/objecttype.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/objecttype.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/objecttype.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/objecttype.h" 2

deriveCap_ret_t Arch_deriveCap(cte_t *slot, cap_t cap);
cap_t __attribute__((__const__)) Arch_updateCapData(bool_t preserve, word_t data, cap_t cap);
cap_t __attribute__((__const__)) Arch_maskCapRights(cap_rights_t cap_rights_mask, cap_t cap);
cap_t Arch_finaliseCap(cap_t cap, bool_t final);
cap_t Arch_recycleCap(bool_t is_final, cap_t cap);
bool_t __attribute__((__const__)) Arch_hasRecycleRights(cap_t cap);
bool_t __attribute__((__const__)) Arch_sameRegionAs(cap_t cap_a, cap_t cap_b);
bool_t __attribute__((__const__)) Arch_sameObjectAs(cap_t cap_a, cap_t cap_b);
cap_t Arch_createObject(object_t t, void *regionBase, unsigned int userSize, bool_t deviceMemory);
exception_t Arch_decodeInvocation(word_t label, unsigned int length, cptr_t cptr, cte_t *slot, cap_t cap, extra_caps_t extraCaps, word_t* buffer);
void Arch_prepareThreadDelete(tcb_t *thread);
word_t Arch_getObjectSize(word_t t);
bool_t Arch_isFrameType(word_t t);
# 33 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 2

deriveCap_ret_t deriveCap(cte_t *slot, cap_t cap);
finaliseCap_ret_t finaliseCap(cap_t cap, bool_t final, bool_t exposed);
cap_t recycleCap(bool_t is_final, cap_t cap);
bool_t __attribute__((__const__)) hasRecycleRights(cap_t cap);
bool_t __attribute__((__const__)) sameRegionAs(cap_t cap_a, cap_t cap_b);
bool_t __attribute__((__const__)) sameObjectAs(cap_t cap_a, cap_t cap_b);
cap_t __attribute__((__const__)) updateCapData(bool_t preserve, word_t newData, cap_t cap);
cap_t __attribute__((__const__)) maskCapRights(cap_rights_t cap_rights, cap_t cap);
cap_t createObject(object_t t, void *regionBase, int userSize, bool_t deviceMemory);
void createNewObjects(object_t t, cte_t *parent, slot_range_t slots,
                      void *regionBase, unsigned int userSize, bool_t deviceMemory);
exception_t decodeInvocation(word_t label, unsigned int length,
                             cptr_t capIndex, cte_t *slot, cap_t cap,
                             extra_caps_t extraCaps, bool_t block, bool_t call,
                             word_t *buffer);
exception_t performInvocation_Endpoint(endpoint_t *ep, word_t badge,
                                       bool_t canGrant, bool_t block,
                                       bool_t call);
exception_t performInvocation_AsyncEndpoint(async_endpoint_t *aep,
                                            word_t badge);
exception_t performInvocation_Reply(tcb_t *thread, cte_t *slot);
word_t getObjectSize(word_t t, word_t userObjSize);
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/asyncendpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/object/asyncendpoint.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/object/asyncendpoint.h" 2

void sendAsyncIPC(async_endpoint_t *aepptr, word_t badge);
void receiveAsyncIPC(tcb_t *thread, cap_t cap, bool_t isBlocking);
void aepCancelAll(async_endpoint_t *aepptr);
void asyncIPCCancel(tcb_t *threadPtr, async_endpoint_t *aepptr);
void completeAsyncIPC(async_endpoint_t *aepptr, tcb_t *tcb);
void unbindAsyncEndpoint(tcb_t *tcb);
void bindAsyncEndpoint(tcb_t *tcb, async_endpoint_t *aepptr);
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/endpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/object/endpoint.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/object/endpoint.h" 2

void sendIPC(bool_t blocking, bool_t do_call, word_t badge,
             bool_t canGrant, tcb_t *thread, endpoint_t *epptr);
void receiveIPC(tcb_t *thread, cap_t cap);
void ipcCancel(tcb_t *tptr);
void epCancelAll(endpoint_t *epptr);
void epCancelBadgedSends(endpoint_t *epptr, word_t badge);
void replyFromKernel_error(tcb_t *thread);
void replyFromKernel_success_empty(tcb_t *thread);
# 19 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/object/interrupt.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/object/interrupt.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/object/interrupt.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/interrupt.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/interrupt.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/interrupt.h" 2

exception_t Arch_decodeInterruptControl(unsigned int length, extra_caps_t extraCaps);
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/object/interrupt.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/include/object/interrupt.h" 2

exception_t decodeIRQControlInvocation(word_t label, unsigned int length,
                                       cte_t *srcSlot, extra_caps_t extraCaps,
                                       word_t *buffer);
exception_t invokeIRQControl(irq_t irq, cte_t *handlerSlot, cte_t *controlSlot);
exception_t decodeIRQHandlerInvocation(word_t label, unsigned int length, irq_t irq,
                                       extra_caps_t extraCaps, word_t *buffer);
void invokeIRQHandler_AckIRQ(irq_t irq);
void invokeIRQHandler_SetIRQHandler(irq_t irq, cap_t cap, cte_t *slot);
void invokeIRQHandler_ClearIRQHandler(irq_t irq);
void invokeIRQHandler_SetMode(irq_t irq, bool_t levelTrigger, bool_t polarityLow);
void deletingIRQHandler(irq_t irq);
void deletedIRQHandler(irq_t irq);
void handleInterrupt(irq_t irq);
bool_t isIRQActive(irq_t irq);
void setIRQState(irq_state_t irqState, irq_t irq);
# 20 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/untyped.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/object/untyped.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/object/untyped.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/object/untyped.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/object/untyped.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/include/object/untyped.h" 2



exception_t decodeUntypedInvocation(word_t label, unsigned int length,
                                    cte_t *slot, cap_t cap,
                                    extra_caps_t extraCaps, bool_t call,
                                    word_t *buffer);
exception_t invokeUntyped_Retype(cte_t *srcSlot, void* base_ign,
                                 void* freeRegionBase, object_t newType,
                                 unsigned int objSize, slot_range_t destSlots,
                                 bool_t call, bool_t deviceMemory);
# 24 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 2
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/api/faults.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/api/faults.h" 2

bool_t handleFaultReply(tcb_t *receiver, tcb_t *sender);
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 2

struct lookupCap_ret {
    exception_t status;
    cap_t cap;
};
typedef struct lookupCap_ret lookupCap_ret_t;

struct lookupCapAndSlot_ret {
    exception_t status;
    cap_t cap;
    cte_t *slot;
};
typedef struct lookupCapAndSlot_ret lookupCapAndSlot_ret_t;

struct lookupSlot_raw_ret {
    exception_t status;
    cte_t *slot;
};
typedef struct lookupSlot_raw_ret lookupSlot_raw_ret_t;

struct lookupSlot_ret {
    exception_t status;
    cte_t *slot;
};
typedef struct lookupSlot_ret lookupSlot_ret_t;

struct resolveAddressBits_ret {
    exception_t status;
    cte_t *slot;
    unsigned int bitsRemaining;
};
typedef struct resolveAddressBits_ret resolveAddressBits_ret_t;

lookupCap_ret_t lookupCap(tcb_t *thread, cptr_t cPtr);
lookupCapAndSlot_ret_t lookupCapAndSlot(tcb_t *thread, cptr_t cPtr);
lookupSlot_raw_ret_t lookupSlot(tcb_t *thread, cptr_t capptr);
lookupSlot_ret_t lookupSlotForCNodeOp(bool_t isSource,
                                      cap_t root, cptr_t capptr,
                                      unsigned int depth);
lookupSlot_ret_t lookupSourceSlot(cap_t root, cptr_t capptr,
                                  unsigned int depth);
lookupSlot_ret_t lookupTargetSlot(cap_t root, cptr_t capptr,
                                  unsigned int depth);
lookupSlot_ret_t lookupPivotSlot(cap_t root, cptr_t capptr,
                                 unsigned int depth);
resolveAddressBits_ret_t resolveAddressBits(cap_t nodeCap,
                                            cptr_t capptr,
                                            unsigned int n_bits);
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/faulthandler.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/faulthandler.h" 2

void handleFault(tcb_t *tptr);
exception_t sendFaultIPC(tcb_t *tptr);
void handleDoubleFault(tcb_t *tptr, fault_t ex1);
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 2

static inline __attribute__((__pure__)) uint32_t
ready_queues_index(uint32_t dom, uint32_t prio)
{
    if (1 > 1) {
        return dom * 256 + prio;
    } else {
        if(!(dom == 0)) _assert_fail("dom == 0", "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h", 24, __FUNCTION__);
        return prio;
    }
}

/* the l1 index is the top 32 bits of prio (2^5 == 32) */
static inline __attribute__((__pure__)) uint32_t
prio_to_l1index(uint32_t prio)
{
    return (prio >> 5);
}

static inline __attribute__((__pure__)) uint32_t
l1index_to_prio(uint32_t l1index)
{
    return (l1index << 5);
}

void configureIdleThread(tcb_t *tcb);
void activateThread(void) __attribute__((externally_visible));
void suspend(tcb_t *target);
void restart(tcb_t *target);
void doIPCTransfer(tcb_t *sender, endpoint_t *endpoint,
                   word_t badge, bool_t grant, tcb_t *receiver,
                   bool_t diminish);
void doReplyTransfer(tcb_t *sender, tcb_t *receiver, cte_t *slot);
void doNormalTransfer(tcb_t *sender, word_t *sendBuffer, endpoint_t *endpoint,
                      word_t badge, bool_t canGrant, tcb_t *receiver,
                      word_t *receiveBuffer, bool_t diminish);
void doFaultTransfer(word_t badge, tcb_t *sender, tcb_t *receiver,
                     word_t *receiverIPCBuffer);
void doPollFailedTransfer(tcb_t *thread);
void schedule(void);
void chooseThread(void);
void switchToThread(tcb_t *thread) __attribute__((externally_visible));
void switchToIdleThread(void);
void setDomain(tcb_t *tptr, dom_t dom);
void setPriority(tcb_t *tptr, prio_t prio);
void scheduleTCB(tcb_t *tptr);
void attemptSwitchTo(tcb_t *tptr);
void switchIfRequiredTo(tcb_t *tptr);
void setThreadState(tcb_t *tptr, _thread_state_t ts) __attribute__((externally_visible));
void timerTick(void);
void rescheduleRequired(void);
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/string.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */






# 1 "/home/kq/Sources/RefOS_x86/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/string.h" 2

unsigned int strnlen(const char *s, unsigned int maxlen);
unsigned int strlcpy(char *dest, const char *src, unsigned int size);
unsigned int strlcat(char *dest, const char *src, unsigned int size);
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2


# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/capdl.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




void capDL(void);
# 27 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c" 2


void print_cycle(char *info);
/* The haskell function 'handleEvent' is split into 'handleXXX' variants
 * for each event causing a kernel entry */

void print_cycle(char *info)
{
    unsigned long long result;
    __asm__ volatile("rdtsc" : "=A" (result));
    kprintf("%s: cycles are %lld\n", info, result);
}

exception_t
handleInterruptEntry(void)
{
    irq_t irq;

    irq = getActiveIRQ();
    if (irq != irqInvalid) {
        handleInterrupt(irq);
    } else {
        kprintf("Spurious interrupt\n");
        handleSpuriousIRQ();
    }

    schedule();
    activateThread();

    //print_cycle("will go user-land");

    return EXCEPTION_NONE;
}

exception_t
handleUnknownSyscall(word_t w)
{

    if (w == SysDebugPutChar) {
        console_putchar(getRegister(ksCurThread, capRegister));
        return EXCEPTION_NONE;
    }
    if (w == SysDebugHalt) {
        kprintf("Debug halt syscall from user thread 0x%x\n", (unsigned int)ksCurThread);
        halt();
    }
    if (w == SysDebugSnapshot) {
        kprintf("Debug snapshot syscall from user thread 0x%x\n", (unsigned int)ksCurThread);
        capDL();
        return EXCEPTION_NONE;
    }
    if (w == SysDebugCapIdentify) {
        word_t cptr = getRegister(ksCurThread, capRegister);
        lookupCapAndSlot_ret_t lu_ret = lookupCapAndSlot(ksCurThread, cptr);
        uint32_t cap_type = cap_get_capType(lu_ret.cap);
        setRegister(ksCurThread, capRegister, cap_type);
        return EXCEPTION_NONE;
    }
    if (w == SysDebugNameThread) {
        /* This is a syscall meant to aid debugging, so if anything goes wrong
         * then assume the system is completely misconfigured and halt */
        const char *name;
        word_t cptr = getRegister(ksCurThread, capRegister);
        lookupCapAndSlot_ret_t lu_ret = lookupCapAndSlot(ksCurThread, cptr);
        /* ensure we got a TCB cap */
        uint32_t cap_type = cap_get_capType(lu_ret.cap);
        if (cap_type != cap_thread_cap) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 94, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("SysDebugNameThread: cap is not a TCB, halting"); kprintf(">>" "\033[0m" "\n"); } while (0);
            halt();
        }
        /* Add 1 to the IPC buffer to skip the message info word */
        name = (const char*)(lookupIPCBuffer(true, ksCurThread) + 1);
        if (!name) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 100, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("SysDebugNameThread: Failed to lookup IPC buffer, halting"); kprintf(">>" "\033[0m" "\n"); } while (0);
            halt();
        }
        /* ensure the name isn't too long */
        if (name[strnlen(name, seL4_MsgMaxLength * sizeof(word_t))] != '\0') {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 105, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("SysDebugNameThread: Name too long, halting"); kprintf(">>" "\033[0m" "\n"); } while (0);
            halt();
        }
        setThreadName(((tcb_t *)(cap_thread_cap_get_capTCBPtr(lu_ret.cap))), name);
        return EXCEPTION_NONE;
    }
# 169 "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c"
    current_fault = fault_unknown_syscall_new(w);
    handleFault(ksCurThread);

    schedule();
    activateThread();

    return EXCEPTION_NONE;
}

exception_t
handleUserLevelFault(word_t w_a, word_t w_b)
{
    current_fault = fault_user_exception_new(w_a, w_b);
    handleFault(ksCurThread);

    schedule();
    activateThread();

    return EXCEPTION_NONE;
}

exception_t
handleVMFaultEvent(vm_fault_type_t vm_faultType)
{
    exception_t status;

    status = handleVMFault(ksCurThread, vm_faultType);
    if (status != EXCEPTION_NONE) {
        handleFault(ksCurThread);
    }

    schedule();
    activateThread();

    return EXCEPTION_NONE;
}


static exception_t
handleInvocation(bool_t isCall, bool_t isBlocking)
{
    message_info_t info;
    cptr_t cptr;
    lookupCapAndSlot_ret_t lu_ret;
    word_t *buffer;
    exception_t status;
    word_t length;
    tcb_t *thread;

    thread = ksCurThread;

    info = messageInfoFromWord(getRegister(thread, msgInfoRegister));
    cptr = getRegister(thread, capRegister);

    /* faulting section */
    lu_ret = lookupCapAndSlot(thread, cptr);

    if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 227, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Invocation of invalid cap #%d.", (int)cptr); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_fault = fault_cap_fault_new(cptr, false);

        if (isBlocking) {
            handleFault(thread);
        }

        return EXCEPTION_NONE;
    }

    buffer = lookupIPCBuffer(false, thread);

    status = lookupExtraCaps(thread, buffer, info);

    if (__builtin_expect(!!(status != EXCEPTION_NONE), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 242, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Lookup of extra caps failed."); kprintf(">>" "\033[0m" "\n"); } while (0);
        if (isBlocking) {
            handleFault(thread);
        }
        return EXCEPTION_NONE;
    }

    /* Syscall error/Preemptible section */
    length = message_info_get_msgLength(info);
    if (__builtin_expect(!!(length > n_msgRegisters && !buffer), 0)) {
        length = n_msgRegisters;
    }
    status = decodeInvocation(message_info_get_msgLabel(info), length,
                              cptr, lu_ret.slot, lu_ret.cap,
                              current_extra_caps, isBlocking, isCall,
                              buffer);

    if (__builtin_expect(!!(status == EXCEPTION_PREEMPTED), 0)) {
        return status;
    }

    if (__builtin_expect(!!(status == EXCEPTION_SYSCALL_ERROR), 0)) {
        if (isCall) {
            replyFromKernel_error(thread);
        }
        return EXCEPTION_NONE;
    }

    if (__builtin_expect(!!(thread_state_get_tsType(thread->tcbState) == ThreadState_Restart), 0)
                                                                                 ) {
        if (isCall) {
            replyFromKernel_success_empty(thread);
        }
        setThreadState(thread, ThreadState_Running);
    }

    return EXCEPTION_NONE;
}

static void
handleReply(void)
{
    cte_t *callerSlot;
    cap_t callerCap;

    callerSlot = (((cte_t *)((unsigned int)(ksCurThread)&~((1ul<<(10))-1ul)))+(tcbCaller));
    callerCap = callerSlot->cap;
    switch (cap_get_capType(callerCap)) {
    case cap_reply_cap: {
        tcb_t *caller;

        if (cap_reply_cap_get_capReplyMaster(callerCap)) {
            break;
        }
        caller = ((tcb_t *)(cap_reply_cap_get_capTCBPtr(callerCap)));
        /* Haskell error:
         * "handleReply: caller must not be the current thread" */
        if(!(caller != ksCurThread)) _assert_fail("caller != ksCurThread", "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c", 299, __FUNCTION__);
        doReplyTransfer(ksCurThread, caller, callerSlot);
        //deleteCallerCap(ksCurThread);
        return;
    }

    case cap_null_cap:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 306, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Attempted reply operation when no reply cap present."); kprintf(">>" "\033[0m" "\n"); } while (0);
        return;

    default:
        break;
    }

    _fail("handleReply: invalid caller cap", "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c", 313, __func__);
}

static void
handleWait(bool_t isBlocking)
{
    word_t epCPtr;
    lookupCap_ret_t lu_ret;

    epCPtr = getRegister(ksCurThread, capRegister);

    lu_ret = lookupCap(ksCurThread, epCPtr);
    if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
        /* current_lookup_fault has been set by lookupCap */
        current_fault = fault_cap_fault_new(epCPtr, true);
        handleFault(ksCurThread);
        return;
    }

    switch (cap_get_capType(lu_ret.cap)) {
    case cap_endpoint_cap:

        if (__builtin_expect(!!(!cap_endpoint_cap_get_capCanReceive(lu_ret.cap) || !isBlocking), 0)) {
            current_lookup_fault = lookup_fault_missing_capability_new(0);
            current_fault = fault_cap_fault_new(epCPtr, true);
            handleFault(ksCurThread);
            break;
        }

        deleteCallerCap(ksCurThread);
        receiveIPC(ksCurThread, lu_ret.cap);
        break;

    case cap_async_endpoint_cap: {
        async_endpoint_t *aepptr;
        tcb_t *boundTCB;
        aepptr = ((async_endpoint_t *)(cap_async_endpoint_cap_get_capAEPPtr(lu_ret.cap)));
        boundTCB = (tcb_t*)async_endpoint_ptr_get_aepBoundTCB(aepptr);
        if (__builtin_expect(!!(!cap_async_endpoint_cap_get_capAEPCanReceive(lu_ret.cap) || (boundTCB && boundTCB != ksCurThread)), 0)
                                                              ) {
            current_lookup_fault = lookup_fault_missing_capability_new(0);
            current_fault = fault_cap_fault_new(epCPtr, true);
            handleFault(ksCurThread);
            break;
        }

        receiveAsyncIPC(ksCurThread, lu_ret.cap, isBlocking);
        break;
    }
    default:
        current_lookup_fault = lookup_fault_missing_capability_new(0);
        current_fault = fault_cap_fault_new(epCPtr, true);
        handleFault(ksCurThread);
        break;
    }
}

static void
handleYield(void)
{
    tcbSchedDequeue(ksCurThread);
    tcbSchedAppend(ksCurThread);
    rescheduleRequired();
}

exception_t
handleSyscall(syscall_t syscall)
{
    exception_t ret;
    irq_t irq;

    switch (syscall) {
    case SysSend:
        ret = handleInvocation(false, true);
        if (__builtin_expect(!!(ret != EXCEPTION_NONE), 0)) {
            irq = getActiveIRQ();
            if (irq != irqInvalid) {
                handleInterrupt(irq);
            }
        }
        break;

    case SysNBSend:
        ret = handleInvocation(false, false);
        if (__builtin_expect(!!(ret != EXCEPTION_NONE), 0)) {
            irq = getActiveIRQ();
            if (irq != irqInvalid) {
                handleInterrupt(irq);
            }
        }
        break;

    case SysCall:
        ret = handleInvocation(true, true);
        if (__builtin_expect(!!(ret != EXCEPTION_NONE), 0)) {
            irq = getActiveIRQ();
            if (irq != irqInvalid) {
                handleInterrupt(irq);
            }
        }
        break;

    case SysWait:
        handleWait(true);
        break;

    case SysReply:
        handleReply();
        break;

    case SysReplyWait:
        handleReply();
        handleWait(true);
        break;

    case SysPoll:
        handleWait(false);
        break;

    case SysYield:
        handleYield();
        break;

    default:
        _fail("Invalid syscall", "/home/kq/Sources/RefOS_x86/kernel/src/api/syscall.c", 437, __func__);
    }

    schedule();
    activateThread();

    return EXCEPTION_NONE;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/api/benchmark.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/api/faults.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/api/faults.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/api/faults.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/api/faults.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/api/faults.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/faults.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/api/faults.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/api/faults.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/api/faults.c" 2

bool_t handleFaultReply(tcb_t *receiver, tcb_t *sender)
{
    message_info_t tag;
    word_t label;
    fault_t fault;
    unsigned int length;

    /* These lookups are moved inward from doReplyTransfer */
    tag = messageInfoFromWord(getRegister(sender, msgInfoRegister));
    label = message_info_get_msgLabel(tag);
    length = message_info_get_msgLength(tag);
    fault = receiver->tcbFault;

    switch (fault_get_faultType(fault)) {
    case fault_cap_fault:
        return true;

    case fault_vm_fault:
        return true;

    case fault_unknown_syscall: {
        unsigned int i;
        register_t r;
        word_t v;
        word_t* sendBuf;

        sendBuf = lookupIPCBuffer(false, sender);

        /* Assumes n_syscallMessage > n_msgRegisters */
        for (i = 0; i < length && i < n_msgRegisters; i++) {
            r = syscallMessage[i];
            v = getRegister(sender, msgRegisters[i]);
            setRegister(receiver, r, sanitiseRegister(r, v));
        }

        if (sendBuf) {
            for (; i < length && i < n_syscallMessage; i++) {
                r = syscallMessage[i];
                v = sendBuf[i + 1];
                setRegister(receiver, r, sanitiseRegister(r, v));
            }
        }
        /* HACK: Copy NextEIP to FaultEIP because FaultEIP will be copied */
        /* back to NextEIP later on (and we don't wanna lose NextEIP)     */
        setRegister(receiver, FaultEIP, getRegister(receiver, NextEIP));
    }
    return (label == 0);

    case fault_user_exception: {
        unsigned int i;
        register_t r;
        word_t v;
        word_t* sendBuf;

        sendBuf = lookupIPCBuffer(false, sender);

        /* Assumes n_exceptionMessage > n_msgRegisters */
        for (i = 0; i < length && i < n_msgRegisters; i++) {
            r = exceptionMessage[i];
            v = getRegister(sender, msgRegisters[i]);
            setRegister(receiver, r, sanitiseRegister(r, v));
        }

        if (sendBuf) {
            for (; i < length && i < n_exceptionMessage; i++) {
                r = exceptionMessage[i];
                v = sendBuf[i + 1];
                setRegister(receiver, r, sanitiseRegister(r, v));
            }
        }
    }
    return (label == 0);

    default:
        _fail("Invalid fault", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/api/faults.c", 93, __func__);
    }
}



void handleKernelException(
    uint32_t vector,
    uint32_t errcode,
    uint32_t eip,
    uint32_t esp,
    uint32_t eflags,
    uint32_t cr0,
    uint32_t cr2,
    uint32_t cr3,
    uint32_t cr4
);

__attribute__((externally_visible))
void handleKernelException(
    uint32_t vector,
    uint32_t errcode,
    uint32_t eip,
    uint32_t esp,
    uint32_t eflags,
    uint32_t cr0,
    uint32_t cr2,
    uint32_t cr3,
    uint32_t cr4
)
{
    unsigned int i;

    kprintf("\n========== KERNEL EXCEPTION ==========\n");
    kprintf("Vector:  0x%x\n", vector);
    kprintf("ErrCode: 0x%x\n", errcode);
    kprintf("EIP:     0x%x\n", eip);
    kprintf("ESP:     0x%x\n", esp);
    kprintf("EFLAGS:  0x%x\n", eflags);
    kprintf("CR0:     0x%x\n", cr0);
    kprintf("CR2:     0x%x (page-fault address)\n", cr2);
    kprintf("CR3:     0x%x (page-directory physical address)\n", cr3);
    kprintf("CR4:     0x%x\n", cr4);
    kprintf("\nStack Dump:\n");
    for (i = 0; i < 20; i++) {
        kprintf("*0x%x == 0x%x\n", esp + i * 4, *(uint32_t*)(esp + i * 4));
    }
    kprintf("\nHalting...\n");
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/c_traps.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/c_traps.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/c_traps.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/lock.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */






# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/lock.h" 2

typedef uint32_t lock_t;

/* global spinlocks */

extern lock_t lock_debug;

/* acquire/release lock */

static inline void lock_acquire(lock_t* lock)
{
    __asm__ volatile (
        "1:                 \n"
        "movl  $1,    %%eax \n"
        "xchgl (%0),  %%eax \n"
        "testl %%eax, %%eax \n"
        "jnz   1b           \n"
        :
        : "r"(lock)
        : "%eax", "cc", "memory"
    );
}

static inline void lock_release(lock_t* lock)
{
    *lock = 0;
}
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/c_traps.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/fpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/fpu.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/fpu.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/fpu.h" 2

/* Initialise the FPU. */
void Arch_initFpu(void);

/* Initialise the FPU state of the given user context. */
void Arch_initFpuContext(user_context_t *context);

/* Perform any actions required for the deletion of the given thread. */
void Arch_fpuThreadDelete(tcb_t *thread);

/* Handle an FPU exception. */
exception_t handleUnimplementedDevice(void);

/* Store state in the FPU registers into memory. */
static inline void saveFpuState(user_fpu_state_t *dest)
{
    __asm__ volatile("fxsave %[dest]" : [dest] "=m"(*dest));
}

/* Load FPU state from memory into the FPU registers. */
static inline void loadFpuState(user_fpu_state_t *src)
{
    __asm__ volatile("fxrstor %[src]" :: [src] "m"(*src));
}

/* Reset the FPU registers into their initial blank state. */
static inline void resetFpu(void)
{
    __asm__ volatile("finit" :: "m"(__control_reg_order));
}

/*
 * Enable the FPU to be used without faulting.
 * Required even if the kernel attempts to use the FPU.
 */
static inline void enableFpu(void)
{
    __asm__ volatile("clts" :: "m" (__control_reg_order));
}

/*
 * Disable the FPU so that usage of it causes a fault
 */
static inline void disableFpu(void)
{
    write_cr0(read_cr0() | (1ul<<(3)) /* Trap on any FPU usage, for lazy FPU. */);
}
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/c_traps.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/fastpath/fastpath.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/fastpath/fastpath.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/fastpath/fastpath.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/fastpath/fastpath.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/fastpath/fastpath.h" 2

void slowpath(syscall_t syscall)
__attribute__((__noreturn__));

void fastpath_call(word_t cptr, word_t r_msgInfo)
__attribute__((externally_visible)) __attribute__((fastcall)) __attribute__((__noreturn__));

void fastpath_reply_wait(word_t cptr, word_t r_msgInfo)
__attribute__((externally_visible)) __attribute__((fastcall)) __attribute__((__noreturn__));
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/c_traps.c" 2

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/vtx.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 166 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/vtx.h"
// As borrowed from kvm: "invept (%eax), %ecx"




/* Exit reasons. */
enum exit_reasons {
    EXCEPTION_OR_NMI = 0x00,
    EXTERNAL_INTERRUPT = 0x01,
    TRIPLE_FAULT = 0x02,
    INIT_SIGNAL = 0x03,
    SIPI = 0x04,
    /*IO_SMI = 0x05,
    OTHER_SMI = 0x06,*/
    INTERRUPT_WINDOW = 0x07,
    NMI_WINDOW = 0x08,
    TASK_SWITCH = 0x09,
    CPUID = 0x0A,
    GETSEC = 0x0B,
    HLT = 0x0C,
    INVD = 0x0D,
    INVLPG = 0x0E,
    RDPMC = 0x0F,
    RDTSC = 0x10,
    RSM = 0x11,
    VMCALL = 0x12,
    VMCLEAR = 0x13,
    VMLAUNCH = 0x14,
    VMPTRLD = 0x15,
    VMPTRST = 0x16,
    VMREAD = 0x17,
    VMRESUME = 0x18,
    VMWRITE = 0x19,
    VMXOFF = 0x1A,
    VMXON = 0x1B,
    CONTROL_REGISTER = 0x1C,
    MOV_DR = 0x1D,
    IO = 0x1E,
    RDMSR = 0x1F,
    WRMSR = 0x20,
    INVALID_GUEST_STATE = 0x21,
    MSR_LOAD_FAIL = 0x22,
    /* 0x23 */
    MWAIT = 0x24,
    MONITOR_TRAP_FLAG = 0x25,
    /* 0x26 */
    MONITOR = 0x27,
    PAUSE = 0x28,
    MACHINE_CHECK = 0x29,
    /* 0x2A */
    TPR_BELOW_THRESHOLD = 0x2B,
    APIC_ACCESS = 0x2C,
    GDTR_OR_IDTR = 0x2E,
    LDTR_OR_TR = 0x2F,
    EPT_VIOLATION = 0x30,
    EPT_MISCONFIGURATION = 0x31,
    INVEPT = 0x32,
    RDTSCP = 0x33,
    VMX_PREEMPTION_TIMER = 0x34,
    INVVPID = 0x35,
    WBINVD = 0x36,
    XSETBV = 0x37
};

extern uint32_t vtx_enabled;
extern uint32_t vmcs_revision;
extern void *current_vmcs;
extern uint32_t* msr_bitmap;

uint32_t vmread(uint32_t field);
void vmwrite(uint32_t field, uint32_t value);
bool_t vtx_allocate(void);
void vtx_enable(void);
void vmxon(uint64_t vmxon_region);
exception_t handleVmexit(void) __attribute__((externally_visible));
exception_t handleVmEntryFail(void) __attribute__((externally_visible));
void finishVmexitSaving(void) __attribute__((externally_visible));
void restoreVMCS(void) __attribute__((externally_visible));

int vmptrld(void *vmcs_ptr);
void vmclear(void *vmcs_ptr);
void invept(void* ept_pml4);

uint32_t get_cr0(void);
uint32_t get_cr4(void);
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/c_traps.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/vcpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




struct vcpu {
    /* Storage for VMCS region. First field of vcpu_t so they share address.
     * Will use at most 4KiB of memory. Statically reserve 4KiB for convenience. */
    char vmcs[4096];
    uint32_t io[2048];

    /* General purpose registers that we have to save and restore as they
     * are not part of the vmcs */
    uint32_t gp_registers[EBP + 1];

    /* TCB associated with this VCPU. */
    struct tcb *tcb;
    bool_t launched;
    uint32_t interrupt_info;
    cap_t io_port;
    uint32_t io_min;
    uint32_t io_max;
    /* These are the values the user last set these to. We may have written
     * other values for the purposes of lazy fpu management */
    uint32_t exception_mask;
    uint32_t cr0_shadow;
    uint32_t cr0_mask;
    uint32_t cr0;
    /* Last values we wrote the VMCS */
    uint32_t written_exception_mask;
    uint32_t written_cr0_shadow;
    uint32_t written_cr0_mask;
    uint32_t written_cr0;

    /* Last used EPT root */
    uint32_t last_ept_root;

    /* Last set host cr3 */
    uint32_t last_host_cr3;
};
typedef struct vcpu vcpu_t;

bool_t init_vtx_fixed_values(bool_t useTrueMsrs);
void vcpu_init(vcpu_t *vcpu);

void vcpu_finalise(vcpu_t *vcpu);

uint16_t vpid_for_vcpu(vcpu_t *vcpu);

void associateVcpuTcb(tcb_t *tcb, vcpu_t *vcpu);

void dissociateVcpuTcb(tcb_t *tcb, vcpu_t *vcpu);

exception_t decodeIA32VCPUInvocation(
    word_t label,
    unsigned int length,
    cptr_t cptr,
    cte_t* slot,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
);

void vcpu_update_vmenter_state(vcpu_t *vcpu);
exception_t decodeReadVMCS(cap_t cap, unsigned int length, word_t* buffer);
exception_t decodeWriteVMCS(cap_t cap, unsigned int length, word_t* buffer);
exception_t decodeSetTCB(cap_t cap, unsigned int length, word_t* buffer, extra_caps_t extraCaps);
exception_t decodeSetIOPort(cap_t cap, unsigned int length, word_t* buffer, extra_caps_t extraCaps);
exception_t invokeReadVMCS(vcpu_t *vcpu, int num_fields, uint32_t *fields);
exception_t invokeWriteVMCS(vcpu_t *vcpu, int num_fields, uint32_t *fields, uint32_t *values);
exception_t invokeSetTCB(vcpu_t *vcpu, tcb_t *tcb);
exception_t invokeSetIOPort(vcpu_t *vcpu, cap_t cap);
exception_t decodeSetIOPortMask(cap_t cap, unsigned int length, word_t *buffer);
exception_t invokeSetIOPortMask(vcpu_t *vcpu, uint32_t low, uint32_t high, int mask);
exception_t decodeVCPUWriteRegisters(cap_t cap, unsigned int length, word_t *buffer);
exception_t invokeVCPUWriteRegisters(vcpu_t *vcpu, word_t *buffer);
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/c_traps.c" 2


# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/c_traps.c" 2

void __attribute__((noreturn)) __attribute__((externally_visible)) restore_user_context(void);



void __attribute__((noreturn)) __attribute__((externally_visible)) vmlaunch_failed(void);
void __attribute__((noreturn)) __attribute__((externally_visible)) vmlaunch_failed(void)
{
    handleVmEntryFail();
    restore_user_context();
}

static inline void __attribute__((noreturn)) restore_vmx(void)
{
    restoreVMCS();
    if (ksCurThread->tcbArch.vcpu->launched) {
        /* attempt to do a vmresume */
        __asm__ volatile(
            // Set our stack pointer to the top of the tcb so we can efficiently pop
            "movl %0, %%esp\n"
            "popl %%eax\n"
            "popl %%ebx\n"
            "popl %%ecx\n"
            "popl %%edx\n"
            "popl %%esi\n"
            "popl %%edi\n"
            "popl %%ebp\n"
            // Now do the vmresume
            "vmresume\n"
            // if we get here we failed
            "leal _kernel_stack_top, %%esp\n"
            "jmp vmlaunch_failed\n"
            :
            : "r"(&ksCurThread->tcbArch.vcpu->gp_registers[EAX])
            // Clobber memory so the compiler is forced to complete all stores
            // before running this assembler
            : "memory"
        );
    } else {
        /* attempt to do a vmlaunch */
        __asm__ volatile(
            // Set our stack pointer to the top of the tcb so we can efficiently pop
            "movl %0, %%esp\n"
            "popl %%eax\n"
            "popl %%ebx\n"
            "popl %%ecx\n"
            "popl %%edx\n"
            "popl %%esi\n"
            "popl %%edi\n"
            "popl %%ebp\n"
            // Now do the vmresume
            "vmlaunch\n"
            // if we get here we failed
            "leal _kernel_stack_top, %%esp\n"
            "jmp vmlaunch_failed\n"
            :
            : "r"(&ksCurThread->tcbArch.vcpu->gp_registers[EAX])
            // Clobber memory so the compiler is forced to complete all stores
            // before running this assembler
            : "memory"
        );
    }
    while (1);
}


void __attribute__((noreturn)) __attribute__((externally_visible)) restore_user_context(void)
{
    /* set the tss.esp0 */
    tss_ptr_set_esp0(&ia32KStss, ((uint32_t)ksCurThread) + 0x4c);

    if (thread_state_ptr_get_tsType(&ksCurThread->tcbState) == ThreadState_RunningVM) {
        restore_vmx();
    }

    if (__builtin_expect(!!(ksCurThread == ia32KSfpuOwner), 0)) {
        /* We are using the FPU, make sure it is enabled */
        enableFpu();
    } else if (__builtin_expect(!!(ia32KSfpuOwner), 0)) {
        /* Someone is using the FPU and it might be enabled */
        disableFpu();
    } else {
        /* No-one (including us) is using the FPU, so we assume it
         * is currently disabled */
    }
    /* see if we entered via syscall */
    if (__builtin_expect(!!(ksCurThread->tcbArch.tcbContext.registers[Error] == -1), 1)) {
        ksCurThread->tcbArch.tcbContext.registers[EFLAGS] &= ~0x200;
        __asm__ volatile(
            // Set our stack pointer to the top of the tcb so we can efficiently pop
            "movl %0, %%esp\n"
            // restore syscall number
            "popl %%eax\n"
            // cap/badge register
            "popl %%ebx\n"
            // skip ecx and edx, these will contain esp and nexteip due to sysenter/sysexit convention
            "addl $8, %%esp\n"
            // message info register
            "popl %%esi\n"
            // message register
            "popl %%edi\n"
            // message register
            "popl %%ebp\n"
            //ds (if changed)
            "cmpl $0x23, (%%esp)\n"
            "je 1f\n"
            "popl %%ds\n"
            "jmp 2f\n"
            "1: addl $4, %%esp\n"
            "2:\n"
            //es (if changed)
            "cmpl $0x23, (%%esp)\n"
            "je 1f\n"
            "popl %%es\n"
            "jmp 2f\n"
            "1: addl $4, %%esp\n"
            "2:\n"
            //have to reload other selectors
            "popl %%fs\n"
            "popl %%gs\n"
            // skip faulteip, tls_base and error (these are fake registers)
            "addl $12, %%esp\n"
            // restore nexteip
            "popl %%edx\n"
            // skip cs
            "addl $4,  %%esp\n"
            "popfl\n"
            // reset interrupt bit
            "orl $0x200, -4(%%esp)\n"
            // restore esp
            "pop %%ecx\n"
            "sti\n"
            "sysexit\n"
            :
            : "r"(&ksCurThread->tcbArch.tcbContext.registers[EAX])
            // Clobber memory so the compiler is forced to complete all stores
            // before running this assembler
            : "memory"
        );
    } else {
        __asm__ volatile(
            // Set our stack pointer to the top of the tcb so we can efficiently pop
            "movl %0, %%esp\n"
            "popl %%eax\n"
            "popl %%ebx\n"
            "popl %%ecx\n"
            "popl %%edx\n"
            "popl %%esi\n"
            "popl %%edi\n"
            "popl %%ebp\n"
            "popl %%ds\n"
            "popl %%es\n"
            "popl %%fs\n"
            "popl %%gs\n"
            // skip faulteip, tls_base, error
            "addl $12, %%esp\n"
            "iret\n"
            :
            : "r"(&ksCurThread->tcbArch.tcbContext.registers[EAX])
            // Clobber memory so the compiler is forced to complete all stores
            // before running this assembler
            : "memory"
        );
    }
    while (1);
}

void __attribute__((fastcall)) __attribute__((externally_visible)) c_handle_interrupt(int irq, int syscall);
void __attribute__((fastcall)) __attribute__((externally_visible)) c_handle_interrupt(int irq, int syscall)
{
    if (irq == int_unimpl_dev) {
        handleUnimplementedDevice();
    } else if (irq == int_page_fault) {
        /* Error code is in Error. Pull out bit 5, which is whether it was instruction or data */
        handleVMFaultEvent((ksCurThread->tcbArch.tcbContext.registers[Error] >> 4) & 1);
    } else if (irq < int_irq_min) {
        handleUserLevelFault(irq, ksCurThread->tcbArch.tcbContext.registers[Error]);
    } else if (__builtin_expect(!!(irq < int_trap_min), 1)) {
        ia32KScurInterrupt = irq;
        handleInterruptEntry();
    } else if (irq == int_spurious) {
        /* fall through to restore_user_context and do nothing */
    } else {
        /* Interpret a trap as an unknown syscall */
        /* Adjust FaultEIP to point to trapping INT
         * instruction by subtracting 2 */
        int sys_num;
        ksCurThread->tcbArch.tcbContext.registers[FaultEIP] -= 2;
        /* trap number is MSBs of the syscall number and the LSBS of EAX */
        sys_num = (irq << 24) | (syscall & 0x00ffffff);
        handleUnknownSyscall(sys_num);
    }
    restore_user_context();
}

void __attribute__((noreturn))
slowpath(syscall_t syscall)
{
    ia32KScurInterrupt = -1;
    /* increment nextEIP to skip sysenter */
    ksCurThread->tcbArch.tcbContext.registers[NextEIP] += 2;
    /* check for undefined syscall */
    if (__builtin_expect(!!(syscall < (-9) || syscall > (-1)), 0)) {
        handleUnknownSyscall(syscall);
    } else {
        handleSyscall(syscall);
    }
    restore_user_context();
}

void __attribute__((externally_visible)) c_handle_syscall(syscall_t syscall, word_t cptr, word_t msgInfo);
void __attribute__((externally_visible)) c_handle_syscall(syscall_t syscall, word_t cptr, word_t msgInfo)
{

    if (syscall == SysCall) {
        fastpath_call(cptr, msgInfo);
    } else if (syscall == SysReplyWait) {
        fastpath_reply_wait(cptr, msgInfo);
    }


    if (syscall == SysVMEnter) {
        vcpu_update_vmenter_state(ksCurThread->tcbArch.vcpu);
        ksCurThread->tcbArch.tcbContext.registers[NextEIP] += 2;
        if (ksCurThread->boundAsyncEndpoint && async_endpoint_ptr_get_state(ksCurThread->boundAsyncEndpoint) == AEPState_Active) {
            completeAsyncIPC(ksCurThread->boundAsyncEndpoint, ksCurThread);
            setRegister(ksCurThread, msgInfoRegister, 0);
            /* Any guest state that we should return is in the same
             * register position as sent to us, so we can just return
             * and let the user pick up the values they put in */
            restore_user_context();
        } else {
            setThreadState(ksCurThread, ThreadState_RunningVM);
            restore_vmx();
        }
    }


    slowpath(syscall);
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/profiler.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/*
 * Profiler Interface
 *
 * 2006 - 2007  David Greenaway
 * 2007 Ported to seL4 C kernel by Philip Derrin
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/include/machine/profiler.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/include/machine/profiler.h" 2
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/fastpath/fastpath.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/thread.h" 2

void Arch_switchToThread(tcb_t *tcb);
void Arch_switchToIdleThread(void);
void Arch_configureIdleThread(tcb_t *tcb);
void __attribute__((__const__)) Arch_activateIdleThread(tcb_t *tcb);
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/fpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c" 2

/* Fastpath cap lookup.  Returns a null_cap on failure. */
static inline cap_t
lookup_fp(cap_t cap, cptr_t cptr)
{
    word_t cptr2;
    cte_t *slot;
    word_t radixBits, bits;
    word_t radix;

    if (__builtin_expect(!!(!cap_capType_equals(cap, cap_cnode_cap)), 0)) {
        return cap_null_cap_new();
    }

    bits = cap_cnode_cap_get_capCNodeGuardSize(cap);

    do {
        radixBits = cap_cnode_cap_get_capCNodeRadix(cap);
        cptr2 = cptr << bits;

        radix = cptr2 >> (32 - radixBits);
        slot = ((cte_t *)(cap_cnode_cap_get_capCNodePtr(cap))) + radix;

        cap = slot->cap;
        bits += radixBits;

    } while (__builtin_expect(!!(bits < 32 && cap_capType_equals(cap, cap_cnode_cap)), 0));

    if (__builtin_expect(!!(bits > 32), 0)) {
        /* Depth mismatch. We've overshot 32 bits. The lookup we've done is
           safe, but wouldn't be allowed by the slowpath. */
        return cap_null_cap_new();
    }

    return cap;
}

static inline void __attribute__((fastcall))
switchToThread_fp(tcb_t *thread, pde_t *pd)
{
    word_t base;
    uint32_t new_pd = pptr_to_paddr(pd);

    if (__builtin_expect(!!(getCurrentPD() != new_pd), 1)) {
        setCurrentPD(new_pd);
    }

    /* Code equivalent to in Arch_switchToThread, see arch/object/structures.bf
     * for layout of gdt_data */
    /* update the GDT_TLS entry with the thread's TLS_BASE address */
    base = getRegister(thread, TLS_BASE);
    gdt_entry_gdt_data_ptr_set_base_low(ia32KSgdt + 6, base);
    gdt_entry_gdt_data_ptr_set_base_mid(ia32KSgdt + 6, (base >> 16) & 0xFF);
    gdt_entry_gdt_data_ptr_set_base_high(ia32KSgdt + 6, (base >> 24) & 0xFF);

    /* update the GDT_IPCBUF entry with the thread's IPC buffer address */
    base = thread->tcbIPCBuffer;
    gdt_entry_gdt_data_ptr_set_base_low(ia32KSgdt + 7, base);
    gdt_entry_gdt_data_ptr_set_base_mid(ia32KSgdt + 7, (base >> 16) & 0xFF);
    gdt_entry_gdt_data_ptr_set_base_high(ia32KSgdt + 7, (base >> 24) & 0xFF);

    ksCurThread = thread;
}

/* Custom implementation of functions for manipulating some data structures generated
   from arch/object/structures.bf */

static inline void
thread_state_ptr_set_tsType_np(thread_state_t *ts_ptr, word_t tsType)
{
    ts_ptr->words[0] = tsType;
}

static inline void
thread_state_ptr_mset_blockingIPCEndpoint_tsType(thread_state_t *ts_ptr,
                                                 word_t ep_ref,
                                                 word_t tsType)
{
    ts_ptr->words[0] = ep_ref | tsType;
}

static inline void
thread_state_ptr_set_blockingIPCDiminish_np(thread_state_t *ts_ptr, word_t dim)
{
    ts_ptr->words[2] &= (1ul<<(0));
    ts_ptr->words[1] = dim;
}

static inline void
cap_reply_cap_ptr_new_np(cap_t *cap_ptr, word_t capCallerSlot)
{
    /* 1 is capReplyMaster */
    cap_ptr->words[1] = ((unsigned int)(capCallerSlot)) | 1;
    cap_ptr->words[0] = cap_reply_cap;
}

static inline void
cap_reply_cap_ptr_new_np2(cap_t *cap_ptr, word_t isMaster, word_t capTCBPtr)
{
    cap_ptr->words[0] = ((unsigned int)(capTCBPtr)) | cap_reply_cap;
    cap_ptr->words[1] = isMaster;
}

static inline void
endpoint_ptr_mset_epQueue_tail_state(endpoint_t *ep_ptr, word_t epQueue_tail,
                                     word_t state)
{
    ep_ptr->words[0] = epQueue_tail | state;
}

static inline void
endpoint_ptr_set_epQueue_head_np(endpoint_t *ep_ptr, word_t epQueue_head)
{
    ep_ptr->words[1] = epQueue_head;
}


static inline bool_t
isValidNativeRoot_fp(cap_t pd_cap)
{



    return cap_capType_equals(pd_cap, cap_page_directory_cap);

}

static inline void
fastpath_copy_mrs(unsigned int length, tcb_t *src, tcb_t *dest)
{
    if (length == 2) {
        setRegister(dest, EBP, getRegister(src, EBP));
    }
    if (length == 2 || length == 1) {
        setRegister(dest, EDI, getRegister(src, EDI));
    }
}

/* This is an accelerated check that msgLength, which appears
   in the bottom of the msgInfo word, is <= 2 and that msgExtraCaps
   which appears above it is zero. We are assuming that n_msgRegisters == 2
   for this check to be useful.*/
typedef int __assert_failed_n_msgRegisters_eq_2[(n_msgRegisters == 2) ? 1 : -1];
static inline int
fastpath_mi_check(word_t msgInfo)
{
    return (msgInfo & ((1ul<<(seL4_MsgLengthBits + seL4_MsgExtraCapBits))-1ul)) > 2;
}

static inline bool_t hasDefaultSelectors(tcb_t *thread)
{
    return thread->tcbArch.tcbContext.registers[DS] == ((4 << 3) | 3) &&
           thread->tcbArch.tcbContext.registers[ES] == ((4 << 3) | 3);
}

static inline void __attribute__((fastcall)) __attribute__((__noreturn__))
fastpath_restore(word_t badge, word_t msgInfo)
{
    if (__builtin_expect(!!(ksCurThread == ia32KSfpuOwner), 0)) {
        /* We are using the FPU, make sure it is enabled */
        enableFpu();
    } else if (__builtin_expect(!!(ia32KSfpuOwner), 0)) {
        /* Someone is using the FPU and it might be enabled */
        disableFpu();
    } else {
        /* No-one (including us) is using the FPU, so we assume it
         * is currently disabled */
    }
    tss_ptr_set_esp0(&ia32KStss, ((uint32_t)ksCurThread) + 0x4c);
    ksCurThread->tcbArch.tcbContext.registers[EFLAGS] &= ~0x200;
    if (__builtin_expect(!!(hasDefaultSelectors(ksCurThread)), 1)) {
        __asm__ volatile("                movl %%ecx, %%esp \n                popl %%edi \n                popl %%ebp \n                addl $8, %%esp \n                popl %%fs \n                popl %%gs \n                addl $20, %%esp \n                popfl \n                orl $0x200, 44(%%ecx) \n                movl 36(%%ecx), %%edx \n                pop %%ecx \n                sti \n                sysexit \n            "
# 211 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c"
                     :
                     : "c"(&ksCurThread->tcbArch.tcbContext.registers[EDI]),
                     "a" (ksCurThread->tcbArch.tcbContext.registers[EAX]),
                     "b" (badge),
                     "S" (msgInfo)
                     : "memory"
                    );
    } else {
        __asm__ volatile("                movl %%ecx, %%esp \n                popl %%edi \n                popl %%ebp \n                popl %%ds \n                popl %%es \n                popl %%fs \n                popl %%gs \n                addl $20, %%esp \n                popfl \n                orl $0x200, 44(%%ecx) \n                movl 36(%%ecx), %%edx \n                pop %%ecx \n                sti \n                sysexit \n            "
# 235 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/fastpath/fastpath.c"
                     :
                     : "c"(&ksCurThread->tcbArch.tcbContext.registers[EDI]),
                     "a" (ksCurThread->tcbArch.tcbContext.registers[EAX]),
                     "b" (badge),
                     "S" (msgInfo)
                     : "memory"
                    );
    }
    /* This function is marked NORETURN, but gcc is not aware that the previous assembly
       block will return to user level. This loop prevents gcc complaining, and also helps
       it optimize register usage in this function (since gcc knows it can clobber everything
       as it will not be returning or calling anything else */
    while (1);
}

void __attribute__((fastcall)) __attribute__((__noreturn__))
fastpath_call(word_t cptr, word_t msgInfo)
{
    message_info_t info;
    cap_t ep_cap;
    endpoint_t *ep_ptr;
    unsigned int length;
    tcb_t *dest;
    word_t badge;
    cte_t *replySlot, *callerSlot;
    cap_t newVTable;
    void *vspace;
    uint32_t fault_type;

    /* Get message info, length, and fault type. */
    info = messageInfoFromWord(msgInfo);
    length = message_info_get_msgLength(info);
    fault_type = fault_get_faultType(ksCurThread->tcbFault);

    /* Check there's no extra caps, the length is ok and there's no
     * saved fault. */
    if (__builtin_expect(!!(fastpath_mi_check(msgInfo) || fault_type != fault_null_fault), 0)
                                                ) {
        slowpath(SysCall);
    }

    /* Check there is nothing waiting on the async endpoint */
    if (ksCurThread->boundAsyncEndpoint &&
            async_endpoint_ptr_get_state(ksCurThread->boundAsyncEndpoint) == AEPState_Active) {
        slowpath(SysCall);
    }

    /* Lookup the cap */
    ep_cap = lookup_fp((((cte_t *)((unsigned int)(ksCurThread)&~((1ul<<(10))-1ul)))+(tcbCTable))->cap, cptr);

    /* Check it's an endpoint */
    if (__builtin_expect(!!(!cap_capType_equals(ep_cap, cap_endpoint_cap) || !cap_endpoint_cap_get_capCanSend(ep_cap)), 0)
                                                          ) {
        slowpath(SysCall);
    }

    /* Get the endpoint address */
    ep_ptr = ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(ep_cap)));

    /* Get the destination thread, which is only going to be valid
     * if the endpoint is valid. */
    dest = ((tcb_t *)(endpoint_ptr_get_epQueue_head(ep_ptr)));

    /* Check that there's a thread waiting to receive */
    if (__builtin_expect(!!(endpoint_ptr_get_state(ep_ptr) != EPState_Recv), 0)) {
        slowpath(SysCall);
    }

    /* Get destination thread.*/
    newVTable = (((cte_t *)((unsigned int)(dest)&~((1ul<<(10))-1ul)))+(tcbVTable))->cap;

    /* Get vspace root. */



    vspace = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(newVTable)));


    /* Ensure that the destination has a valid VTable. */
    if (__builtin_expect(!!(! isValidNativeRoot_fp(newVTable)), 0)) {
        slowpath(SysCall);
    }

    /* Ensure the destination has a higher/equal priority to us. */
    if (__builtin_expect(!!(dest->tcbPriority < ksCurThread->tcbPriority), 0)) {
        slowpath(SysCall);
    }

    /* Ensure that the endpoint has standard non-diminishing rights. */
    if (__builtin_expect(!!(!cap_endpoint_cap_get_capCanGrant(ep_cap) || thread_state_ptr_get_blockingIPCDiminishCaps(&dest->tcbState)), 0)
                                                                               ) {
        slowpath(SysCall);
    }

    /* Ensure the original caller is in the current domain and can be scheduled directly. */
    if (1 > 1 && __builtin_expect(!!(dest->tcbDomain != ksCurDomain), 0)) {
        slowpath(SysCall);
    }

    /*
     * --- POINT OF NO RETURN ---
     *
     * At this stage, we have committed to performing the IPC.
     */

    /* Need to update NextEIP in the calling thread */
    setRegister(ksCurThread, NextEIP, getRegister(ksCurThread, NextEIP) + 2);

    /* Dequeue the destination. */
    endpoint_ptr_set_epQueue_head_np(ep_ptr, ((unsigned int)(dest->tcbEPNext)));
    if (__builtin_expect(!!(dest->tcbEPNext), 0)) {
        dest->tcbEPNext->tcbEPPrev = ((void *)0);
    } else {
        endpoint_ptr_mset_epQueue_tail_state(ep_ptr, 0, EPState_Idle);
    }

    badge = cap_endpoint_cap_get_capEPBadge(ep_cap);

    /* Block sender */
    thread_state_ptr_set_tsType_np(&ksCurThread->tcbState,
                                   ThreadState_BlockedOnReply);

    /* Get sender reply slot */
    replySlot = (((cte_t *)((unsigned int)(ksCurThread)&~((1ul<<(10))-1ul)))+(tcbReply));

    /* Get dest caller slot */
    callerSlot = (((cte_t *)((unsigned int)(dest)&~((1ul<<(10))-1ul)))+(tcbCaller));

    /* Insert reply cap */
    cap_reply_cap_ptr_new_np2(&callerSlot->cap, 0, ((unsigned int)(ksCurThread)));
    cap_reply_cap_ptr_new_np(&replySlot->cap, ((unsigned int)(callerSlot)));

    fastpath_copy_mrs (length, ksCurThread, dest);

    /* Dest thread is set Running, but not queued. */
    thread_state_ptr_set_tsType_np(&dest->tcbState,
                                   ThreadState_Running);
    switchToThread_fp(dest, vspace);

    msgInfo = wordFromMessageInfo(message_info_set_msgCapsUnwrapped(info, 0));
    fastpath_restore(badge, msgInfo);
}

void __attribute__((fastcall))
fastpath_reply_wait(word_t cptr, word_t msgInfo)
{
    message_info_t info;
    cap_t ep_cap;
    endpoint_t *ep_ptr;
    unsigned int length;
    cte_t *callerSlot;
    cte_t *replySlot;
    cap_t callerCap;
    tcb_t *caller;
    word_t badge;
    tcb_t *endpointTail;
    uint32_t fault_type;

    cap_t newVTable;
    void *vspace;

    /* Get message info and length */
    info = messageInfoFromWord(msgInfo);
    length = message_info_get_msgLength(info);
    fault_type = fault_get_faultType(ksCurThread->tcbFault);

    /* Check there's no extra caps, the length is ok and there's no
     * saved fault. */
    if (__builtin_expect(!!(fastpath_mi_check(msgInfo) || fault_type != fault_null_fault), 0)
                                                ) {
        slowpath(SysReplyWait);
    }

    /* Lookup the cap */
    ep_cap = lookup_fp((((cte_t *)((unsigned int)(ksCurThread)&~((1ul<<(10))-1ul)))+(tcbCTable))->cap,
                       cptr);

    /* Check it's an endpoint */
    if (__builtin_expect(!!(!cap_capType_equals(ep_cap, cap_endpoint_cap) || !cap_endpoint_cap_get_capCanReceive(ep_cap)), 0)
                                                             ) {
        slowpath(SysReplyWait);
    }

    /* Check there is nothing waiting on the async endpoint */
    if (ksCurThread->boundAsyncEndpoint &&
            async_endpoint_ptr_get_state(ksCurThread->boundAsyncEndpoint) == AEPState_Active) {
        slowpath(SysReplyWait);
    }

    /* Get the endpoint address */
    ep_ptr = ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(ep_cap)));

    /* Check that there's not a thread waiting to send */
    if (__builtin_expect(!!(endpoint_ptr_get_state(ep_ptr) == EPState_Send), 0)) {
        slowpath(SysReplyWait);
    }

    /* Only reply if the reply cap is valid. */
    callerSlot = (((cte_t *)((unsigned int)(ksCurThread)&~((1ul<<(10))-1ul)))+(tcbCaller));
    callerCap = callerSlot->cap;
    if (__builtin_expect(!!(!cap_capType_equals(callerCap, cap_reply_cap)), 0)) {
        slowpath(SysReplyWait);
    }

    /* Determine who the caller is. */
    caller = ((tcb_t *)(cap_reply_cap_get_capTCBPtr(callerCap)));

    /* Get reply slot from the caller */
    replySlot = (((cte_t *)((unsigned int)(caller)&~((1ul<<(10))-1ul)))+(tcbReply));

    /* Check that the caller has not faulted, in which case a fault
       reply is generated instead. */
    fault_type = fault_get_faultType(caller->tcbFault);
    if (__builtin_expect(!!(fault_type != fault_null_fault), 0)) {
        slowpath(SysReplyWait);
    }

    /* Get destination thread.*/
    newVTable = (((cte_t *)((unsigned int)(caller)&~((1ul<<(10))-1ul)))+(tcbVTable))->cap;

    /* Get vspace root. */



    vspace = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(newVTable)));


    /* Ensure that the destination has a valid MMU. */
    if (__builtin_expect(!!(! isValidNativeRoot_fp (newVTable)), 0)) {
        slowpath(SysReplyWait);
    }

    /* Ensure the original caller can be scheduled directly. */
    if (__builtin_expect(!!(caller->tcbPriority < ksCurThread->tcbPriority), 0)) {
        slowpath(SysReplyWait);
    }

    /* Ensure the original caller is in the current domain and can be scheduled directly. */
    if (1 > 1 && __builtin_expect(!!(caller->tcbDomain != ksCurDomain), 0)) {
        slowpath(SysReplyWait);
    }

    /*
     * --- POINT OF NO RETURN ---
     *
     * At this stage, we have committed to performing the IPC.
     */

    /* Need to update NextEIP in the calling thread */
    setRegister(ksCurThread, NextEIP, getRegister(ksCurThread, NextEIP) + 2);

    /* Set thread state to BlockedOnReceive */
    thread_state_ptr_mset_blockingIPCEndpoint_tsType(
        &ksCurThread->tcbState, (word_t)ep_ptr, ThreadState_BlockedOnReceive);
    thread_state_ptr_set_blockingIPCDiminish_np(
        &ksCurThread->tcbState, ! cap_endpoint_cap_get_capCanSend(ep_cap));

    /* Place the thread in the endpoint queue */
    endpointTail = ((tcb_t *)(endpoint_ptr_get_epQueue_tail(ep_ptr)));
    if (__builtin_expect(!!(!endpointTail), 1)) {
        ksCurThread->tcbEPPrev = ((void *)0);
        ksCurThread->tcbEPNext = ((void *)0);

        /* Set head/tail of queue and endpoint state. */
        endpoint_ptr_set_epQueue_head_np(ep_ptr, ((unsigned int)(ksCurThread)));
        endpoint_ptr_mset_epQueue_tail_state(ep_ptr, ((unsigned int)(ksCurThread)),
                                             EPState_Recv);
    } else {
        /* Append current thread onto the queue. */
        endpointTail->tcbEPNext = ksCurThread;
        ksCurThread->tcbEPPrev = endpointTail;
        ksCurThread->tcbEPNext = ((void *)0);

        /* Update tail of queue. */
        endpoint_ptr_mset_epQueue_tail_state(ep_ptr, ((unsigned int)(ksCurThread)),
                                             EPState_Recv);
    }

    /* Delete the reply cap. */
    cap_reply_cap_ptr_new_np(&replySlot->cap, ((unsigned int)(((void *)0))));
    callerSlot->cap = cap_null_cap_new();

    /* I know there's no fault, so straight to the transfer. */

    /* Replies don't have a badge. */
    badge = 0;

    fastpath_copy_mrs (length, ksCurThread, caller);

    /* Dest thread is set Running, but not queued. */
    thread_state_ptr_set_tsType_np(&caller->tcbState,
                                   ThreadState_Running);
    switchToThread_fp(caller, vspace);

    msgInfo = wordFromMessageInfo(message_info_set_msgCapsUnwrapped(info, 0));
    fastpath_restore(badge, msgInfo);
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/apic.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/apic.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/apic.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/apic.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/apic.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/apic.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/apic.h" 2

uint32_t apic_measure_freq(paddr_t paddr_apic);
paddr_t apic_get_base_paddr(void);
bool_t apic_init(uint32_t apic_khz, bool_t mask_legacy_irqs);

bool_t apic_is_interrupt_pending(void);
void apic_ack_active_interrupt(void);

void apic_send_init_ipi(cpu_id_t cpu_id);
void apic_send_startup_ipi(cpu_id_t cpu_id, paddr_t startup_addr);
void apic_send_ipi(cpu_id_t cpu_id, interrupt_t vector);
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/apic.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/apic.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/devices.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/apic.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/pit.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




/* ms after which a wraparound occurs (max. 54) */


void pit_init(void);
void pit_wait_wraparound(void);
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/apic.c" 2

typedef enum _apic_reg_t {
    APIC_ID = 0x020,
    APIC_VERSION = 0x030,
    APIC_TASK_PRIO = 0x080,
    APIC_ARBITR_PRIO = 0x090,
    APIC_PROC_PRIO = 0x0A0,
    APIC_EOI = 0x0B0,
    APIC_LOCAL_DEST = 0x0D0,
    APIC_DEST_FORMAT = 0x0E0,
    APIC_SVR = 0x0F0,
    APIC_ISR_BASE = 0x100,
    APIC_TMR_BASE = 0x180,
    APIC_IRR_BASE = 0x200,
    APIC_ERR_STATUS = 0x280,
    APIC_ICR1 = 0x300,
    APIC_ICR2 = 0x310,
    APIC_LVT_TIMER = 0x320,
    APIC_LVT_THERMAL = 0x330,
    APIC_LVT_PERF_CNTR = 0x340,
    APIC_LVT_LINT0 = 0x350,
    APIC_LVT_LINT1 = 0x360,
    APIC_LVT_ERROR = 0x370,
    APIC_TIMER_COUNT = 0x380,
    APIC_TIMER_CURRENT = 0x390,
    APIC_TIMER_DIVIDE = 0x3E0
} apic_reg_t;

__attribute__((__section__(".phys.text")))
static inline uint32_t __attribute__((always_inline))
apic_read_reg_(uint32_t addr, apic_reg_t reg)
{
    return *(volatile uint32_t*)(addr + reg);
}

__attribute__((__section__(".phys.text")))
static inline void __attribute__((always_inline))
apic_write_reg_(uint32_t addr, apic_reg_t reg, uint32_t val)
{
    *(volatile uint32_t*)(addr + reg) = val;
}

static inline uint32_t
apic_read_reg(apic_reg_t reg)
{
    return *(volatile uint32_t*)(0xffff0000 + reg);
}

static inline void
apic_write_reg(apic_reg_t reg, uint32_t val)
{
    *(volatile uint32_t*)(0xffff0000 + reg) = val;
}

__attribute__((__section__(".phys.text"))) __attribute__((externally_visible)) uint32_t
apic_measure_freq(paddr_t paddr_apic)
{
    pit_init();
    /* wait for 1st PIT wraparound */
    pit_wait_wraparound();

    /* start APIC timer countdown */
    apic_write_reg_(paddr_apic, APIC_TIMER_DIVIDE, 0xb); /* divisor = 1 */
    apic_write_reg_(paddr_apic, APIC_TIMER_COUNT, 0xffffffff);

    /* wait for 2nd PIT wraparound */
    pit_wait_wraparound();

    /* calculate APIC/bus cycles per ms = frequency in kHz */
    return (0xffffffff - apic_read_reg_(paddr_apic, APIC_TIMER_CURRENT)) / 50;
}

__attribute__((__section__(".boot.text"))) paddr_t
apic_get_base_paddr(void)
{
    apic_base_msr_t apic_base_msr;

    apic_base_msr.words[0] = ia32_rdmsr_low(0x01B);
    if (!apic_base_msr_get_enabled(apic_base_msr)) {
        kprintf("APIC: Enabled bit not set\n");
    }

    return apic_base_msr_get_base_addr(apic_base_msr);
}

__attribute__((__section__(".boot.text"))) bool_t
apic_init(uint32_t apic_khz, bool_t mask_legacy_irqs)
{
    apic_version_t apic_version;
    uint32_t num_lvt_entries;

    apic_version.words[0] = apic_read_reg(APIC_VERSION);

    /* check for correct version: 0x1X */
    if (apic_version_get_version(apic_version) >> 4 != 1) {
        kprintf("APIC: apic_version must be 0x1X\n");
        return false;
    }

    /* check for correct number of LVT entries */
    num_lvt_entries = apic_version_get_max_lvt_entry(apic_version) + 1;
    if (num_lvt_entries < 3) {
        kprintf("APIC: number of LVT entries: %d\n", num_lvt_entries);
        kprintf("APIC: number of LVT entries must be >= 3\n");
        return false;
    }

    /* initialise APIC timer */
    apic_write_reg(APIC_TIMER_DIVIDE, 0xb); /* divisor = 1 */
    apic_write_reg(APIC_TIMER_COUNT, apic_khz * 20);

    /* enable APIC using SVR register */
    apic_write_reg(
        APIC_SVR,
        apic_svr_new(
            0, /* focus_processor_chk */
            1, /* enabled             */
            int_spurious /* spurious_vector     */
        ).words[0]
    );

    /* mask/unmask LINT0 (used for legacy IRQ delivery) */
    apic_write_reg(
        APIC_LVT_LINT0,
        apic_lvt_new(
            0, /* timer_mode      */
            mask_legacy_irqs, /* masked          */
            0, /* trigger_mode    */
            0, /* remote_irr      */
            0, /* pin_polarity    */
            0, /* delivery_status */
            7, /* delivery_mode   */
            0 /* vector          */
        ).words[0]
    );

    /* mask LINT1 (used for NMI delivery) */
    apic_write_reg(
        APIC_LVT_LINT1,
        apic_lvt_new(
            0, /* timer_mode      */
            1, /* masked          */
            0, /* trigger_mode    */
            0, /* remote_irr      */
            0, /* pin_polarity    */
            0, /* delivery_status */
            0, /* delivery_mode   */
            0 /* vector          */
        ).words[0]
    );

    /* initialise timer */
    apic_write_reg(
        APIC_LVT_TIMER,
        apic_lvt_new(
            1, /* timer_mode      */
            0, /* masked          */
            0, /* trigger_mode    */
            0, /* remote_irr      */
            0, /* pin_polarity    */
            0, /* delivery_status */
            0, /* delivery_mode   */
            int_timer /* vector          */
        ).words[0]
    );

    /*
    printf("APIC: ID=0x%x\n", apic_read_reg(APIC_ID) >> 24);
    printf("APIC: SVR=0x%x\n", apic_read_reg(APIC_SVR));
    printf("APIC: LVT_TIMER=0x%x\n", apic_read_reg(APIC_LVT_TIMER));
    printf("APIC: LVT_LINT0=0x%x\n", apic_read_reg(APIC_LVT_LINT0));
    printf("APIC: LVT_LINT1=0x%x\n", apic_read_reg(APIC_LVT_LINT1));
    printf("APIC: LVT_ERROR=0x%x\n", apic_read_reg(APIC_LVT_ERROR));
    printf("APIC: LVT_PERF_CNTR=0x%x\n", apic_read_reg(APIC_LVT_PERF_CNTR));
    printf("APIC: LVT_THERMAL=0x%x\n", apic_read_reg(APIC_LVT_THERMAL));
    */
    return true;
}

bool_t apic_is_interrupt_pending(void)
{
    unsigned int i;

    /* read 256-bit register: each 32-bit word is 16 byte aligned */
    if(!(int_irq_min % 32 == 0)) _assert_fail("int_irq_min % 32 == 0", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/apic.c", 202, __FUNCTION__);
    for (i = int_irq_min; i <= int_irq_max; i += 32) {
        if (apic_read_reg(APIC_IRR_BASE + i / 2) != 0) {
            return true;
        }
    }
    return false;
}

void apic_ack_active_interrupt(void)
{
    apic_write_reg(APIC_EOI, 0);
}

__attribute__((__section__(".boot.text"))) void
apic_send_init_ipi(cpu_id_t cpu_id)
{
    apic_write_reg(
        APIC_ICR2,
        apic_icr2_new(
            cpu_id /* dest */
        ).words[0]
    );
    apic_write_reg(
        APIC_ICR1,
        apic_icr1_new(
            0, /* dest_shorthand  */
            1, /* trigger_mode    */
            1, /* level           */
            0, /* delivery_status */
            0, /* dest_mode       */
            5, /* delivery_mode   */
            0 /* vector          */
        ).words[0]
    );

    apic_write_reg(
        APIC_ICR2,
        apic_icr2_new(
            cpu_id /* dest */
        ).words[0]
    );
    apic_write_reg(
        APIC_ICR1,
        apic_icr1_new(
            0, /* dest_shorthand  */
            1, /* trigger_mode    */
            0, /* level           */
            0, /* delivery_status */
            0, /* dest_mode       */
            5, /* delivery_mode   */
            0 /* vector          */
        ).words[0]
    );
}

__attribute__((__section__(".boot.text"))) void
apic_send_startup_ipi(cpu_id_t cpu_id, paddr_t startup_addr)
{
    /* check if 4K aligned */
    if(!((!((startup_addr) & ((1ul<<(IA32_4K_bits))-1ul))))) _assert_fail("IS_ALIGNED(startup_addr, PAGE_BITS)", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/apic.c", 262, __FUNCTION__);
    /* check if startup_addr < 640K */
    if(!(startup_addr < 0xa0000)) _assert_fail("startup_addr < 0xa0000", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/apic.c", 264, __FUNCTION__);
    startup_addr >>= IA32_4K_bits;

    apic_write_reg(
        APIC_ICR2,
        apic_icr2_new(
            cpu_id /* dest */
        ).words[0]
    );
    apic_write_reg(
        APIC_ICR1,
        apic_icr1_new(
            0, /* dest_shorthand  */
            0, /* trigger_mode    */
            0, /* level           */
            0, /* delivery_status */
            0, /* dest_mode       */
            6, /* delivery_mode   */
            startup_addr /* vector          */
        ).words[0]
    );
}

void apic_send_ipi(cpu_id_t cpu_id, interrupt_t vector)
{
    apic_write_reg(
        APIC_ICR2,
        apic_icr2_new(
            cpu_id /* dest */
        ).words[0]
    );
    apic_write_reg(
        APIC_ICR1,
        apic_icr1_new(
            0, /* dest_shorthand  */
            0, /* trigger_mode    */
            0, /* level           */
            0, /* delivery_status */
            0, /* dest_mode       */
            0, /* delivery_mode   */
            vector /* vector          */
        ).words[0]
    );
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/bootinfo.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/bootinfo.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/bootinfo.h" 2




/* bootinfo data structures (directly corresponding to abstract specification) */



/* fixed cap positions in root CNode */
# 39 "/home/kq/Sources/RefOS_x86/kernel/include/bootinfo.h"
/* type definitions */

typedef uint32_t slot_pos_t;

typedef struct slot_region {
    slot_pos_t start;
    slot_pos_t end;
} slot_region_t;



typedef struct bi_dev_reg {
    paddr_t base_paddr; /* base physical address of device region */
    uint32_t frame_size_bits; /* size (2^n bytes) of a device-region frame */
    slot_region_t frame_caps; /* device-region frame caps */
} bi_dev_reg_t;

typedef struct bi {
    node_id_t node_id;
    uint32_t num_nodes;
    uint32_t num_iopt_levels; /* number of IOMMU PT levels (0 if no IOMMU support) */
    vptr_t ipcbuf_vptr; /* vptr to initial thread's IPC buffer */
    slot_region_t null_caps; /* null caps (empty slots) */
    slot_region_t sh_frame_caps; /* shared-frame caps */
    slot_region_t ui_frame_caps; /* userland-image frame caps */
    slot_region_t ui_pd_caps; /* userland-image PD caps */
    slot_region_t ui_pt_caps; /* userland-image PT caps */
    slot_region_t ut_obj_caps; /* untyped-object caps (UT caps) */
    slot_region_t ut_device_obj_caps; /* untyped-objects caps for device frames */
    paddr_t ut_obj_paddr_list [800]; /* physical address of each UT cap */
    uint8_t ut_obj_size_bits_list[800]; /* size (2^n) bytes of each UT cap */
    uint8_t it_cnode_size_bits; /* initial thread's root CNode size (2^n slots) */
    dom_t it_domain; /* initial thread's domain ID */
} bi_t;

/* adjust constants in config.h if this assert fails */
typedef int __assert_failed_bi_size[(sizeof(bi_t) <= (1ul<<(IA32_4K_bits))) ? 1 : -1];
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/boot.h" 2



/*
 * Resolve naming differences between the abstract specifications
 * of the bootstrapping phase and the runtime phase of the kernel.
 */
typedef cte_t slot_t;
typedef cte_t* slot_ptr_t;



/* (node-local) state accessed only during bootstrapping */

typedef struct ndks_boot {
    region_t freemem[2];
    bi_t* bi_frame;
    slot_pos_t slot_pos_cur;
    slot_pos_t slot_pos_max;
} ndks_boot_t;

extern ndks_boot_t ndks_boot;

/* function prototypes */

static inline bool_t
is_reg_empty(region_t reg)
{
    return reg.start == reg.end;
}

pptr_t alloc_region(uint32_t size_bits);
bool_t insert_region(region_t reg);
void write_slot(slot_ptr_t slot_ptr, cap_t cap);
cap_t create_root_cnode(void);
bool_t provide_cap(cap_t root_cnode_cap, cap_t cap);
void write_it_pd_pts(cap_t root_cnode_cap, cap_t it_pd_cap);
bool_t create_idle_thread(void);
bool_t create_untypeds_for_region(cap_t root_cnode_cap, bool_t deviceMemory, region_t reg, slot_pos_t first_untyped_slot);
bool_t create_untypeds(cap_t root_cnode_cap, region_t boot_mem_reuse_reg);
void bi_finalise(void);
bool_t create_irq_cnode(void);
void create_domain_cap(cap_t root_cnode_cap);

cap_t create_ipcbuf_frame(cap_t root_cnode_cap, cap_t pd_cap, vptr_t vptr);

pptr_t allocate_bi_frame(node_id_t node_id, uint32_t num_nodes, vptr_t ipcbuf_vptr);

void create_bi_frame_cap(cap_t root_cnode_cap, cap_t pd_cap, pptr_t pptr, vptr_t vptr);

typedef struct create_frames_of_region_ret {
    slot_region_t region;
    bool_t success;
} create_frames_of_region_ret_t;

create_frames_of_region_ret_t
create_frames_of_region(
    cap_t root_cnode_cap,
    cap_t pd_cap,
    region_t reg,
    bool_t do_map,
    int32_t pv_offset
);

cap_t
create_it_pd_pts(
    cap_t root_cnode_cap,
    v_region_t ui_v_reg,
    vptr_t ipcbuf_vptr,
    vptr_t bi_frame_vptr
);

bool_t
create_initial_thread(
    cap_t root_cnode_cap,
    cap_t it_pd_cap,
    vptr_t ui_v_entry,
    vptr_t bi_frame_vptr,
    vptr_t ipcbuf_vptr,
    cap_t ipcbuf_cap
);
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/apic.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/multiboot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




/* Adapted from the MultiBoot Specification:  */
/* www.gnu.org/software/grub/manual/multiboot */



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/multiboot.h" 2

typedef struct multiboot_module {
    uint32_t start;
    uint32_t end;
    uint32_t name;
    uint32_t reserved;
} __attribute__((packed)) multiboot_module_t;

typedef struct vbe_control_info {
    /* We do not need to interpret the contents, just get the size right */
    uint32_t data[512 / sizeof(uint32_t)];
} vbe_control_info_t;

typedef struct vbe_mode_info {
    /* We do not need to interpret the contents, just get the size right */
    uint32_t data[256 / sizeof(uint32_t)];
} vbe_mode_info_t;

typedef struct multiboot_mmap_entry {
    uint32_t size;
    uint64_t addr;
    uint64_t len;
    uint32_t type;
} __attribute__((packed)) multiboot_memory_map_t;

typedef struct multiboot_info {
    uint32_t flags;
    uint32_t mem_lower;
    uint32_t mem_upper;
    uint32_t boot_device;
    uint32_t cmdline;
    uint32_t mod_count;
    uint32_t mod_list;
    uint32_t syms[4];
    uint32_t mmap_length;
    void *mmap_addr;
    uint32_t drives_length;
    void *drives_addr;
    void *config_table;
    void *boot_loader_name;
    void *apm_table;
    vbe_control_info_t *vbe_control_info;
    vbe_mode_info_t *vbe_mode_info;
    uint16_t vbe_mode;
    uint16_t vbe_interface_seg;
    uint16_t vbe_interface_off;
    uint16_t vbe_interface_len;
} __attribute__((packed)) multiboot_info_t;
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/bootinfo.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/multiboot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/bootinfo.h" 2

typedef struct ia32_mem_region {
    uint64_t paddr;
    uint64_t len;
} ia32_mem_region_t;

typedef struct ia32_bootinfo_frame {
    vbe_control_info_t vbe_control_info;
    vbe_mode_info_t vbe_mode_info;
    uint32_t vbe_mode;
    uint32_t vbe_interface_seg;
    uint32_t vbe_interface_off;
    uint32_t vbe_interface_len;
    ia32_mem_region_t mem_regions[10];
} ia32_bootinfo_frame_t;

typedef int __assert_failed_ia32_bootinfo_frame_4k[(sizeof(ia32_bootinfo_frame_t) < (1ul<<(IA32_4K_bits))) ? 1 : -1];;
# 18 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/acpi.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/acpi.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/acpi.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/acpi.h" 2

/* Generic System Descriptor Table Header */
typedef struct acpi_header {
    char signature[4];
    uint32_t length;
    uint8_t revision;
    uint8_t checksum;
    char oem_id[6];
    char oem_table_id[8];
    uint32_t oem_revision;
    char creater_id[4];
    uint32_t creater_revision;
} __attribute__((packed)) acpi_header_t;

/* Root System Descriptor Table */
typedef struct acpi_rsdt {
    acpi_header_t header;
    uint32_t entry[1];
} __attribute__((packed)) acpi_rsdt_t;

acpi_rsdt_t* acpi_init(void);

uint32_t acpi_madt_scan(
    acpi_rsdt_t* acpi_rsdt,
    cpu_id_t* cpu_list,
    uint32_t max_list_len,
    uint32_t* num_ioapic,
    paddr_t* ioapic_addrs
);


typedef struct acpi_rmrr_entry {
    dev_id_t device;
    uint32_t base;
    uint32_t limit;
} acpi_rmrr_entry_t;

typedef struct acpi_rmrr_list {
    acpi_rmrr_entry_t entries[32];
    int num;
} acpi_rmrr_list_t;

void acpi_dmar_scan(
    acpi_rsdt_t* acpi_rsdt,
    paddr_t* drhu_list,
    uint32_t* num_drhu,
    uint32_t max_dhru_list_len,
    acpi_rmrr_list_t *rmrr_list
);
# 19 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot.h" 2

typedef struct dev_p_regs {
    uint32_t count;
    p_region_t list[10];
} dev_p_regs_t;

typedef struct ui_info {
    p_region_t p_reg; /* region where the userland image lies in */
    int32_t pv_offset; /* UI virtual address + pv_offset = UI physical address */
    vptr_t v_entry; /* entry point (virtual address) of userland image */
} ui_info_t;

typedef struct vesa_info {
    vbe_control_info_t vbe_control_info;
    vbe_mode_info_t vbe_mode_info;
    uint32_t vbe_mode;
    uint32_t vbe_interface_seg;
    uint32_t vbe_interface_off;
    uint32_t vbe_interface_len;
} vesa_info_t;

cap_t create_unmapped_it_frame_cap(pptr_t pptr, bool_t use_large);
cap_t create_mapped_it_frame_cap(cap_t pd_cap, pptr_t pptr, vptr_t vptr, bool_t use_large, bool_t executable);

bool_t init_node_state(
    p_region_t avail_p_reg,
    p_region_t sh_p_reg,
    dev_p_regs_t* dev_p_regs,
    ui_info_t ui_info,
    p_region_t boot_mem_reuse_p_reg,
    node_id_t node_id,
    uint32_t num_nodes,
    cpu_id_t* cpu_list,
    /* parameters below not modeled in abstract specification */
    pdpte_t* kernel_pdpt,
    pde_t* kernel_pd,
    pte_t* kernel_pt,
    vesa_info_t* vesa_info,
    ia32_mem_region_t* mem_regions

    , cpu_id_t cpu_id,
    uint32_t num_drhu,
    paddr_t* drhu_list,
    acpi_rmrr_list_t *rmrr_list

);

bool_t init_node_cpu(
    uint32_t apic_khz,
    bool_t mask_legacy_irqs
);
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/bootinfo.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot_sys.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/multiboot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot_sys.h" 2

bool_t in_boot_phase(void);
cpu_id_t cur_cpu_id(void);
node_id_t node_of_cpu(cpu_id_t);
uint16_t console_port_of_node(node_id_t node_id);
uint16_t debug_port_of_node(node_id_t node_id);

void boot_sys(
    unsigned long multiboot_magic,
    multiboot_info_t* mbi,
    uint32_t apic_khz
);
void boot_node(void);
void insert_dev_p_reg(p_region_t reg);
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/fpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/ioport.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/ioport.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/ioport.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/ioport.h" 2



exception_t decodeIA32PortInvocation(word_t label, unsigned int length, cptr_t cptr, cte_t *slot, cap_t cap, extra_caps_t extraCaps, word_t* buffer);
# 25 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 26 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 27 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2


# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/intel-vtd.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/acpi.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/intel-vtd.h" 2

void invalidate_iotlb(void);
void invalidate_context_cache(void);
void vtd_handle_fault(void);

bool_t vtd_init(
    cpu_id_t cpu_id,
    uint32_t num_drhu,
    acpi_rmrr_list_t *rmrr_list
);
# 30 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/vtx.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 34 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c" 2


/* functions exactly corresponding to abstract specification */

__attribute__((__section__(".boot.text"))) static void
init_irqs(cap_t root_cnode_cap, bool_t mask_irqs)
{
    irq_t i;

    for (i = 0; i <= maxIRQ; i++) {
        if (i == irq_timer) {
            setIRQState(IRQTimer, i);
        } else if (i == irq_iommu) {
            setIRQState(IRQReserved, i);

        } else if (i == 2) {
            /* cascaded legacy PIC */
            setIRQState(IRQReserved, i);

        } else if (i >= irq_controller_min && i <= irq_controller_max)
            if (mask_irqs)
                /* Don't use setIRQState() here because it implicitly also enables */
                /* the IRQ on the interrupt controller which only node 0 is allowed to do. */
            {
                intStateIRQTable[i] = IRQReserved;
            } else {
                setIRQState(IRQInactive, i);
            }
        else if (i >= irq_msi_min && i <= irq_msi_max) {
            setIRQState(IRQInactive, i);
        } else if (i >= irq_ipi_min && i <= irq_ipi_max) {
            setIRQState(IRQInactive, i);
        }
    }

    /* provide the IRQ control cap */
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (4 /* global IRQ controller cap */)), cap_irq_control_cap_new());
}

/* Create a frame cap for the initial thread. */

__attribute__((__section__(".boot.text"))) cap_t
create_unmapped_it_frame_cap(pptr_t pptr, bool_t use_large)
{
    vm_page_size_t frame_size;

    if (use_large) {
        frame_size = IA32_LargePage;
    } else {
        frame_size = IA32_SmallPage;
    }
    return
        cap_frame_cap_new(
            frame_size, /* capFSize           */
            0, /* capFMappedObject   */
            0, /* capFMappedIndex    */
            IA32_MAPPING_PD, /* capFMappedType     */
            wordFromVMRights(VMReadWrite), /* capFVMRights       */
            pptr /* capFBasePtr        */
        );
}

__attribute__((__section__(".boot.text"))) cap_t
create_mapped_it_frame_cap(cap_t vspace_cap, pptr_t pptr, vptr_t vptr, bool_t use_large, bool_t executable)
{
    cap_t cap;
    int shift = 10 + 10 + IA32_4K_bits;
    pde_t *pd;
    uint32_t pd_index;
    if (shift == 32) {
        pd = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(vspace_cap)));
    } else {
        uint32_t pdpt_index = vptr >> shift;
        pdpte_t *pdpt = ((pdpte_t*)(cap_pdpt_cap_get_capPDPTBasePtr(vspace_cap)));
        pd = paddr_to_pptr(pdpte_get_pd_base_address(pdpt[pdpt_index]));
    }
    pd_index = vptr >> (10 + IA32_4K_bits);

    if (use_large) {
        cap = cap_frame_cap_new(
                  IA32_LargePage, /* capFSize           */
                  ((unsigned int)(pd)), /* capFMappedObject   */
                  pd_index, /* capFMappedIndex    */
                  IA32_MAPPING_PD, /* capFMappedType     */
                  wordFromVMRights(VMReadWrite), /* capFVMRights       */
                  pptr /* capFBasePtr        */
              );
    } else {
        uint32_t pt_index = (vptr >> IA32_4K_bits) & ((1ul<<(10))-1ul);
        pte_t *pt = paddr_to_pptr(pde_pde_small_get_pt_base_address(pd[pd_index]));
        cap = cap_frame_cap_new(
                  IA32_SmallPage, /* capFSize           */
                  ((unsigned int)(pt)), /* capFMappedObject   */
                  pt_index, /* capFMappedIndex    */
                  IA32_MAPPING_PD, /* capFMappedType     */
                  wordFromVMRights(VMReadWrite), /* capFVMRights       */
                  pptr /* capFBasePtr        */
              );
    }
    map_it_frame_cap(cap);
    return cap;
}

/* Create a page table for the initial thread */

static __attribute__((__section__(".boot.text"))) cap_t
create_it_page_table_cap(cap_t vspace_cap, pptr_t pptr, vptr_t vptr)
{
    cap_t cap;
    int shift = 10 + 10 + IA32_4K_bits;
    pde_t *pd;
    uint32_t pd_index;
    if (shift == 32) {
        pd = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(vspace_cap)));
    } else {
        uint32_t pdpt_index = vptr >> shift;
        pdpte_t *pdpt = ((pdpte_t*)(cap_pdpt_cap_get_capPDPTBasePtr(vspace_cap)));
        pd = paddr_to_pptr(pdpte_get_pd_base_address(pdpt[pdpt_index]));
    }
    pd_index = vptr >> (10 + IA32_4K_bits);
    cap = cap_page_table_cap_new(
              ((unsigned int)(pd)), /* capPTMappedObject */
              pd_index, /* capPTMappedIndex  */
              pptr /* capPTBasePtr      */
          );
    map_it_pt_cap(cap);
    return cap;
}

static __attribute__((__section__(".boot.text"))) cap_t
create_it_page_directory_cap(cap_t vspace_cap, pptr_t pptr, vptr_t vptr)
{
    cap_t cap;
    int shift = 10 + 10 + IA32_4K_bits;
    uint32_t pdpt_index;
    pdpte_t *pdpt;
    if (shift == 32) {
        pdpt = ((void *)0);
        pdpt_index = 0;
    } else {
        pdpt = ((pdpte_t*)(cap_pdpt_cap_get_capPDPTBasePtr(vspace_cap)));
        pdpt_index = vptr >> shift;
    }
    cap = cap_page_directory_cap_new(
              ((unsigned int)(pdpt)), /* capPDMappedObject */
              pdpt_index, /* capPDMappedIndex  */
              pptr /* capPDBasePtr      */
          );
    if (cap_get_capType(vspace_cap) != cap_null_cap) {
        map_it_pd_cap(cap);
    }
    return cap;
}

/* Create an address space for the initial thread.
 * This includes page directory and page tables */
__attribute__((__section__(".boot.text"))) static cap_t
create_it_address_space(cap_t root_cnode_cap, v_region_t it_v_reg)
{
    cap_t vspace_cap;
    vptr_t vptr;
    pptr_t pptr;
    slot_pos_t slot_pos_before;
    slot_pos_t slot_pos_after;

    slot_pos_before = ndks_boot.slot_pos_cur;
    if (0 == 0) {
        cap_t pd_cap;
        pptr_t pd_pptr;
        /* just create single PD obj and cap */
        pd_pptr = alloc_region((10 + 2));
        if (!pd_pptr) {
            return cap_null_cap_new();
        }
        memzero(((pde_t *)(pd_pptr)), 1 << (10 + 2));
        copyGlobalMappings(((pde_t *)(pd_pptr)));
        pd_cap = create_it_page_directory_cap(cap_null_cap_new(), pd_pptr, 0);
        if (!provide_cap(root_cnode_cap, pd_cap)) {
            return cap_null_cap_new();
        }
        write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (3 /* initial thread's vspace root cap */)), pd_cap);
        vspace_cap = pd_cap;
    } else {
        cap_t pdpt_cap;
        pptr_t pdpt_pptr;
        unsigned int i;
        /* create a PDPT obj and cap */
        pdpt_pptr = alloc_region((0 + 0));
        if (!pdpt_pptr) {
            return cap_null_cap_new();
        }
        memzero(((pdpte_t *)(pdpt_pptr)), 1 << (0 + 0));
        pdpt_cap = cap_pdpt_cap_new(
                       pdpt_pptr /* capPDPTBasePtr */
                   );
        /* create all PD objs and caps necessary to cover userland image. For simplicity
         * to ensure we also cover the kernel window we create all PDs */
        for (i = 0; i < (1ul<<(0)); i++) {
            /* The compiler is under the mistaken belief here that this shift could be
             * undefined. However, in the case that it would be undefined this code path
             * is not reachable because PDPT_BITS == 0 (see if statement at the top of
             * this function), so to work around it we must both put in a redundant
             * if statement AND place the shift in a variable. While the variable
             * will get compiled away it prevents the compiler from evaluating
             * the 1 << 32 as a constant when it shouldn't
             * tl;dr gcc evaluates constants even if code is unreachable */
            int shift = (10 + 10 + IA32_4K_bits);
            if (shift != 32) {
                vptr = i << shift;
            } else {
                return cap_null_cap_new();
            }

            pptr = alloc_region((10 + 2));
            if (!pptr) {
                return cap_null_cap_new();
            }
            memzero(((pde_t *)(pptr)), 1 << (10 + 2));
            if (!provide_cap(root_cnode_cap,
                             create_it_page_directory_cap(pdpt_cap, pptr, vptr))
               ) {
                return cap_null_cap_new();
            }
        }
        /* now that PDs exist we can copy the global mappings */
        copyGlobalMappings(((pdpte_t *)(pdpt_pptr)));
        write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (3 /* initial thread's vspace root cap */)), pdpt_cap);
        vspace_cap = pdpt_cap;
    }

    slot_pos_after = ndks_boot.slot_pos_cur;
    ndks_boot.bi_frame->ui_pd_caps = (slot_region_t) {
        slot_pos_before, slot_pos_after
    };
    /* create all PT objs and caps necessary to cover userland image */
    slot_pos_before = ndks_boot.slot_pos_cur;

    for (vptr = (((it_v_reg.start) >> (10 + IA32_4K_bits)) << (10 + IA32_4K_bits));
            vptr < it_v_reg.end;
            vptr += (1ul<<(10 + IA32_4K_bits))) {
        pptr = alloc_region((10 + 2));
        if (!pptr) {
            return cap_null_cap_new();
        }
        memzero(((pte_t *)(pptr)), 1 << (10 + 2));
        if (!provide_cap(root_cnode_cap,
                         create_it_page_table_cap(vspace_cap, pptr, vptr))
           ) {
            return cap_null_cap_new();
        }
    }

    slot_pos_after = ndks_boot.slot_pos_cur;
    ndks_boot.bi_frame->ui_pt_caps = (slot_region_t) {
        slot_pos_before, slot_pos_after
    };

    return vspace_cap;
}

__attribute__((__section__(".boot.text"))) static bool_t
create_device_untypeds(
    cap_t root_cnode_cap,
    dev_p_regs_t *dev_p_regs)
{
    slot_pos_t slot_pos_before;
    slot_pos_t slot_pos_after;
    uint32_t i;

    slot_pos_before = ndks_boot.slot_pos_cur;
    for (i = 0; i < dev_p_regs->count; i++) {
        if (!create_untypeds_for_region(root_cnode_cap, true, paddr_to_pptr_reg(dev_p_regs->list[i]), ndks_boot.bi_frame->ut_obj_caps.start)) {
            return false;
        }
    }
    slot_pos_after = ndks_boot.slot_pos_cur;
    ndks_boot.bi_frame->ut_device_obj_caps = (slot_region_t) {
        slot_pos_before, slot_pos_after
    };
    return true;
}

__attribute__((__section__(".boot.text"))) static void
create_ia32_bootinfo(ia32_bootinfo_frame_t *bootinfo, vesa_info_t *vesa_info, ia32_mem_region_t* mem_regions)
{
    int i;
    bootinfo->vbe_control_info = vesa_info->vbe_control_info;
    bootinfo->vbe_mode_info = vesa_info->vbe_mode_info;
    bootinfo->vbe_mode = vesa_info->vbe_mode;
    bootinfo->vbe_interface_seg = vesa_info->vbe_interface_seg;
    bootinfo->vbe_interface_off = vesa_info->vbe_interface_off;
    bootinfo->vbe_interface_len = vesa_info->vbe_interface_len;
    for (i = 0; i < 10; i++) {
        bootinfo->mem_regions[i] = mem_regions[i];
    }
}

__attribute__((__section__(".boot.text"))) static pptr_t
create_arch_bi_frame_cap(
    cap_t root_cnode_cap,
    cap_t pd_cap,
    vptr_t vptr
)
{
    pptr_t pptr;
    cap_t cap;

    pptr = alloc_region(IA32_4K_bits);
    if (!pptr) {
        kprintf("Kernel init failed: could not allocate arch bootinfo frame\n");
        return 0;
    }
    clearMemory((void*)pptr, IA32_4K_bits);

    /* create a cap and write it into the root cnode */
    cap = create_mapped_it_frame_cap(pd_cap, pptr, vptr, false, false);
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (8 /* arch specific bootinfo frame cap */)), cap);

    return pptr;
}

/* This function initialises a node's kernel state. It does NOT initialise the CPU. */

__attribute__((__section__(".boot.text"))) bool_t
init_node_state(
    p_region_t avail_p_reg,
    p_region_t sh_p_reg,
    dev_p_regs_t* dev_p_regs,
    ui_info_t ui_info,
    p_region_t boot_mem_reuse_p_reg,
    node_id_t node_id,
    uint32_t num_nodes,
    cpu_id_t* cpu_list,
    /* parameters below not modeled in abstract specification */
    pdpte_t* kernel_pdpt,
    pde_t* kernel_pd,
    pte_t* kernel_pt,
    vesa_info_t* vesa_info,
    ia32_mem_region_t* mem_regions

    , cpu_id_t cpu_id,
    uint32_t num_drhu,
    paddr_t* drhu_list,
    acpi_rmrr_list_t *rmrr_list

)
{
    cap_t root_cnode_cap;
    vptr_t arch_bi_frame_vptr;
    vptr_t bi_frame_vptr;
    vptr_t ipcbuf_vptr;
    cap_t it_vspace_cap;
    cap_t ipcbuf_cap;
    pptr_t bi_frame_pptr;
    pptr_t arch_bi_frame_pptr;
    create_frames_of_region_ret_t create_frames_ret;
    int i;






    /* convert from physical addresses to kernel pptrs */
    region_t avail_reg = paddr_to_pptr_reg(avail_p_reg);
    region_t ui_reg = paddr_to_pptr_reg(ui_info.p_reg);
    region_t sh_reg = paddr_to_pptr_reg(sh_p_reg);
    region_t boot_mem_reuse_reg = paddr_to_pptr_reg(boot_mem_reuse_p_reg);

    /* convert from physical addresses to userland vptrs */
    v_region_t ui_v_reg;
    v_region_t it_v_reg;
    ui_v_reg.start = ui_info.p_reg.start - ui_info.pv_offset;
    ui_v_reg.end = ui_info.p_reg.end - ui_info.pv_offset;

    ipcbuf_vptr = ui_v_reg.end;
    bi_frame_vptr = ipcbuf_vptr + (1ul<<(IA32_4K_bits));
    arch_bi_frame_vptr = bi_frame_vptr + (1ul<<(IA32_4K_bits));

    /* The region of the initial thread is the user image + ipcbuf + boot info and arch boot info */
    it_v_reg.start = ui_v_reg.start;
    it_v_reg.end = arch_bi_frame_vptr + (1ul<<(IA32_4K_bits));

    /* make the free memory available to alloc_region() */
    ndks_boot.freemem[0] = avail_reg;
    for (i = 1; i < 2; i++) {
        ndks_boot.freemem[i] = (region_t){ .start = 0, .end = 0 };
    }

    /* initialise virtual-memory-related data structures (not in abstract spec) */
    if (!init_vm_state(kernel_pdpt, kernel_pd, kernel_pt)) {
        return false;
    }
# 465 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c"
    /* create the root cnode */
    root_cnode_cap = create_root_cnode();

    /* create the IO port cap */
    write_slot(
        (((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (5 /* global IO port cap (null cap if not supported) */)),
        cap_io_port_cap_new(
            0, /* first port */
            (1ul<<(16)) - 1 /* last port  */
        )
    );

    /* create the cap for managing thread domains */
    create_domain_cap(root_cnode_cap);

    /* create the IRQ CNode */
    if (!create_irq_cnode()) {
        return false;
    }

    /* initialise the IRQ states and provide the IRQ control cap */
    init_irqs(root_cnode_cap, node_id != 0);

    /* create the bootinfo frame */
    bi_frame_pptr = allocate_bi_frame(node_id, num_nodes, ipcbuf_vptr);
    if (!bi_frame_pptr) {
        return false;
    }

    /* Construct an initial address space with enough virtual addresses
     * to cover the user image + ipc buffer and bootinfo frames */
    it_vspace_cap = create_it_address_space(root_cnode_cap, it_v_reg);
    if (cap_get_capType(it_vspace_cap) == cap_null_cap) {
        return false;
    }

    /* Create and map bootinfo frame cap */
    create_bi_frame_cap(
        root_cnode_cap,
        it_vspace_cap,
        bi_frame_pptr,
        bi_frame_vptr
    );

    /* Create and map arch bootinfo frame cap */
    arch_bi_frame_pptr = create_arch_bi_frame_cap(
                             root_cnode_cap,
                             it_vspace_cap,
                             arch_bi_frame_vptr
                         );

    /* create the initial thread's IPC buffer */
    ipcbuf_cap = create_ipcbuf_frame(root_cnode_cap, it_vspace_cap, ipcbuf_vptr);
    if (cap_get_capType(ipcbuf_cap) == cap_null_cap) {
        return false;
    }

    /* create all userland image frames */
    create_frames_ret =
        create_frames_of_region(
            root_cnode_cap,
            it_vspace_cap,
            ui_reg,
            true,
            ui_info.pv_offset
        );
    if (!create_frames_ret.success) {
        return false;
    }
    ndks_boot.bi_frame->ui_frame_caps = create_frames_ret.region;

    /*
     * Initialise the NULL FPU state. This is different from merely zero'ing it
     * out (i.e., the NULL FPU state is non-zero), and must be performed before
     * the first thread is created.
     */
    resetFpu();
    saveFpuState(&ia32KSnullFpuState);
    ia32KSfpuOwner = ((void *)0);

    /* create the idle thread */
    if (!create_idle_thread()) {
        return false;
    }

    /* create the initial thread */
    if (!create_initial_thread(
                root_cnode_cap,
                it_vspace_cap,
                ui_info.v_entry,
                bi_frame_vptr,
                ipcbuf_vptr,
                ipcbuf_cap
            )) {
        return false;
    }


    /* initialise VTD-related data structures and the IOMMUs */
    if (!vtd_init(cpu_id, num_drhu, rmrr_list)) {
        return false;
    }

    /* write number of IOMMU PT levels into bootinfo */
    ndks_boot.bi_frame->num_iopt_levels = ia32KSnumIOPTLevels;

    /* write IOSpace master cap */
    if (ia32KSnumDrhu != 0) {
        write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (6 /* global IO space cap (null cap if no IOMMU support) */)), master_iospace_cap());
    }



    /* allow vtx to allocate any memory it may need before we give
       the rest away */
    if (!vtx_allocate()) {
        return false;
    }


    /* convert the remaining free memory into UT objects and provide the caps */
    if (!create_untypeds(root_cnode_cap, boot_mem_reuse_reg)) {
        return false;
    }
    /* WARNING: alloc_region() must not be called anymore after here! */

    /* create device frames */
    if (!create_device_untypeds(root_cnode_cap, dev_p_regs)) {
        return false;
    }

    /* create all shared frames */
    create_frames_ret =
        create_frames_of_region(
            root_cnode_cap,
            it_vspace_cap,
            sh_reg,
            false,
            0
        );
    if (!create_frames_ret.success) {
        return false;
    }
    ndks_boot.bi_frame->sh_frame_caps = create_frames_ret.region;;

    /* create ia32 specific bootinfo frame */
    create_ia32_bootinfo( (ia32_bootinfo_frame_t*)arch_bi_frame_pptr, vesa_info, mem_regions);

    /* finalise the bootinfo frame */
    bi_finalise();


    ia32KSconsolePort = console_port_of_node(node_id);
    ia32KSdebugPort = debug_port_of_node(node_id);


    ia32KSNodeID = node_id;
    ia32KSNumNodes = num_nodes;
    ia32KSCPUList = cpu_list;

    /* write IPI cap */
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (10 /* IPI cap */)), cap_ipi_cap_new());

    return true;
}

/* This function initialises the CPU. It does NOT initialise any kernel state. */

__attribute__((__section__(".boot.text"))) bool_t
init_node_cpu(
    uint32_t apic_khz,
    bool_t mask_legacy_irqs
)
{
    /* initialise CPU's descriptor table registers (GDTR, IDTR, LDTR, TR) */
    init_dtrs();

    /* initialise MSRs (needs an initialised TSS) */
    init_sysenter_msrs();

    /* setup additional PAT MSR */
    if (!init_pat_msr()) {
        return false;
    }

    /* initialise floating-point unit */
    Arch_initFpu();

    /* initialise local APIC */
    if (!apic_init(apic_khz, mask_legacy_irqs)) {
        return false;
    }


    /* initialise Intel VT-x extensions */
    vtx_enable();
# 669 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot.c"
    return true;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/apic.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/cmdline.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/cmdline.h" 2

typedef struct cmdline_opt {

    uint16_t console_port[1];
    uint16_t debug_port[1];


    bool_t disable_iommu;

    uint32_t max_num_nodes;
    uint32_t num_sh_frames;
} cmdline_opt_t;

void cmdline_parse(const char *cmdline, cmdline_opt_t* cmdline_opt);
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot_sys.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/elf.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/elf.h" 2

/* minimal ELF structures needed for loading GRUB boot module */

typedef struct Elf32_Header {
    unsigned char e_ident[16];
    uint16_t e_type; /* Relocatable=1, Executable=2 (+ some more ..) */
    uint16_t e_machine; /* Target architecture: MIPS=8 */
    uint32_t e_version; /* Elf version (should be 1) */
    uint32_t e_entry; /* Code entry point */
    uint32_t e_phoff; /* Program header table */
    uint32_t e_shoff; /* Section header table */
    uint32_t e_flags; /* Flags */
    uint16_t e_ehsize; /* ELF header size */
    uint16_t e_phentsize; /* Size of one program segment header */
    uint16_t e_phnum; /* Number of program segment headers */
    uint16_t e_shentsize; /* Size of one section header */
    uint16_t e_shnum; /* Number of section headers */
    uint16_t e_shstrndx; /* Section header index of the string table for section header names */
} Elf32_Header_t;

typedef struct Elf32_Phdr {
    uint32_t p_type; /* Segment type: Loadable segment = 1 */
    uint32_t p_offset; /* Offset of segment in file */
    uint32_t p_vaddr; /* Reqd virtual address of segment when loading */
    uint32_t p_paddr; /* Reqd physical address of segment (ignore) */
    uint32_t p_filesz; /* How many bytes this segment occupies in file */
    uint32_t p_memsz; /* How many bytes this segment should occupy in memory */
    uint32_t p_flags; /* Flags: logical "or" of PF_ constants below */
    uint32_t p_align; /* Reqd alignment of segment in memory */
} Elf32_Phdr_t;

/* minimal ELF functionality for loading GRUB boot module */

bool_t elf32_checkFile(Elf32_Header_t* elfFile);
v_region_t elf32_getMemoryBounds(Elf32_Header_t* elfFile);
void elf32_load(Elf32_Header_t* elfFile, int32_t offset);
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/acpi.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/devices.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/pic.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/pic.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/pic.h" 2

/* Even if not using the PIC as the main interrupt controller we still
 * need to interact with it to remap and disable it */
void pic_remap_irqs(interrupt_t vector);
void pic_disable(void);



void pic_mask_irq(bool_t mask, irq_t irq);
bool_t pic_is_irq_pending(void);
void pic_ack_active_irq(void);
# 25 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/ioapic.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 26 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c" 2

/* addresses defined in linker script */
/* need a fake array to get the pointer from the linker script */

/* start/end of CPU boot code */
extern char _boot_cpu_start[1];
extern char _boot_cpu_end[1];

/* start/end of boot stack */
extern char _boot_stack_bottom[1];
extern char _boot_stack_top[1];

/* locations in kernel image */
extern char ki_boot_end[1];
extern char ki_end[1];


/* start/end of .ndks section */
extern char _ndks_start[1];
extern char _ndks_end[1];

/* start/end of kernel stack */
extern char _kernel_stack_bottom[1];
extern char _kernel_stack_top[1];

/* kernel entry point */
extern char _start[1];


/* constants */




typedef int __assert_failed_align_ndks_size[((!((0x3000) & ((1ul<<(IA32_4K_bits))-1ul)))) ? 1 : -1];
typedef int __assert_failed_max_ndks_size[(0x3000 <= 0xffff0000 - ((-(1ul<<(IA32_4M_bits))) + 0x1000)) ? 1 : -1];

/* type definitions (directly corresponding to abstract specification) */

typedef struct glks {
    p_region_t avail_p_reg; /* region of available physical memory on platform */
    p_region_t ki_p_reg; /* region where the kernel image is in */
    p_region_t sh_p_reg; /* region shared between nodes */
    uint32_t num_nodes; /* number of nodes */
    cpu_id_t cpu_list [1]; /* CPUs assigned to nodes */
    ui_info_t ui_info_list [1]; /* info about userland images */
    dev_p_regs_t dev_p_regs; /* device memory regions */
    uint32_t apic_khz; /* frequency of APIC/bus */
    uint32_t num_ioapic; /* number of IOAPICs detected */
    paddr_t ioapic_paddr[1];
    vesa_info_t vesa_info; /* vesa information given by multiboot */
    ia32_mem_region_t mem_regions[10]; /* memory regions as given by multiboot */

    uint32_t num_drhu; /* number of IOMMUs */
    paddr_t drhu_list[((-(0xffff0000 + (1ul<<(IA32_4K_bits)))) >> IA32_4K_bits)]; /* list of physical addresses of the IOMMUs */
    acpi_rmrr_list_t rmrr_list;

} glks_t;

typedef char ndks_t[0x3000];

/* global variables (called var_glks, var_ndks_list in abstract specification) */

__attribute__((__section__(".boot.glob")))
glks_t glks;

__attribute__((__section__(".glob"))) __attribute__((__aligned__((1ul<<(IA32_4K_bits)))))
ndks_t ndks_list[1];

/* The kernel stack is actually allocated per-node as part of ndks_list, above.
 * The following definition, in conjunction with the linker script, tells the
 * linker to reserve space in virtual memory at the start of the NDKS section.
 */
__attribute__((__section__(".ndks.stack"))) __attribute__((__aligned__((1ul<<(IA32_4K_bits)))))
char kernel_stack_alloc[4096];

/* global variables (not covered by abstract specification) */

__attribute__((__section__(".boot.glob")))
cmdline_opt_t cmdline_opt;






/* In non PAE paging we define the pdpt to be the pd. This is just to
 * allow for there to be common boot code for paging structures on
 * both platforms. This common code detects if it is passed a pdpt
 * and pd at the same address, and ignores the pdpt if this happens
 */




/* the array type is explicit instead of pde_t due to a c-parser limitation */
__attribute__((__section__(".glob"))) __attribute__((__aligned__((1ul<<((10 + 2))))))
uint32_t kernel_pd_list[1][(1ul<<(10 + 0))];

/* the array type is explicit instead of pte_t due to a c-parser limitation */
__attribute__((__section__(".glob"))) __attribute__((__aligned__((1ul<<((10 + 2))))))
uint32_t kernel_pt_list[1][(1ul<<(10))];



/* Determine whether we are in bootstrapping phase or runtime phase.
 * Is currently only needed to determine console port in debug mode.
 */
bool_t
in_boot_phase()
{
    paddr_t esp = pptr_to_paddr(get_current_esp());

    return (esp <= 0x80000 ||
            (esp <= (paddr_t)_boot_stack_top && esp > (paddr_t)_boot_stack_bottom));
}

__attribute__((__section__(".boot.text"))) uint16_t
console_port_of_node(node_id_t node_id)
{
    return cmdline_opt.console_port[node_id];
}

__attribute__((__section__(".boot.text"))) uint16_t
debug_port_of_node(node_id_t node_id)
{
    return cmdline_opt.debug_port[node_id];
}


/* functions not modeled in abstract specification */

__attribute__((__section__(".boot.text"))) static paddr_t
load_boot_module(node_id_t node, multiboot_module_t* boot_module, paddr_t load_paddr)
{
    Elf32_Header_t* elf_file = (Elf32_Header_t*)boot_module->start;
    v_region_t v_reg;

    if (!elf32_checkFile(elf_file)) {
        kprintf("Boot module does not contain a valid ELF32 image\n");
        return 0;
    }

    v_reg = elf32_getMemoryBounds(elf_file);

    if (v_reg.end == 0) {
        kprintf("ELF32 image in boot module does not contain any segments\n");
        return 0;
    }
    v_reg.end = (((((v_reg.end) - 1ul) >> (IA32_4K_bits)) + 1ul) << (IA32_4K_bits));

    kprintf("size=0x%x v_entry=0x%x v_start=0x%x v_end=0x%x ", v_reg.end - v_reg.start, elf_file->e_entry, v_reg.start, v_reg.end)




           ;

    if (!(!((v_reg.start) & ((1ul<<(IA32_4K_bits))-1ul)))) {
        kprintf("Userland image virtual start address must be 4KB-aligned\n");
        return 0;
    }
    if (v_reg.end + 2 * (1ul<<(IA32_4K_bits)) > (0xe0000000 & (~((1ul<<(IA32_4M_bits))-1ul)))) {
        /* for IPC buffer frame and bootinfo frame, need 2*4K of additional userland virtual memory */
        kprintf("Userland image virtual end address too high\n");
        return 0;
    }
    if ((elf_file->e_entry < v_reg.start) || (elf_file->e_entry >= v_reg.end)) {
        kprintf("Userland image entry point does not lie within userland image\n");
        return 0;
    }

    /* fill ui_info struct */
    glks.ui_info_list[node].pv_offset = load_paddr - v_reg.start;
    glks.ui_info_list[node].p_reg.start = load_paddr;
    load_paddr += v_reg.end - v_reg.start;
    glks.ui_info_list[node].p_reg.end = load_paddr;
    glks.ui_info_list[node].v_entry = elf_file->e_entry;

    kprintf("p_start=0x%x p_end=0x%x\n", glks.ui_info_list[node].p_reg.start, glks.ui_info_list[node].p_reg.end)


           ;

    if (load_paddr > glks.avail_p_reg.end) {
        kprintf("End of loaded userland image lies outside of usable physical memory\n");
        return 0;
    }

    /* initialise all initial userland memory and load potentially sparse ELF image */
    memzero(
        (void*)glks.ui_info_list[node].p_reg.start,
        glks.ui_info_list[node].p_reg.end - glks.ui_info_list[node].p_reg.start
    );
    elf32_load(elf_file, glks.ui_info_list[node].pv_offset);

    return load_paddr;
}

__attribute__((__section__(".boot.text"))) void
insert_dev_p_reg(p_region_t reg)
{
    if (glks.dev_p_regs.count < sizeof(glks.dev_p_regs.list) / sizeof(glks.dev_p_regs.list[0])) {
        glks.dev_p_regs.list[glks.dev_p_regs.count] = reg;
        glks.dev_p_regs.count++;
        kprintf("\n");
    } else {
        kprintf(" -> IGNORED! (too many)\n");
    }
}

/* functions directly corresponding to abstract specification */

__attribute__((__section__(".boot.text"))) cpu_id_t
cur_cpu_id(void)
{
    cpu_id_t cpu_id;
    paddr_t esp = pptr_to_paddr(get_current_esp());

    if (esp <= (paddr_t)_boot_stack_top && esp > (paddr_t)_boot_stack_bottom) {
        cpu_id = glks.cpu_list[0];
    } else {
        cpu_id = esp >> 11;
    }

    return cpu_id;
}

__attribute__((__section__(".boot.text"))) node_id_t
node_of_cpu(cpu_id_t cpu_id)
{
    node_id_t i;

    for (i = 0; i < glks.num_nodes; i++) {
        if (glks.cpu_list[i] == cpu_id) {
            return i;
        }
    }
    /* Is it even possible for this to happen? */
    _fail("Couldn't find node of CPU", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c", 265, __func__);
}

/* split a region of physical memory into n mutually disjoint pieces */

__attribute__((__section__(".boot.text"))) static p_region_t
split_region(unsigned int i, unsigned int n, p_region_t reg)
{
    uint32_t offset;
    uint32_t total_frames = (reg.end - reg.start) >> IA32_4K_bits;
    uint32_t frames_div = total_frames / n;
    uint32_t frames_mod = total_frames % n;

    if (i < frames_mod) {
        offset = (i * (frames_div + 1)) << IA32_4K_bits;
        return (p_region_t) {
            .start = reg.start + offset,
             .end = reg.start + offset + ((frames_div + 1) << IA32_4K_bits)
        };
    } else {
        offset = (frames_mod * (frames_div + 1) + (i - frames_mod) * frames_div) << IA32_4K_bits;
        return (p_region_t) {
            .start = reg.start + offset,
             .end = reg.start + offset + (frames_div << IA32_4K_bits)
        };
    }
}

__attribute__((__section__(".boot.text"))) static bool_t
lift_ndks(node_id_t node_id)
{
    p_region_t ndks_p_reg;

    ndks_p_reg.start = pptr_to_paddr(ndks_list[node_id]);
    ndks_p_reg.end = ndks_p_reg.start + 0x3000;

    if (!map_kernel_window(
                (pdpte_t*)kernel_pd_list[node_id],
                (pde_t*)kernel_pd_list[node_id],
                (pte_t*)kernel_pt_list[node_id],
                ndks_p_reg





                , node_id == 0 ? glks.num_drhu : 0,
                glks.drhu_list

            )) {
        return false;
    }
    write_cr3(pptr_to_paddr(kernel_pd_list[node_id]));
    /* Sync up the compilers view of the world here to force the PD to actually
     * be set *right now* instead of delayed */
    __asm__ volatile("" ::: "memory");
    return true;
}

static __attribute__((__section__(".boot.text"))) bool_t
try_boot_node(void)
{
    p_region_t boot_mem_reuse_p_reg;

    cpu_id_t cpu_id = cur_cpu_id();
    node_id_t node_id = node_of_cpu(cpu_id);

    uint32_t num_nodes = glks.num_nodes;
    ui_info_t ui_info = glks.ui_info_list[node_id];
    dev_p_regs_t* dev_p_regs = &glks.dev_p_regs;

    /* calculate this node's available physical memory */
    p_region_t this_avail_p_reg = split_region(node_id, num_nodes, glks.avail_p_reg);

    /* if we only boot up one node, we can reuse boot code/data memory */
    if (num_nodes == 1) {
        boot_mem_reuse_p_reg.start = 0x00100000;
        boot_mem_reuse_p_reg.end = (paddr_t)ki_boot_end - (0xe0000000 - 0x00000000);
    } else {
        boot_mem_reuse_p_reg = (p_region_t){ .start = 0, .end = 0 };
    }

    /* map NDKS (node kernel state) into PD/PT and activate PD */
    if (!lift_ndks(node_id)) {
        return false;
    }

    /* initialise NDKS and kernel heap */
    if (!init_node_state(
                this_avail_p_reg,
                glks.sh_p_reg,
                dev_p_regs,
                ui_info,
                boot_mem_reuse_p_reg,
                node_id,
                num_nodes,
                glks.cpu_list,
                /* parameters below not modeled in abstract specification */
                (pdpte_t*)kernel_pd_list[node_id],
                (pde_t*)kernel_pd_list[node_id],
                (pte_t*)kernel_pt_list[node_id],
                &glks.vesa_info,
                glks.mem_regions

                , cpu_id,
                node_id == 0 ? glks.num_drhu : 0,
                glks.drhu_list,
                &glks.rmrr_list

            )) {
        return false;
    }

    /* initialise the CPU */
    if (!init_node_cpu(
                glks.apic_khz,



                node_id != 0

            )) {
        return false;
    }
    return true;
}

/* This is the entry function for SMP nodes. Node 0 calls
 * try_boot_node directly */
__attribute__((__section__(".boot.text"))) __attribute__((externally_visible)) void
boot_node(void)
{
    bool_t result;
    result = try_boot_node();
    if (!result) {
        _fail("Failed to start node :(\n", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c", 400, __func__);
    }
}

__attribute__((__section__(".boot.text"))) static void
start_cpu(cpu_id_t cpu_id, paddr_t boot_fun_paddr)
{
    /* memory fence needed before starting the other CPU */
    ia32_mfence();

    /* starting the other CPU */
    apic_send_init_ipi(cpu_id);
    apic_send_startup_ipi(cpu_id, boot_fun_paddr);
}

static __attribute__((__section__(".boot.text"))) bool_t
try_boot_sys(
    unsigned long multiboot_magic,
    multiboot_info_t* mbi,
    uint32_t apic_khz
)
{
    /* ==== following code corresponds to the "select" in abstract specification ==== */

    acpi_rsdt_t* acpi_rsdt; /* physical address of ACPI root */
    paddr_t mods_end_paddr; /* physical address where boot modules end */
    paddr_t load_paddr;
    unsigned int i;
    p_region_t ui_p_regs;
    multiboot_module_t *modules = (multiboot_module_t*)mbi->mod_list;

    glks.num_nodes = 1; /* needed to enable console output */

    if (multiboot_magic != 0x2BADB002) {
        kprintf("Boot loader not multiboot compliant\n");
        return false;
    }
    cmdline_parse((const char *)mbi->cmdline, &cmdline_opt);

    /* assert correct NDKS location and size */
    if(!((uint32_t)_ndks_start == ((-(1ul<<(IA32_4M_bits))) + 0x1000))) _assert_fail("(uint32_t)_ndks_start == PPTR_NDKS", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c", 440, __FUNCTION__);
    if(!(_ndks_end - _ndks_start <= 0x3000)) _assert_fail("_ndks_end - _ndks_start <= NDKS_SIZE", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c", 441, __FUNCTION__);

    if ((mbi->flags & (1ul<<(0))) == 0) {
        kprintf("Boot loader did not provide information about physical memory size\n");
        return false;
    }

    if(!(_boot_cpu_end - _boot_cpu_start < 0x400)) _assert_fail("_boot_cpu_end - _boot_cpu_start < 0x400", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c", 448, __FUNCTION__);
    if ((mbi->mem_lower << 10) < 0x80000 + 0x400) {
        kprintf("Need at least 513K of available lower physical memory\n");
        return false;
    }

    /* copy VESA information from multiboot header */
    if ((mbi->flags & (1ul<<(11))) == 0) {
        glks.vesa_info.vbe_mode = -1;
        kprintf("Multiboot gave us no video information :(\n");
    } else {
        glks.vesa_info.vbe_control_info = *mbi->vbe_control_info;
        glks.vesa_info.vbe_mode_info = *mbi->vbe_mode_info;
        glks.vesa_info.vbe_mode = mbi->vbe_mode;
        kprintf("Got VBE info in multiboot. Current video mode is %d\n", mbi->vbe_mode);
        glks.vesa_info.vbe_interface_seg = mbi->vbe_interface_seg;
        glks.vesa_info.vbe_interface_off = mbi->vbe_interface_off;
        glks.vesa_info.vbe_interface_len = mbi->vbe_interface_len;
    }
    /* copy memory map from multiboot header */
    if ((mbi->flags & (1ul<<(6))) != 0) {
        multiboot_memory_map_t *map = (multiboot_memory_map_t*)((uint32_t)mbi->mmap_addr);
        multiboot_memory_map_t *map_end = (multiboot_memory_map_t*)((uint32_t)mbi->mmap_addr + mbi->mmap_length);
        i = 0;
        while (map < map_end && i < 10) {
            if (map->type == 1) {
                /* We will freely describe memory in the kernel window and leave it up
                 * to userland to not use it. Also taunt the user with
                 * memory that is >4gb that they cannot yet use */
                glks.mem_regions[i].paddr = map->addr;
                glks.mem_regions[i].len = map->len;
                i++;
                kprintf("Found memory at 0x%x:0x%x - 0x%x:0x%x\n", (uint32_t)(map->addr >> 32), (uint32_t)map->addr, (uint32_t)( (map->addr + map->len) >> 32), (uint32_t)(map->addr + map->len));
            }
            /* The 'size' element in the multiboot struct is technically at offset -4 in the struct
             * so we need to add 4 here for everything to work. Please don't think on this too hard */
            map = (multiboot_memory_map_t*)((uint32_t)map + map->size + 4);
        }
        if (map < map_end) {
            kprintf("Found > %d memory regions. Consider increasing CONFIG_MAX_MEM_REGIONS\n", 10);
        }
    } else {
        kprintf("Multiboot gave us no memory map :(\n");
        i = 0;
    }
    while (i < 10) {
        glks.mem_regions[i].paddr = 0;
        glks.mem_regions[i].len = 0;
        i++;
    }

    /* copy CPU bootup code to lower memory */
    memcpy((void*)0x80000, _boot_cpu_start, _boot_cpu_end - _boot_cpu_start);

    kprintf("Physical high memory given to seL4: start=0x%x end=0x%x size=0x%x\n", 0x100000, mbi->mem_upper << 10, (mbi->mem_upper << 10) - 0x100000)


                                                            ;
    /* calculate available physical memory (above 1M) */
    glks.avail_p_reg.start = 0x100000;
    glks.avail_p_reg.end = (((glks.avail_p_reg.start + (mbi->mem_upper << 10)) >> (IA32_4K_bits)) << (IA32_4K_bits));
    if (glks.avail_p_reg.end > ((-(1ul<<(IA32_4M_bits))) - (0xe0000000 - 0x00000000))) {
        glks.avail_p_reg.end = ((-(1ul<<(IA32_4M_bits))) - (0xe0000000 - 0x00000000));
    }

    kprintf("Physical memory usable by seL4 (kernel): start=0x%x end=0x%x size=0x%x\n", glks.avail_p_reg.start, glks.avail_p_reg.end, glks.avail_p_reg.end - glks.avail_p_reg.start)



           ;

    glks.ki_p_reg.start = 0x00100000;
    glks.ki_p_reg.end = pptr_to_paddr(ki_end);

    kprintf("Kernel loaded to: start=0x%x end=0x%x size=0x%x entry=0x%x\n", glks.ki_p_reg.start, glks.ki_p_reg.end, glks.ki_p_reg.end - glks.ki_p_reg.start, (paddr_t)_start)




           ;
    kprintf("Kernel stack size: 0x%x\n", _kernel_stack_top - _kernel_stack_bottom);

    glks.apic_khz = apic_khz;
    kprintf("APIC: Bus frequency is %d MHz\n", glks.apic_khz / 1000);

    /* remapping legacy IRQs to their correct vectors */
    pic_remap_irqs(0x20);






    /* Prepare for accepting device regions from here on */
    glks.dev_p_regs.count = 0;

    /* get ACPI root table */
    acpi_rsdt = acpi_init();
    if (!acpi_rsdt) {
        return false;
    }


    if (cmdline_opt.disable_iommu) {
        glks.num_drhu = 0;
    } else {
        /* query available IOMMUs from ACPI */
        acpi_dmar_scan(
            acpi_rsdt,
            glks.drhu_list,
            &glks.num_drhu,
            ((-(0xffff0000 + (1ul<<(IA32_4K_bits)))) >> IA32_4K_bits),
            &glks.rmrr_list
        );
    }


    /* query available CPUs from ACPI */
    glks.num_nodes = acpi_madt_scan(acpi_rsdt, glks.cpu_list, 1, &glks.num_ioapic, glks.ioapic_paddr);
    if (glks.num_nodes == 0) {
        kprintf("No CPUs detected\n");
        return false;
    }






    if (glks.num_ioapic > 0) {
        kprintf("Detected %d IOAPICs, but configured to use PIC instead\n", glks.num_ioapic);
    }


    if (glks.num_nodes > cmdline_opt.max_num_nodes) {
        glks.num_nodes = cmdline_opt.max_num_nodes;
    }
    kprintf("Will boot up %d seL4 node(s)\n", glks.num_nodes);

    if (!(mbi->flags & (1ul<<(3)))) {
        kprintf("Boot loader did not provide information about boot modules\n");
        return false;
    }

    kprintf("Detected %d boot module(s):\n", mbi->mod_count);
    mods_end_paddr = 0;

    for (i = 0; i < mbi->mod_count; i++) {
        kprintf("  module #%d: start=0x%x end=0x%x size=0x%x name='%s'\n", i, modules[i].start, modules[i].end, modules[i].end - modules[i].start, modules[i].name)






         ;
        if ((int32_t)(modules[i].end - modules[i].start) <= 0) {
            kprintf("Invalid boot module size! Possible cause: boot module file not found by QEMU\n");
            return false;
        }
        if (mods_end_paddr < modules[i].end) {
            mods_end_paddr = modules[i].end;
        }
    }
    mods_end_paddr = (((((mods_end_paddr) - 1ul) >> (IA32_4K_bits)) + 1ul) << (IA32_4K_bits));
    if(!(mods_end_paddr > glks.ki_p_reg.end)) _assert_fail("mods_end_paddr > glks.ki_p_reg.end", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c", 613, __FUNCTION__);

    if (mbi->mod_count < 1) {
        kprintf("Expect at least one boot module (containing a userland image)\n");
        return false;
    }

    kprintf("ELF-loading userland images from boot modules:\n");
    load_paddr = mods_end_paddr;

    for (i = 0; i < mbi->mod_count && i < glks.num_nodes; i++) {
        kprintf("  module #%d for node #%d: ", i, i);
        load_paddr = load_boot_module(i, modules + i, load_paddr);
        if (!load_paddr) {
            return false;
        }
    }

    for (i = mbi->mod_count; i < glks.num_nodes; i++) {
        kprintf("  module #%d for node #%d: ", mbi->mod_count - 1, i);
        load_paddr = load_boot_module(i, modules + mbi->mod_count - 1, load_paddr);
        if (!load_paddr) {
            return false;
        }
    }

    /* calculate final location of userland images */
    ui_p_regs.start = glks.ki_p_reg.end;
    ui_p_regs.end = ui_p_regs.start + load_paddr - mods_end_paddr;

    kprintf("Moving loaded userland images to final location: from=0x%x to=0x%x size=0x%x\n", mods_end_paddr, ui_p_regs.start, ui_p_regs.end - ui_p_regs.start)




     ;
    memcpy((void*)ui_p_regs.start, (void*)mods_end_paddr, ui_p_regs.end - ui_p_regs.start);

    for (i = 0; i < glks.num_nodes; i++) {
        /* adjust p_reg and pv_offset to final load address */
        glks.ui_info_list[i].p_reg.start -= mods_end_paddr - ui_p_regs.start;
        glks.ui_info_list[i].p_reg.end -= mods_end_paddr - ui_p_regs.start;
        glks.ui_info_list[i].pv_offset -= mods_end_paddr - ui_p_regs.start;
    }

    /* ==== following code corresponds to abstract specification after "select" ==== */

    /* exclude kernel image from available memory */
    if(!(glks.avail_p_reg.start == glks.ki_p_reg.start)) _assert_fail("glks.avail_p_reg.start == glks.ki_p_reg.start", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c", 661, __FUNCTION__);
    glks.avail_p_reg.start = glks.ki_p_reg.end;

    /* exclude userland images from available memory */
    if(!(glks.avail_p_reg.start == ui_p_regs.start)) _assert_fail("glks.avail_p_reg.start == ui_p_regs.start", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c", 665, __FUNCTION__);
    glks.avail_p_reg.start = ui_p_regs.end;

    /* choose shared memory */
    glks.sh_p_reg.start = glks.avail_p_reg.start;
    glks.sh_p_reg.end = glks.sh_p_reg.start + (cmdline_opt.num_sh_frames << IA32_4K_bits);
    if (glks.sh_p_reg.end > glks.avail_p_reg.end || glks.sh_p_reg.end < glks.sh_p_reg.start) {
        kprintf("Not enough usable physical memory to allocate shared region\n");
        return false;
    }

    /* exclude shared region from available memory */
    if(!(glks.avail_p_reg.start == glks.sh_p_reg.start)) _assert_fail("glks.avail_p_reg.start == glks.sh_p_reg.start", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c", 677, __FUNCTION__);
    glks.avail_p_reg.start = glks.sh_p_reg.end;

    /* Add in all the memory except for the kernel window as device memory.
     * This is UNSAFE as we are giving user level access to regions of memory,
     * such as the APIC, that it realy should not be able to use. This needs to
     * be fixed by blacklisting regions.
     * We also need to make sure we do not use the address that will get translated
     * to the NULL pptr, or that will be considered a NULL physical address */
    insert_dev_p_reg( (p_region_t) {
        .start = 0x1000, .end = 0x100000
    } );
    insert_dev_p_reg( (p_region_t) {
        .start = glks.avail_p_reg.end, .end = pptr_to_paddr(0)
    });
    /* Specifying zero here for the .end really is correct */
    insert_dev_p_reg( (p_region_t) {
        .start = pptr_to_paddr(0) + 0x1000, .end = 0
    });

    kprintf("Starting node #0\n");
    if (!try_boot_node()) {
        return false;
    }






    /* start up other CPUs and initialise their nodes */
    for (i = 1; i < glks.num_nodes; i++) {
        kprintf("Starting node #%d\n", i);
        start_cpu(glks.cpu_list[i], 0x80000);
    }
    return true;
}

__attribute__((__section__(".boot.text"))) __attribute__((externally_visible)) void
boot_sys(
    unsigned long multiboot_magic,
    multiboot_info_t* mbi,
    uint32_t apic_khz)
{
    bool_t result;
    result = try_boot_sys(multiboot_magic, mbi, apic_khz);

    if (!result) {
        _fail("boot_sys failed for some reason :(\n", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/boot_sys.c", 725, __func__);
    }
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/cmdline.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/cmdline.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/cmdline.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/cmdline.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/cmdline.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/cmdline.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot_sys.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/cmdline.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/cmdline.c" 2

/* 'cmdline_val' is declared globally because of a C-subset restriction.
 * It is only used in cmdline_parse(), which therefore is non-reentrant.
 */

__attribute__((__section__(".boot.glob")))
char cmdline_val[1000];

/* workaround because string literals are not supported by C parser */
const char cmdline_str_max_num_nodes[] = {'m', 'a', 'x', '_', 'n', 'u', 'm', '_', 'n', 'o', 'd', 'e', 's', 0};
const char cmdline_str_num_sh_frames[] = {'n', 'u', 'm', '_', 's', 'h', '_', 'f', 'r', 'a', 'm', 'e', 's', 0};
const char cmdline_str_disable_iommu[] = {'d', 'i', 's', 'a', 'b', 'l', 'e', '_', 'i', 'o', 'm', 'm', 'u', 0};

static int is_space(char c)
{
    return c <= ' ';
}

static int parse_opt(const char *cmdline, const char *opt, char *value, int bufsize)
{
    int len = -1;
    const char *optptr = ((void *)0);

    while (true) {
        for (; is_space(*cmdline) && (*cmdline != 0); cmdline++);
        if (*cmdline == 0) {
            break;
        }

        for (optptr = opt; *optptr && *cmdline && (*cmdline != '=') && !is_space(*cmdline) && (*optptr == *cmdline); optptr++, cmdline++);

        if (*optptr == '\0' && *cmdline == '=') {
            cmdline++;

            for (len = 0; !is_space(*cmdline) && (len < bufsize - 1); cmdline++, len++) {
                value[len] = *cmdline;
            }
            if (bufsize) {
                value[len] = '\0';
            }
        }
        for (; !is_space(*cmdline); cmdline++);
    }

    return len;
}


static int parse_bool(const char *cmdline, const char *opt)
{
    const char *optptr = ((void *)0);

    while (1) {
        for (; is_space(*cmdline) && (*cmdline != 0); cmdline++);
        if (*cmdline == 0) {
            return 0;
        }

        for (optptr = opt; *optptr && *cmdline && !is_space(*cmdline) && (*optptr == *cmdline); optptr++, cmdline++);

        if (*optptr == '\0' && is_space(*cmdline)) {
            return 1;
        } else {
            for (; !is_space(*cmdline); cmdline++);
        }
    }
}



static void parse_uint16_array(char* str, uint16_t* array, int array_size)
{
    char* last;
    int i = 0;
    int v;

    while (str && i < array_size) {
        for (last = str; *str && *str != ','; str++);
        if (*str == 0) {
            str = 0;
        } else {
            *str = 0;
            str++;
        }
        v = str_to_int(last);
        if (v == -1) {
            array[i] = 0;
        } else {
            array[i] = v;
        }
        i++;
    }
}


void cmdline_parse(const char *cmdline, cmdline_opt_t* cmdline_opt)
{
    int i;


    /* initialise to default */
    for (i = 0; i < 1; i++) {
        cmdline_opt->console_port[i] = 0;
        cmdline_opt->debug_port[i] = 0;
    }
    cmdline_opt->console_port[0] = 0x3f8;
    cmdline_opt->debug_port[0] = 0x3f8;

    if (parse_opt(cmdline, "console_port", cmdline_val, 1000) != -1) {
        parse_uint16_array(cmdline_val, cmdline_opt->console_port, 1);
    }

    /* initialise console ports to enable debug output */
    for (i = 0; i < 1; i++) {
        if (cmdline_opt->console_port[i]) {
            serial_init(cmdline_opt->console_port[i]);
        }
    }

    /* only start printing here after having parsed/set/initialised the console_port */
    kprintf("\nBoot config: parsing cmdline '%s'\n", cmdline);

    for (i = 0; i < 1; i++)
        if (cmdline_opt->console_port[i]) {
            kprintf("Boot config: console_port of node #%d = 0x%x\n", i, cmdline_opt->console_port[i]);
        }

    if (parse_opt(cmdline, "debug_port", cmdline_val, 1000) != -1) {
        parse_uint16_array(cmdline_val, cmdline_opt->debug_port, 1);
    }

    /* initialise debug ports */
    for (i = 0; i < 1; i++) {
        if (cmdline_opt->debug_port[i]) {
            serial_init(cmdline_opt->debug_port[i]);
            kprintf("Boot config: debug_port of node #%d = 0x%x\n", i, cmdline_opt->debug_port[i]);
        }
    }



    cmdline_opt->disable_iommu = parse_bool(cmdline, cmdline_str_disable_iommu);
    kprintf("Boot config: disable_iommu = %s\n", cmdline_opt->disable_iommu ? "true" : "false");


    /* parse max_num_nodes option */
    cmdline_opt->max_num_nodes = 1; /* default */
    if (parse_opt(cmdline, cmdline_str_max_num_nodes, cmdline_val, 1000) != -1) {
        i = str_to_int(cmdline_val);
        if (i > 0 && i <= 1) {
            cmdline_opt->max_num_nodes = i;
        }
    }
    kprintf("Boot config: max_num_nodes = %d\n", cmdline_opt->max_num_nodes);

    /* parse num_sh_frames option */
    cmdline_opt->num_sh_frames = 0; /* default */
    if (parse_opt(cmdline, cmdline_str_num_sh_frames, cmdline_val, 1000) != -1) {
        i = str_to_int(cmdline_val);
        if (i >= 0 && i < (1ul<<(32 - IA32_4K_bits))) {
            cmdline_opt->num_sh_frames = i;
        }
    }
    kprintf("Boot config: num_sh_frames = 0x%x\n", cmdline_opt->num_sh_frames);
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/elf.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/elf.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/elf.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/elf.c" 2

/* minimal ELF functionality for loading GRUB boot module */

__attribute__((__section__(".boot.text"))) bool_t
elf32_checkFile(Elf32_Header_t* elfFile)
{
    return (
               elfFile->e_ident[0] == '\177' &&
               elfFile->e_ident[1] == 'E' &&
               elfFile->e_ident[2] == 'L' &&
               elfFile->e_ident[3] == 'F' &&
               elfFile->e_ident[4] == 1
           );
}

__attribute__((__section__(".boot.text"))) v_region_t
elf32_getMemoryBounds(Elf32_Header_t* elfFile)
{
    Elf32_Phdr_t* phdr = (Elf32_Phdr_t*)((paddr_t)elfFile + elfFile->e_phoff);
    v_region_t elf_reg;
    vptr_t sect_start;
    vptr_t sect_end;
    uint32_t i;

    elf_reg.start = 0xffffffff;
    elf_reg.end = 0;

    /* loop through all program headers (segments) and record start/end address */
    for (i = 0; i < elfFile->e_phnum; i++) {
        if (phdr[i].p_memsz > 0) {
            sect_start = phdr[i].p_vaddr;
            sect_end = sect_start + phdr[i].p_memsz;
            if (sect_start < elf_reg.start) {
                elf_reg.start = sect_start;
            }
            if (sect_end > elf_reg.end) {
                elf_reg.end = sect_end;
            }
        }
    }

    return elf_reg;
}

__attribute__((__section__(".boot.text"))) void
elf32_load(Elf32_Header_t* elfFile, int32_t offset)
{
    Elf32_Phdr_t* phdr = (Elf32_Phdr_t*)((paddr_t)elfFile + elfFile->e_phoff);
    paddr_t src;
    paddr_t dst;
    uint32_t len;
    uint32_t i;

    /* loop through all program headers (segments) and load them */
    for (i = 0; i < elfFile->e_phnum; i++) {
        src = (paddr_t)elfFile + phdr[i].p_offset;
        dst = phdr[i].p_vaddr + offset;
        len = phdr[i].p_filesz;
        memcpy((void*)dst, (char*)src, len);
        dst += len;
        memset((void*)dst, 0, phdr[i].p_memsz - len);
    }
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/lock.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/lock.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/lock.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/lock.c" 2

/* global spinlocks */
lock_t lock_debug __attribute__((__section__(".glob")));
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/thread.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/thread.c" 2

void
Arch_switchToThread(tcb_t* tcb)
{
    word_t base;

    /* set PD */
    setVMRoot(tcb);

    /* update the GDT_TLS entry with the thread's TLS_BASE address */
    base = getRegister(tcb, TLS_BASE);
    gdt_entry_gdt_data_ptr_set_base_low(ia32KSgdt + 6, base);
    gdt_entry_gdt_data_ptr_set_base_mid(ia32KSgdt + 6, (base >> 16) & 0xFF);
    gdt_entry_gdt_data_ptr_set_base_high(ia32KSgdt + 6, (base >> 24) & 0xFF);

    /* update the GDT_IPCBUF entry with the thread's IPC buffer address */
    base = tcb->tcbIPCBuffer;
    gdt_entry_gdt_data_ptr_set_base_low(ia32KSgdt + 7, base);
    gdt_entry_gdt_data_ptr_set_base_mid(ia32KSgdt + 7, (base >> 16) & 0xFF);
    gdt_entry_gdt_data_ptr_set_base_high(ia32KSgdt + 7, (base >> 24) & 0xFF);
}

__attribute__((__section__(".boot.text"))) void
Arch_configureIdleThread(tcb_t* tcb)
{
    setRegister(tcb, EFLAGS, (1ul<<(9)) | (1ul<<(1))); /* enable interrupts and set bit 1 which is always 1 */
    setRegister(tcb, NextEIP, (uint32_t)(&idle_thread));
    setRegister(tcb, CS, (1 << 3));
    setRegister(tcb, DS, (2 << 3));
    setRegister(tcb, ES, (2 << 3));
    setRegister(tcb, FS, (2 << 3));
    setRegister(tcb, GS, (2 << 3));
    setRegister(tcb, SS, (2 << 3));
}

void
Arch_switchToIdleThread(void)
{
    /* Don't need to do anything */
}

void __attribute__((__const__))
Arch_activateIdleThread(tcb_t* tcb)
{
    /* Don't need to do anything */
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cdt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cdt.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cdt.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cdt.h" 2

void cdtInsert(cte_t *parentSlot, cte_t *newSlot);
void cdtRemove(cte_t *slot);
cte_t *cdtFindChild(cte_t *parentSlot);
void cdtMove(cte_t *oldSlot, cte_t *newSlot);
void cdtSwap(cap_t cap1, cte_t *slot1, cap_t cap2, cte_t *slot2);
bool_t cdtIsFinal(cte_t *slot);
void cdtUpdate(cte_t *slot, cap_t newCap);
cte_t *cdtFind(cap_t hypothetical);
cte_t *cdtFindAtDepth(cap_t hypothetical, uint32_t depth);
cte_t *cdtFindWithExtra(cap_t hypothetical);
cte_t *cdtFindTypedInRange(word_t base, unsigned int size_bits);
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c" 2
# 1 "./arch/api/invocation.h" 1
/* @LICENSE(OKL_CORE) */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */


# 1 "./api/invocation.h" 1
/* @LICENSE(OKL_CORE) */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */



enum invocation_label {
    InvalidInvocation,
    UntypedRetype,
    TCBReadRegisters,
    TCBWriteRegisters,
    TCBCopyRegisters,
    TCBConfigure,
    TCBSetPriority,
    TCBSetIPCBuffer,
    TCBSetSpace,
    TCBSuspend,
    TCBResume,
    TCBBindAEP,
    TCBUnbindAEP,
    TCBSetEPTRoot,
    CNodeRevoke,
    CNodeDelete,
    CNodeRecycle,
    CNodeCopy,
    CNodeMint,
    CNodeMove,
    CNodeMutate,
    CNodeRotate,
    CNodeSaveCaller,
    IRQIssueIRQHandler,
    IRQInterruptControl,
    IRQAckIRQ,
    IRQSetIRQHandler,
    IRQClearIRQHandler,
    IRQSetMode,
    DomainSetSet,
    nInvocationLabels
};
# 11 "./arch/api/invocation.h" 2

enum arch_invocation_label {
    IA32PageDirectoryMap = nInvocationLabels + 0,
    IA32PageDirectoryUnmap = nInvocationLabels + 1,
    IA32PageTableMap = nInvocationLabels + 2,
    IA32PageTableUnmap = nInvocationLabels + 3,
    IA32IOPageTableMap = nInvocationLabels + 4,
    IA32IOPageTableUnmap = nInvocationLabels + 5,
    IA32PageMap = nInvocationLabels + 6,
    IA32PageUnmap = nInvocationLabels + 7,
    IA32PageMapIO = nInvocationLabels + 8,
    IA32PageGetAddress = nInvocationLabels + 9,
    IA32IOPortIn8 = nInvocationLabels + 10,
    IA32IOPortIn16 = nInvocationLabels + 11,
    IA32IOPortIn32 = nInvocationLabels + 12,
    IA32IOPortOut8 = nInvocationLabels + 13,
    IA32IOPortOut16 = nInvocationLabels + 14,
    IA32IOPortOut32 = nInvocationLabels + 15,
    IA32VCPUSetTCB = nInvocationLabels + 16,
    IA32VCPUReadVMCS = nInvocationLabels + 17,
    IA32VCPUWriteVMCS = nInvocationLabels + 18,
    IA32VCPUSetIOPort = nInvocationLabels + 19,
    IA32VCPUSetIOPortMask = nInvocationLabels + 20,
    IA32VCPUWriteRegisters = nInvocationLabels + 21,
    IA32EPTPageDirectoryMap = nInvocationLabels + 22,
    IA32EPTPageDirectoryUnmap = nInvocationLabels + 23,
    IA32EPTPageTableMap = nInvocationLabels + 24,
    IA32EPTPageTableUnmap = nInvocationLabels + 25,
    IA32IPISend = nInvocationLabels + 26,
    nArchInvocationLabels
};
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c" 2


# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/vtx.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c" 2

static exception_t decodeIA32EPTFrameMap(cap_t pdptCap, cte_t *cte, cap_t cap, vm_rights_t vmRights, vm_attributes_t vmAttr, word_t vaddr);



struct lookupPTSlot_ret {
    exception_t status;
    pte_t* ptSlot;
    pte_t* pt;
    unsigned int ptIndex;
};
typedef struct lookupPTSlot_ret lookupPTSlot_ret_t;

/* 'gdt_idt_ptr' is declared globally because of a C-subset restriction.
 * It is only used in init_drts(), which therefore is non-reentrant.
 */
gdt_idt_ptr_t gdt_idt_ptr;

/* initialise the Task State Segment (TSS) */

__attribute__((__section__(".boot.text"))) static void
init_tss(tss_t* tss)
{
    tss_ptr_new(
        tss,
        0, /* io_map_base  */
        0, /* trap         */
        0, /* sel_ldt      */
        0, /* gs           */
        0, /* fs           */
        0, /* ds           */
        0, /* ss           */
        0, /* cs           */
        0, /* es           */
        0, /* edi          */
        0, /* esi          */
        0, /* ebp          */
        0, /* esp          */
        0, /* ebx          */
        0, /* edx          */
        0, /* ecx          */
        0, /* eax          */
        0, /* eflags       */
        0, /* eip          */
        0, /* cr3          */
        0, /* ss2          */
        0, /* esp2         */
        0, /* ss1          */
        0, /* esp1         */
        (2 << 3), /* ss0          */
        0, /* esp0         */
        0 /* prev_task    */
    );
}
/* initialise Global Descriptor Table (GDT) */

__attribute__((__section__(".boot.text"))) static void
init_gdt(gdt_entry_t* gdt, tss_t* tss)
{
    uint32_t tss_addr = (uint32_t)tss;

    /* Set the NULL descriptor */
    gdt[0] = gdt_entry_gdt_null_new();

    /* 4GB flat kernel code segment on ring 0 descriptor */
    gdt[1] = gdt_entry_gdt_code_new(
                        0, /* Base high 8 bits             */
                        1, /* Granularity                  */
                        1, /* Operation size               */
                        0, /* Available                    */
                        0xf, /* Segment limit high 4 bits    */
                        1, /* Present                      */
                        0, /* Descriptor privilege level   */
                        1, /* readable                     */
                        1, /* accessed                     */
                        0, /* Base middle 8 bits           */
                        0, /* Base low 16 bits             */
                        0xffff /* Segment limit low 16 bits    */
                    );

    /* 4GB flat kernel data segment on ring 0 descriptor */
    gdt[2] = gdt_entry_gdt_data_new(
                        0, /* Base high 8 bits             */
                        1, /* Granularity                  */
                        1, /* Operation size               */
                        0, /* Available                    */
                        0xf, /* Segment limit high 4 bits    */
                        1, /* Present                      */
                        0, /* Descriptor privilege level   */
                        1, /* writable                     */
                        1, /* accessed                     */
                        0, /* Base middle 8 bits           */
                        0, /* Base low 16 bits             */
                        0xffff /* Segment limit low 16 bits    */
                    );

    /* 4GB flat userland code segment on ring 3 descriptor */
    gdt[3] = gdt_entry_gdt_code_new(
                        0, /* Base high 8 bits             */
                        1, /* Granularity                  */
                        1, /* Operation size               */
                        0, /* Available                    */
                        0xf, /* Segment limit high 4 bits    */
                        1, /* Present                      */
                        3, /* Descriptor privilege level   */
                        1, /* readable                     */
                        1, /* accessed                     */
                        0, /* Base middle 8 bits           */
                        0, /* Base low 16 bits             */
                        0xffff /* Segment limit low 16 bits    */
                    );

    /* 4GB flat userland data segment on ring 3 descriptor */
    gdt[4] = gdt_entry_gdt_data_new(
                        0, /* Base high 8 bits             */
                        1, /* Granularity                  */
                        1, /* Operation size               */
                        0, /* Available                    */
                        0xf, /* Segment limit high 4 bits    */
                        1, /* Present                      */
                        3, /* Descriptor privilege level   */
                        1, /* writable                     */
                        1, /* accessed                     */
                        0, /* Base middle 8 bits           */
                        0, /* Base low 16 bits             */
                        0xffff /* Segment limit low 16 bits    */
                    );

    /* Task State Segment (TSS) descriptor */
    gdt[5] = gdt_entry_gdt_tss_new(
                       tss_addr >> 24, /* base_high 8 bits     */
                       0, /* granularity          */
                       0, /* avl                  */
                       0, /* limit_high 4 bits    */
                       1, /* present              */
                       0, /* dpl                  */
                       0, /* busy                 */
                       1, /* always_true          */
                       (tss_addr >> 16) & 0xff, /* base_mid 8 bits      */
                       (tss_addr & 0xffff), /* base_low 16 bits     */
                       sizeof(tss_t) - 1 /* limit_low 16 bits    */
                   );

    /* pre-init the userland data segment used for TLS */
    gdt[6] = gdt_entry_gdt_data_new(
                       0, /* Base high 8 bits             */
                       1, /* Granularity                  */
                       1, /* Operation size               */
                       0, /* Available                    */
                       0xf, /* Segment limit high 4 bits    */
                       1, /* Present                      */
                       3, /* Descriptor privilege level   */
                       1, /* writable                     */
                       1, /* accessed                     */
                       0, /* Base middle 8 bits           */
                       0, /* Base low 16 bits             */
                       0xffff /* Segment limit low 16 bits    */
                   );

    /* pre-init the userland data segment used for the IPC buffer */
    gdt[7] = gdt_entry_gdt_data_new(
                          0, /* Base high 8 bits             */
                          1, /* Granularity                  */
                          1, /* Operation size               */
                          0, /* Available                    */
                          0xf, /* Segment limit high 4 bits    */
                          1, /* Present                      */
                          3, /* Descriptor privilege level   */
                          1, /* writable                     */
                          1, /* accessed                     */
                          0, /* Base middle 8 bits           */
                          0, /* Base low 16 bits             */
                          0xffff /* Segment limit low 16 bits    */
                      );
}

/* initialise the Interrupt Descriptor Table (IDT) */

__attribute__((__section__(".boot.text"))) static void
init_idt_entry(idt_entry_t* idt, interrupt_t interrupt, void(*handler)(void))
{
    uint32_t handler_addr = (uint32_t)handler;
    uint32_t dpl = 3;

    if (interrupt < int_trap_min) {
        dpl = 0;
    }

    idt[interrupt] = idt_entry_interrupt_gate_new(
                         handler_addr >> 16, /* offset_high  */
                         1, /* present      */
                         dpl, /* dpl          */
                         1, /* gate_size    */
                         (1 << 3), /* seg_selector */
                         handler_addr & 0xffff /* offset_low   */
                     );
}

__attribute__((__section__(".boot.text"))) static void
init_idt(idt_entry_t* idt)
{
    init_idt_entry(idt, 0x00, int_00);
    init_idt_entry(idt, 0x01, int_01);
    init_idt_entry(idt, 0x02, int_02);
    init_idt_entry(idt, 0x03, int_03);
    init_idt_entry(idt, 0x04, int_04);
    init_idt_entry(idt, 0x05, int_05);
    init_idt_entry(idt, 0x06, int_06);
    init_idt_entry(idt, 0x07, int_07);
    init_idt_entry(idt, 0x08, int_08);
    init_idt_entry(idt, 0x09, int_09);
    init_idt_entry(idt, 0x0a, int_0a);
    init_idt_entry(idt, 0x0b, int_0b);
    init_idt_entry(idt, 0x0c, int_0c);
    init_idt_entry(idt, 0x0d, int_0d);
    init_idt_entry(idt, 0x0e, int_0e);
    init_idt_entry(idt, 0x0f, int_0f);

    init_idt_entry(idt, 0x10, int_10);
    init_idt_entry(idt, 0x11, int_11);
    init_idt_entry(idt, 0x12, int_12);
    init_idt_entry(idt, 0x13, int_13);
    init_idt_entry(idt, 0x14, int_14);
    init_idt_entry(idt, 0x15, int_15);
    init_idt_entry(idt, 0x16, int_16);
    init_idt_entry(idt, 0x17, int_17);
    init_idt_entry(idt, 0x18, int_18);
    init_idt_entry(idt, 0x19, int_19);
    init_idt_entry(idt, 0x1a, int_1a);
    init_idt_entry(idt, 0x1b, int_1b);
    init_idt_entry(idt, 0x1c, int_1c);
    init_idt_entry(idt, 0x1d, int_1d);
    init_idt_entry(idt, 0x1e, int_1e);
    init_idt_entry(idt, 0x1f, int_1f);

    init_idt_entry(idt, 0x20, int_20);
    init_idt_entry(idt, 0x21, int_21);
    init_idt_entry(idt, 0x22, int_22);
    init_idt_entry(idt, 0x23, int_23);
    init_idt_entry(idt, 0x24, int_24);
    init_idt_entry(idt, 0x25, int_25);
    init_idt_entry(idt, 0x26, int_26);
    init_idt_entry(idt, 0x27, int_27);
    init_idt_entry(idt, 0x28, int_28);
    init_idt_entry(idt, 0x29, int_29);
    init_idt_entry(idt, 0x2a, int_2a);
    init_idt_entry(idt, 0x2b, int_2b);
    init_idt_entry(idt, 0x2c, int_2c);
    init_idt_entry(idt, 0x2d, int_2d);
    init_idt_entry(idt, 0x2e, int_2e);
    init_idt_entry(idt, 0x2f, int_2f);

    init_idt_entry(idt, 0x30, int_30);
    init_idt_entry(idt, 0x31, int_31);
    init_idt_entry(idt, 0x32, int_32);
    init_idt_entry(idt, 0x33, int_33);
    init_idt_entry(idt, 0x34, int_34);
    init_idt_entry(idt, 0x35, int_35);
    init_idt_entry(idt, 0x36, int_36);
    init_idt_entry(idt, 0x37, int_37);
    init_idt_entry(idt, 0x38, int_38);
    init_idt_entry(idt, 0x39, int_39);
    init_idt_entry(idt, 0x3a, int_3a);
    init_idt_entry(idt, 0x3b, int_3b);
    init_idt_entry(idt, 0x3c, int_3c);
    init_idt_entry(idt, 0x3d, int_3d);
    init_idt_entry(idt, 0x3e, int_3e);
    init_idt_entry(idt, 0x3f, int_3f);

    init_idt_entry(idt, 0x40, int_40);
    init_idt_entry(idt, 0x41, int_41);
    init_idt_entry(idt, 0x42, int_42);
    init_idt_entry(idt, 0x43, int_43);
    init_idt_entry(idt, 0x44, int_44);
    init_idt_entry(idt, 0x45, int_45);
    init_idt_entry(idt, 0x46, int_46);
    init_idt_entry(idt, 0x47, int_47);
    init_idt_entry(idt, 0x48, int_48);
    init_idt_entry(idt, 0x49, int_49);
    init_idt_entry(idt, 0x4a, int_4a);
    init_idt_entry(idt, 0x4b, int_4b);
    init_idt_entry(idt, 0x4c, int_4c);
    init_idt_entry(idt, 0x4d, int_4d);
    init_idt_entry(idt, 0x4e, int_4e);
    init_idt_entry(idt, 0x4f, int_4f);

    init_idt_entry(idt, 0x50, int_50);
    init_idt_entry(idt, 0x51, int_51);
    init_idt_entry(idt, 0x52, int_52);
    init_idt_entry(idt, 0x53, int_53);
    init_idt_entry(idt, 0x54, int_54);
    init_idt_entry(idt, 0x55, int_55);
    init_idt_entry(idt, 0x56, int_56);
    init_idt_entry(idt, 0x57, int_57);
    init_idt_entry(idt, 0x58, int_58);
    init_idt_entry(idt, 0x59, int_59);
    init_idt_entry(idt, 0x5a, int_5a);
    init_idt_entry(idt, 0x5b, int_5b);
    init_idt_entry(idt, 0x5c, int_5c);
    init_idt_entry(idt, 0x5d, int_5d);
    init_idt_entry(idt, 0x5e, int_5e);
    init_idt_entry(idt, 0x5f, int_5f);

    init_idt_entry(idt, 0x60, int_60);
    init_idt_entry(idt, 0x61, int_61);
    init_idt_entry(idt, 0x62, int_62);
    init_idt_entry(idt, 0x63, int_63);
    init_idt_entry(idt, 0x64, int_64);
    init_idt_entry(idt, 0x65, int_65);
    init_idt_entry(idt, 0x66, int_66);
    init_idt_entry(idt, 0x67, int_67);
    init_idt_entry(idt, 0x68, int_68);
    init_idt_entry(idt, 0x69, int_69);
    init_idt_entry(idt, 0x6a, int_6a);
    init_idt_entry(idt, 0x6b, int_6b);
    init_idt_entry(idt, 0x6c, int_6c);
    init_idt_entry(idt, 0x6d, int_6d);
    init_idt_entry(idt, 0x6e, int_6e);
    init_idt_entry(idt, 0x6f, int_6f);

    init_idt_entry(idt, 0x70, int_70);
    init_idt_entry(idt, 0x71, int_71);
    init_idt_entry(idt, 0x72, int_72);
    init_idt_entry(idt, 0x73, int_73);
    init_idt_entry(idt, 0x74, int_74);
    init_idt_entry(idt, 0x75, int_75);
    init_idt_entry(idt, 0x76, int_76);
    init_idt_entry(idt, 0x77, int_77);
    init_idt_entry(idt, 0x78, int_78);
    init_idt_entry(idt, 0x79, int_79);
    init_idt_entry(idt, 0x7a, int_7a);
    init_idt_entry(idt, 0x7b, int_7b);
    init_idt_entry(idt, 0x7c, int_7c);
    init_idt_entry(idt, 0x7d, int_7d);
    init_idt_entry(idt, 0x7e, int_7e);
    init_idt_entry(idt, 0x7f, int_7f);

    init_idt_entry(idt, 0x80, int_80);
    init_idt_entry(idt, 0x81, int_81);
    init_idt_entry(idt, 0x82, int_82);
    init_idt_entry(idt, 0x83, int_83);
    init_idt_entry(idt, 0x84, int_84);
    init_idt_entry(idt, 0x85, int_85);
    init_idt_entry(idt, 0x86, int_86);
    init_idt_entry(idt, 0x87, int_87);
    init_idt_entry(idt, 0x88, int_88);
    init_idt_entry(idt, 0x89, int_89);
    init_idt_entry(idt, 0x8a, int_8a);
    init_idt_entry(idt, 0x8b, int_8b);
    init_idt_entry(idt, 0x8c, int_8c);
    init_idt_entry(idt, 0x8d, int_8d);
    init_idt_entry(idt, 0x8e, int_8e);
    init_idt_entry(idt, 0x8f, int_8f);

    init_idt_entry(idt, 0x90, int_90);
    init_idt_entry(idt, 0x91, int_91);
    init_idt_entry(idt, 0x92, int_92);
    init_idt_entry(idt, 0x93, int_93);
    init_idt_entry(idt, 0x94, int_94);
    init_idt_entry(idt, 0x95, int_95);
    init_idt_entry(idt, 0x96, int_96);
    init_idt_entry(idt, 0x97, int_97);
    init_idt_entry(idt, 0x98, int_98);
    init_idt_entry(idt, 0x99, int_99);
    init_idt_entry(idt, 0x9a, int_9a);
    init_idt_entry(idt, 0x9b, int_9b);
    init_idt_entry(idt, 0x9c, int_9c);
    init_idt_entry(idt, 0x9d, int_9d);
    init_idt_entry(idt, 0x9e, int_9e);
    init_idt_entry(idt, 0x9f, int_9f);

    init_idt_entry(idt, 0xa0, int_a0);
    init_idt_entry(idt, 0xa1, int_a1);
    init_idt_entry(idt, 0xa2, int_a2);
    init_idt_entry(idt, 0xa3, int_a3);
    init_idt_entry(idt, 0xa4, int_a4);
    init_idt_entry(idt, 0xa5, int_a5);
    init_idt_entry(idt, 0xa6, int_a6);
    init_idt_entry(idt, 0xa7, int_a7);
    init_idt_entry(idt, 0xa8, int_a8);
    init_idt_entry(idt, 0xa9, int_a9);
    init_idt_entry(idt, 0xaa, int_aa);
    init_idt_entry(idt, 0xab, int_ab);
    init_idt_entry(idt, 0xac, int_ac);
    init_idt_entry(idt, 0xad, int_ad);
    init_idt_entry(idt, 0xae, int_ae);
    init_idt_entry(idt, 0xaf, int_af);

    init_idt_entry(idt, 0xb0, int_b0);
    init_idt_entry(idt, 0xb1, int_b1);
    init_idt_entry(idt, 0xb2, int_b2);
    init_idt_entry(idt, 0xb3, int_b3);
    init_idt_entry(idt, 0xb4, int_b4);
    init_idt_entry(idt, 0xb5, int_b5);
    init_idt_entry(idt, 0xb6, int_b6);
    init_idt_entry(idt, 0xb7, int_b7);
    init_idt_entry(idt, 0xb8, int_b8);
    init_idt_entry(idt, 0xb9, int_b9);
    init_idt_entry(idt, 0xba, int_ba);
    init_idt_entry(idt, 0xbb, int_bb);
    init_idt_entry(idt, 0xbc, int_bc);
    init_idt_entry(idt, 0xbd, int_bd);
    init_idt_entry(idt, 0xbe, int_be);
    init_idt_entry(idt, 0xbf, int_bf);

    init_idt_entry(idt, 0xc0, int_c0);
    init_idt_entry(idt, 0xc1, int_c1);
    init_idt_entry(idt, 0xc2, int_c2);
    init_idt_entry(idt, 0xc3, int_c3);
    init_idt_entry(idt, 0xc4, int_c4);
    init_idt_entry(idt, 0xc5, int_c5);
    init_idt_entry(idt, 0xc6, int_c6);
    init_idt_entry(idt, 0xc7, int_c7);
    init_idt_entry(idt, 0xc8, int_c8);
    init_idt_entry(idt, 0xc9, int_c9);
    init_idt_entry(idt, 0xca, int_ca);
    init_idt_entry(idt, 0xcb, int_cb);
    init_idt_entry(idt, 0xcc, int_cc);
    init_idt_entry(idt, 0xcd, int_cd);
    init_idt_entry(idt, 0xce, int_ce);
    init_idt_entry(idt, 0xcf, int_cf);

    init_idt_entry(idt, 0xd0, int_d0);
    init_idt_entry(idt, 0xd1, int_d1);
    init_idt_entry(idt, 0xd2, int_d2);
    init_idt_entry(idt, 0xd3, int_d3);
    init_idt_entry(idt, 0xd4, int_d4);
    init_idt_entry(idt, 0xd5, int_d5);
    init_idt_entry(idt, 0xd6, int_d6);
    init_idt_entry(idt, 0xd7, int_d7);
    init_idt_entry(idt, 0xd8, int_d8);
    init_idt_entry(idt, 0xd9, int_d9);
    init_idt_entry(idt, 0xda, int_da);
    init_idt_entry(idt, 0xdb, int_db);
    init_idt_entry(idt, 0xdc, int_dc);
    init_idt_entry(idt, 0xdd, int_dd);
    init_idt_entry(idt, 0xde, int_de);
    init_idt_entry(idt, 0xdf, int_df);

    init_idt_entry(idt, 0xe0, int_e0);
    init_idt_entry(idt, 0xe1, int_e1);
    init_idt_entry(idt, 0xe2, int_e2);
    init_idt_entry(idt, 0xe3, int_e3);
    init_idt_entry(idt, 0xe4, int_e4);
    init_idt_entry(idt, 0xe5, int_e5);
    init_idt_entry(idt, 0xe6, int_e6);
    init_idt_entry(idt, 0xe7, int_e7);
    init_idt_entry(idt, 0xe8, int_e8);
    init_idt_entry(idt, 0xe9, int_e9);
    init_idt_entry(idt, 0xea, int_ea);
    init_idt_entry(idt, 0xeb, int_eb);
    init_idt_entry(idt, 0xec, int_ec);
    init_idt_entry(idt, 0xed, int_ed);
    init_idt_entry(idt, 0xee, int_ee);
    init_idt_entry(idt, 0xef, int_ef);

    init_idt_entry(idt, 0xf0, int_f0);
    init_idt_entry(idt, 0xf1, int_f1);
    init_idt_entry(idt, 0xf2, int_f2);
    init_idt_entry(idt, 0xf3, int_f3);
    init_idt_entry(idt, 0xf4, int_f4);
    init_idt_entry(idt, 0xf5, int_f5);
    init_idt_entry(idt, 0xf6, int_f6);
    init_idt_entry(idt, 0xf7, int_f7);
    init_idt_entry(idt, 0xf8, int_f8);
    init_idt_entry(idt, 0xf9, int_f9);
    init_idt_entry(idt, 0xfa, int_fa);
    init_idt_entry(idt, 0xfb, int_fb);
    init_idt_entry(idt, 0xfc, int_fc);
    init_idt_entry(idt, 0xfd, int_fd);
    init_idt_entry(idt, 0xfe, int_fe);
    init_idt_entry(idt, 0xff, int_ff);
}

__attribute__((__section__(".boot.text"))) bool_t
map_kernel_window(
    pdpte_t* pdpt,
    pde_t* pd,
    pte_t* pt,
    p_region_t ndks_p_reg





    , uint32_t num_drhu,
    paddr_t* drhu_list

)
{
    paddr_t phys;
    uint32_t idx;
    pde_t pde;
    pte_t pte;
    unsigned int __attribute__((unused)) i;

    if ((void*)pdpt != (void*)pd) {
        for (idx = 0; idx < (1ul<<(0)); idx++) {
            pdpte_ptr_new(pdpt + idx,
                          pptr_to_paddr(pd + (idx * (1ul<<(10)))),
                          0, /* avl*/
                          0, /* cache_disabled */
                          0, /* write_through */
                          1 /* present */
                         );
        }
    }

    /* Mapping of PPTR_BASE (virtual address) to kernel's PADDR_BASE
     * up to end of virtual address space except for the last large page.
     */
    phys = 0x00000000;
    idx = 0xe0000000 >> IA32_4M_bits;





    while (idx < (1ul<<(10 + 0)) - 1) {

        pde = pde_pde_large_new(
                  phys, /* page_base_address    */
                  0, /* pat                  */
                  0, /* avl_cte_depth        */
                  1, /* global               */
                  0, /* dirty                */
                  0, /* accessed             */
                  0, /* cache_disabled       */
                  0, /* write_through        */
                  0, /* super_user           */
                  1, /* read_write           */
                  1 /* present              */
              );
        pd[idx] = pde;
        phys += (1ul<<(IA32_4M_bits));
        idx++;
    }

    /* crosscheck whether we have mapped correctly so far */
    if(!(phys == ((-(1ul<<(IA32_4M_bits))) - (0xe0000000 - 0x00000000)))) _assert_fail("phys == PADDR_TOP", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 562, __FUNCTION__);
# 574 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c"
    /* map page table of last 4M of virtual address space to page directory */
    pde = pde_pde_small_new(
              pptr_to_paddr(pt), /* pt_base_address  */
              0, /* avl_cte_Depth    */
              0, /* accessed         */
              0, /* cache_disabled   */
              0, /* write_through    */
              1, /* super_user       */
              1, /* read_write       */
              1 /* present          */
          );
    pd[idx] = pde;

    /* Start with an empty guard page preceding the stack. */
    idx = 0;
    pte = pte_new(
              0, /* page_base_address    */
              0, /* avl                  */
              0, /* global               */
              0, /* pat                  */
              0, /* dirty                */
              0, /* accessed             */
              0, /* cache_disabled       */
              0, /* write_through        */
              0, /* super_user           */
              0, /* read_write           */
              0 /* present              */
          );
    pt[idx] = pte;
    idx++;

    /* establish NDKS (node kernel state) mappings in page table */
    phys = ndks_p_reg.start;
    while (idx - 1 < (ndks_p_reg.end - ndks_p_reg.start) >> IA32_4K_bits) {
        pte = pte_new(
                  phys, /* page_base_address    */
                  0, /* avl_cte_depth        */
                  1, /* global               */
                  0, /* pat                  */
                  0, /* dirty                */
                  0, /* accessed             */
                  0, /* cache_disabled       */
                  0, /* write_through        */
                  0, /* super_user           */
                  1, /* read_write           */
                  1 /* present              */
              );
        pt[idx] = pte;
        phys += (1ul<<(IA32_4K_bits));
        idx++;
    }

    /* null mappings up to PPTR_KDEV */

    while (idx < (0xffff0000 & ((1ul<<(IA32_4M_bits))-1ul)) >> IA32_4K_bits) {
        pte = pte_new(
                  0, /* page_base_address    */
                  0, /* avl_cte_depth        */
                  0, /* global               */
                  0, /* pat                  */
                  0, /* dirty                */
                  0, /* accessed             */
                  0, /* cache_disabled       */
                  0, /* write_through        */
                  0, /* super_user           */
                  0, /* read_write           */
                  0 /* present              */
              );
        pt[idx] = pte;
        phys += (1ul<<(IA32_4K_bits));
        idx++;
    }

    /* map kernel devices (devices only used by the kernel) */

    /* map kernel devices: APIC */
    phys = apic_get_base_paddr();
    if (!phys) {
        return false;
    }
    pte = pte_new(
              phys, /* page_base_address    */
              0, /* avl_cte_depth        */
              1, /* global               */
              0, /* pat                  */
              0, /* dirty                */
              0, /* accessed             */
              1, /* cache_disabled       */
              1, /* write_through        */
              0, /* super_user           */
              1, /* read_write           */
              1 /* present              */
          );

    if(!(idx == (0xffff0000 & ((1ul<<(IA32_4M_bits))-1ul)) >> IA32_4K_bits)) _assert_fail("idx == (PPTR_APIC & MASK(LARGE_PAGE_BITS)) >> PAGE_BITS", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 668, __FUNCTION__);
    pt[idx] = pte;
    idx++;
# 717 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c"
    /* map kernel devices: IOMMUs */
    for (i = 0; i < num_drhu; i++) {
        phys = (paddr_t)drhu_list[i];
        pte = pte_new(
                  phys, /* page_base_address    */
                  0, /* avl_cte_depth        */
                  1, /* global               */
                  0, /* pat                  */
                  0, /* dirty                */
                  0, /* accessed             */
                  1, /* cache_disabled       */
                  1, /* write_through        */
                  0, /* super_user           */
                  1, /* read_write           */
                  1 /* present              */
              );

        if(!(idx == (((0xffff0000 + (1ul<<(IA32_4K_bits))) + i * (1ul<<(IA32_4K_bits))) & ((1ul<<(IA32_4M_bits))-1ul)) >> IA32_4K_bits)) _assert_fail("idx == ((PPTR_DRHU_START + i * BIT(PAGE_BITS)) & MASK(LARGE_PAGE_BITS)) >> PAGE_BITS", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 734, __FUNCTION__);
        pt[idx] = pte;
        idx++;
        if (idx == (1ul<<(10))) {
            return false;
        }
    }


    /* mark unused kernel-device pages as 'not present' */
    while (idx < (1ul<<(10))) {
        pte = pte_new(
                  0, /* page_base_address    */
                  0, /* avl_cte_depth        */
                  0, /* global               */
                  0, /* pat                  */
                  0, /* dirty                */
                  0, /* accessed             */
                  0, /* cache_disabled       */
                  0, /* write_through        */
                  0, /* super_user           */
                  0, /* read_write           */
                  0 /* present              */
              );
        pt[idx] = pte;
        idx++;
    }

    /* Check we haven't added too many kernel-device mappings.*/
    if(!(idx == (1ul<<(10)))) _assert_fail("idx == BIT(PT_BITS)", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 763, __FUNCTION__);

    invalidatePageStructureCache();
    return true;
}

__attribute__((__section__(".boot.text"))) void
map_it_pt_cap(cap_t pt_cap)
{
    pde_t* pd = ((pde_t *)(cap_page_table_cap_get_capPTMappedObject(pt_cap)));
    pte_t* pt = ((pte_t *)(cap_page_table_cap_get_capPTBasePtr(pt_cap)));
    uint32_t index = cap_page_table_cap_get_capPTMappedIndex(pt_cap);

    /* Assume the capabilities for the initial page tables are at a depth of 0 */
    pde_pde_small_ptr_new(
        pd + index,
        pptr_to_paddr(pt), /* pt_base_address */
        0, /* avl_cte_depth   */
        0, /* accessed        */
        0, /* cache_disabled  */
        0, /* write_through   */
        1, /* super_user      */
        1, /* read_write      */
        1 /* present         */
    );
    invalidatePageStructureCache();
}

__attribute__((__section__(".boot.text"))) void
map_it_frame_cap(cap_t frame_cap)
{
    pte_t *pt;
    pte_t *targetSlot;
    uint32_t index;
    void *frame = (void*)cap_frame_cap_get_capFBasePtr(frame_cap);

    pt = ((pte_t *)(cap_frame_cap_get_capFMappedObject(frame_cap)));
    index = cap_frame_cap_get_capFMappedIndex(frame_cap);
    targetSlot = pt + index;
    /* Assume the capabilities for the inital frames are at a depth of 0 */
    pte_ptr_new(
        targetSlot,
        pptr_to_paddr(frame), /* page_base_address */
        0, /* avl_cte_depth     */
        0, /* global            */
        0, /* pat               */
        0, /* dirty             */
        0, /* accessed          */
        0, /* cache_disabled    */
        0, /* write_through     */
        1, /* super_user        */
        1, /* read_write        */
        1 /* present           */
    );
    invalidatePageStructureCache();
}

/* Note: this function will invalidate any pointers previously returned from this function */
__attribute__((__section__(".boot.text"))) void*
map_temp_boot_page(void* entry, uint32_t large_pages)
{
    void* replacement_vaddr;
    unsigned int i;
    unsigned int offset_in_page;

    unsigned int phys_pg_start = (unsigned int)(entry) & ~((1ul<<(IA32_4M_bits))-1ul);
    unsigned int virt_pd_start = (0xe0000000 >> IA32_4M_bits) - large_pages;
    unsigned int virt_pg_start = 0xe0000000 - (large_pages << IA32_4M_bits);

    for (i = 0; i < large_pages; ++i) {
        unsigned int pg_offset = i << IA32_4M_bits; // num pages since start * page size

        pde_pde_large_ptr_new(get_boot_pd() + virt_pd_start + i,
                              phys_pg_start + pg_offset, /* physical address */
                              0, /* pat            */
                              0, /* avl            */
                              1, /* global         */
                              0, /* dirty          */
                              0, /* accessed       */
                              0, /* cache_disabled */
                              0, /* write_through  */
                              0, /* super_user     */
                              1, /* read_write     */
                              1 /* present        */
                             );
        invalidateTLBentry(virt_pg_start + pg_offset);
    }

    // assign replacement virtual addresses page
    offset_in_page = (unsigned int)(entry) & ((1ul<<(IA32_4M_bits))-1ul);
    replacement_vaddr = (void*)(virt_pg_start + offset_in_page);

    invalidatePageStructureCache();

    return replacement_vaddr;
}

__attribute__((__section__(".boot.text"))) bool_t
init_vm_state(pdpte_t *kernel_pdpt, pde_t* kernel_pd, pte_t* kernel_pt)
{
    ia32KScacheLineSizeBits = getCacheLineSizeBits();
    if (!ia32KScacheLineSizeBits) {
        return false;
    }
    ia32KSkernelPDPT = kernel_pdpt;
    ia32KSkernelPD = kernel_pd;
    ia32KSkernelPT = kernel_pt;
    init_tss(&ia32KStss);
    init_gdt(ia32KSgdt, &ia32KStss);
    init_idt(ia32KSidt);
    return true;
}

/* initialise CPU's descriptor table registers (GDTR, IDTR, LDTR, TR) */

__attribute__((__section__(".boot.text"))) void
init_dtrs(void)
{
    /* setup the GDT pointer and limit and load into GDTR */
    gdt_idt_ptr.limit = (sizeof(gdt_entry_t) * 8) - 1;
    gdt_idt_ptr.basel = (uint32_t)ia32KSgdt;
    gdt_idt_ptr.baseh = (uint16_t)((uint32_t)ia32KSgdt >> 16);
    ia32_install_gdt(&gdt_idt_ptr);

    /* setup the IDT pointer and limit and load into IDTR */
    gdt_idt_ptr.limit = (sizeof(idt_entry_t) * (int_max + 1)) - 1;
    gdt_idt_ptr.basel = (uint32_t)ia32KSidt;
    gdt_idt_ptr.baseh = (uint16_t)((uint32_t)ia32KSidt >> 16);
    ia32_install_idt(&gdt_idt_ptr);

    /* load NULL LDT selector into LDTR */
    ia32_install_ldt(0);

    /* load TSS selector into Task Register (TR) */
    ia32_install_tss((5 << 3));
}

__attribute__((__section__(".boot.text"))) bool_t
init_pat_msr(void)
{
    ia32_pat_msr_t pat_msr;
    /* First verify PAT is supported by the machine.
     *      See section 11.12.1 of Volume 3 of the Intel manual */
    if ( (ia32_cpuid_edx(0x1, 0x0) & (1ul<<(16))) == 0) {
        kprintf("PAT support not found\n");
        return false;
    }
    pat_msr.words[0] = ia32_rdmsr_low(0x277);
    pat_msr.words[1] = ia32_rdmsr_high(0x277);
    /* Set up the PAT MSR to the Intel defaults, just in case
     * they have been changed but a bootloader somewhere along the way */
    ia32_pat_msr_ptr_set_pa0(&pat_msr, 0x06);
    ia32_pat_msr_ptr_set_pa1(&pat_msr, 0x04);
    ia32_pat_msr_ptr_set_pa2(&pat_msr, 0x07);
    ia32_pat_msr_ptr_set_pa3(&pat_msr, 0x00);
    /* Add the WriteCombining cache type to the PAT */
    ia32_pat_msr_ptr_set_pa4(&pat_msr, 0x01);
    ia32_wrmsr(0x277, pat_msr.words[1], pat_msr.words[0]);
    return true;
}

/* ==================== BOOT CODE FINISHES HERE ==================== */

static uint32_t __attribute__((__const__)) WritableFromVMRights(vm_rights_t vm_rights)
{
    switch (vm_rights) {
    case VMReadOnly:
        return 0;

    case VMKernelOnly:
    case VMReadWrite:
        return 1;

    default:
        _fail("Invalid VM rights", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 937, __func__);
    }
}

static uint32_t __attribute__((__const__)) SuperUserFromVMRights(vm_rights_t vm_rights)
{
    switch (vm_rights) {
    case VMKernelOnly:
        return 0;

    case VMReadOnly:
    case VMReadWrite:
        return 1;

    default:
        _fail("Invalid VM rights", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 952, __func__);
    }
}

static pde_t __attribute__((__const__)) makeUserPDE(paddr_t paddr, vm_attributes_t vm_attr, vm_rights_t vm_rights, uint32_t avl)
{
    return pde_pde_large_new(
               paddr, /* page_base_address    */
               vm_attributes_get_ia32PATBit(vm_attr), /* pat                  */
               avl, /* avl_cte_depth        */
               0, /* global               */
               0, /* dirty                */
               0, /* accessed             */
               vm_attributes_get_ia32PCDBit(vm_attr), /* cache_disabled       */
               vm_attributes_get_ia32PWTBit(vm_attr), /* write_through        */
               SuperUserFromVMRights(vm_rights), /* super_user           */
               WritableFromVMRights(vm_rights), /* read_write           */
               1 /* present              */
           );
}

static pte_t __attribute__((__const__)) makeUserPTE(paddr_t paddr, vm_attributes_t vm_attr, vm_rights_t vm_rights, uint32_t avl)
{
    return pte_new(
               paddr, /* page_base_address    */
               avl, /* avl_cte_depth        */
               0, /* global               */
               vm_attributes_get_ia32PATBit(vm_attr), /* pat                  */
               0, /* dirty                */
               0, /* accessed             */
               vm_attributes_get_ia32PCDBit(vm_attr), /* cache_disabled       */
               vm_attributes_get_ia32PWTBit(vm_attr), /* write_through        */
               SuperUserFromVMRights(vm_rights), /* super_user           */
               WritableFromVMRights(vm_rights), /* read_write           */
               1 /* present              */
           );
}

word_t* __attribute__((__pure__)) lookupIPCBuffer(bool_t isReceiver, tcb_t *thread)
{
    word_t w_bufferPtr;
    cap_t bufferCap;
    vm_rights_t vm_rights;

    w_bufferPtr = thread->tcbIPCBuffer;
    bufferCap = (((cte_t *)((unsigned int)(thread)&~((1ul<<(10))-1ul)))+(tcbBuffer))->cap;

    if (cap_get_capType(bufferCap) != cap_frame_cap) {
        return ((void *)0);
    }

    vm_rights = cap_frame_cap_get_capFVMRights(bufferCap);
    if (vm_rights == VMReadWrite || (!isReceiver && vm_rights == VMReadOnly)) {
        word_t basePtr;
        unsigned int pageBits;

        basePtr = cap_frame_cap_get_capFBasePtr(bufferCap);
        pageBits = pageBitsForSize(cap_frame_cap_get_capFSize(bufferCap));
        return (word_t *)(basePtr + (w_bufferPtr & ((1ul<<(pageBits))-1ul)));
    } else {
        return ((void *)0);
    }
}

static lookupPTSlot_ret_t lookupPTSlot(void *vspace, vptr_t vptr)
{
    lookupPTSlot_ret_t ret;
    lookupPDSlot_ret_t pdSlot;

    pdSlot = lookupPDSlot(vspace, vptr);
    if (pdSlot.status != EXCEPTION_NONE) {
        ret.ptSlot = ((void *)0);
        ret.status = pdSlot.status;
        return ret;
    }

    if ((pde_ptr_get_page_size(pdSlot.pdSlot) != pde_pde_small) ||
            !pde_pde_small_ptr_get_present(pdSlot.pdSlot)) {
        current_lookup_fault = lookup_fault_missing_capability_new(IA32_4K_bits + 10);

        ret.ptSlot = ((void *)0);
        ret.status = EXCEPTION_LOOKUP_FAULT;
        return ret;
    } else {
        pte_t* pt;
        pte_t* ptSlot;
        unsigned int ptIndex;

        pt = paddr_to_pptr(pde_pde_small_ptr_get_pt_base_address(pdSlot.pdSlot));
        ptIndex = (vptr >> IA32_4K_bits) & ((1ul<<(10))-1ul);
        ptSlot = pt + ptIndex;

        ret.pt = pt;
        ret.ptIndex = ptIndex;
        ret.ptSlot = ptSlot;
        ret.status = EXCEPTION_NONE;
        return ret;
    }
}

exception_t handleVMFault(tcb_t* thread, vm_fault_type_t vm_faultType)
{
    uint32_t addr;
    uint32_t fault;

    addr = getFaultAddr();
    fault = getRegister(thread, Error);

    switch (vm_faultType) {
    case IA32DataFault:
        current_fault = fault_vm_fault_new(addr, fault, false);
        return EXCEPTION_FAULT;

    case IA32InstructionFault:
        current_fault = fault_vm_fault_new(addr, fault, true);
        return EXCEPTION_FAULT;

    default:
        _fail("Invalid VM fault type", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1070, __func__);
    }
}

exception_t checkValidIPCBuffer(vptr_t vptr, cap_t cap)
{
    if (cap_get_capType(cap) != cap_frame_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1077, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IPC Buffer is an invalid cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (!inKernelWindow((void *)cap_frame_cap_get_capFBasePtr(cap))) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1083, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IPC Buffer must in the kernel window."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (!(!((vptr) & ((1ul<<(9))-1ul)))) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1089, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IPC Buffer vaddr 0x%x is not aligned.", (int)vptr); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_AlignmentError;
        return EXCEPTION_SYSCALL_ERROR;
    }

    return EXCEPTION_NONE;
}

vm_rights_t __attribute__((__const__)) maskVMRights(vm_rights_t vm_rights, cap_rights_t cap_rights_mask)
{
    if (vm_rights == VMReadOnly && cap_rights_get_capAllowRead(cap_rights_mask)) {
        return VMReadOnly;
    }
    if (vm_rights == VMReadWrite && cap_rights_get_capAllowRead(cap_rights_mask)) {
        if (!cap_rights_get_capAllowWrite(cap_rights_mask)) {
            return VMReadOnly;
        } else {
            return VMReadWrite;
        }
    }
    return VMKernelOnly;
}

static void flushTable(void *vspace, uint32_t pdIndex, pte_t *pt)
{
    cap_t threadRoot;

    /* check if page table belongs to current address space */
    threadRoot = (((cte_t *)((unsigned int)(ksCurThread)&~((1ul<<(10))-1ul)))+(tcbVTable))->cap;
    if (isValidNativeRoot(threadRoot) && (void*)(pptr_t)cap_get_capPtr(threadRoot) == vspace) {
        invalidateTLB();
        invalidatePageStructureCache();
    }
}

void setVMRoot(tcb_t* tcb)
{
    cap_t threadRoot;
    void *vspace_root;

    threadRoot = (((cte_t *)((unsigned int)(tcb)&~((1ul<<(10))-1ul)))+(tcbVTable))->cap;

    vspace_root = getValidNativeRoot(threadRoot);
    if (!vspace_root) {
        setCurrentPD(pptr_to_paddr(ia32KSkernelPDPT));
        return;
    }

    /* only set PD if we change it, otherwise we flush the TLB needlessly */
    if (getCurrentPD() != pptr_to_paddr(vspace_root)) {
        setCurrentPD(pptr_to_paddr(vspace_root));
    }
}

void unmapAllPageTables(pde_t *pd)
{
    uint32_t i, max;
    if(!(pd)) _assert_fail("pd", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1146, __FUNCTION__);




    max = (0xe0000000 & (~((1ul<<(IA32_4M_bits))-1ul))) >> IA32_4M_bits;

    for (i = 0; i < max; i++) {
        if (pde_ptr_get_page_size(pd + i) == pde_pde_small && pde_pde_small_ptr_get_present(pd + i)) {
            pte_t *pt = ((pte_t *)(paddr_to_pptr(pde_pde_small_ptr_get_pt_base_address(pd + i))));
            cte_t *ptCte;
            cap_t ptCap;
            ptCte = cdtFindAtDepth(cap_page_table_cap_new(((unsigned int)(pd)), i, ((unsigned int)(pt))), pde_pde_small_ptr_get_avl_cte_depth(pd + i));
            if(!(ptCte)) _assert_fail("ptCte", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1159, __FUNCTION__);

            ptCap = ptCte->cap;
            ptCap = cap_page_table_cap_set_capPTMappedObject(ptCap, 0);
            cdtUpdate(ptCte, ptCap);
        } else if (pde_ptr_get_page_size(pd + i) == pde_pde_large && pde_pde_large_ptr_get_present(pd + i)) {
            void *frame = paddr_to_pptr(pde_pde_large_ptr_get_page_base_address(pd + i));
            cte_t *frameCte;
            cap_t frameCap;
            frameCte = cdtFindAtDepth(cap_frame_cap_new(IA32_LargePage, ((unsigned int)(pd)), i, IA32_MAPPING_PD, 0, (uint32_t)frame), pde_pde_large_ptr_get_avl_cte_depth(pd + i));
            if(!(frameCte)) _assert_fail("frameCte", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1169, __FUNCTION__);
            frameCap = cap_frame_cap_set_capFMappedObject(frameCte->cap, 0);
            cdtUpdate(frameCte, frameCap);
        }
    }
}

void unmapAllPages(pte_t *pt)
{
    cte_t* frameCte;
    cap_t newCap;
    uint32_t i;

    for (i = 0; i < (1ul<<(10)); i++) {
        if (pte_ptr_get_present(pt + i)) {
            frameCte = cdtFindAtDepth(cap_frame_cap_new(IA32_SmallPage, ((unsigned int)(pt)), i, IA32_MAPPING_PD, 0, (uint32_t)paddr_to_pptr(pte_ptr_get_page_base_address(pt + i))), pte_ptr_get_avl_cte_depth(pt + i));
            if(!(frameCte)) _assert_fail("frameCte", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1185, __FUNCTION__);
            newCap = cap_frame_cap_set_capFMappedObject(frameCte->cap, 0);
            cdtUpdate(frameCte, newCap);
        }
    }
}

void unmapPageTable(pde_t* pd, uint32_t pdIndex)
{
    pd[pdIndex] = pde_pde_small_new(
                      0, /* pt_base_address  */
                      0, /* avl_cte_Depth    */
                      0, /* accessed         */
                      0, /* cache_disabled   */
                      0, /* write_through    */
                      0, /* super_user       */
                      0, /* read_write       */
                      0 /* present          */
                  );
}

void unmapPageSmall(pte_t *pt, uint32_t ptIndex)
{
    pt[ptIndex] = pte_new(
                      0, /* page_base_address    */
                      0, /* avl_cte_depth        */
                      0, /* global               */
                      0, /* pat                  */
                      0, /* dirty                */
                      0, /* accessed             */
                      0, /* cache_disabled       */
                      0, /* write_through        */
                      0, /* super_user           */
                      0, /* read_write           */
                      0 /* present              */
                  );
}

void unmapPageLarge(pde_t *pd, uint32_t pdIndex)
{
    pd[pdIndex] = pde_pde_large_new(
                      0, /* page_base_address    */
                      0, /* pat                  */
                      0, /* avl_cte_depth        */
                      0, /* global               */
                      0, /* dirty                */
                      0, /* accessed             */
                      0, /* cache_disabled       */
                      0, /* write_through        */
                      0, /* super_user           */
                      0, /* read_write           */
                      0 /* present              */
                  );
}

static exception_t
performPageGetAddress(void *vbase_ptr)
{
    paddr_t capFBasePtr;

    /* Get the physical address of this frame. */
    capFBasePtr = pptr_to_paddr(vbase_ptr);

    /* return it in the first message register */
    setRegister(ksCurThread, msgRegisters[0], capFBasePtr);
    setRegister(ksCurThread, msgInfoRegister,
                wordFromMessageInfo(message_info_new(0, 0, 0, 1)));

    return EXCEPTION_NONE;
}

static inline bool_t
checkVPAlignment(vm_page_size_t sz, word_t w)
{
    return (!((w) & ((1ul<<(pageBitsForSize(sz)))-1ul)));
}

static exception_t
decodeIA32PageTableInvocation(
    word_t label,
    unsigned int length,
    cte_t* cte, cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    word_t vaddr;
    vm_attributes_t attr;
    lookupPDSlot_ret_t pdSlot;
    cap_t vspaceCap;
    void* vspace;
    pde_t pde;
    pde_t * pd;
    paddr_t paddr;

    if (label == IA32PageTableUnmap) {
        setThreadState(ksCurThread, ThreadState_Restart);

        pd = ((pde_t *)(cap_page_table_cap_get_capPTMappedObject(cap)));
        if (pd) {
            pte_t *pt = ((pte_t *)(cap_page_table_cap_get_capPTBasePtr(cap)));
            uint32_t pdIndex = cap_page_table_cap_get_capPTMappedIndex(cap);
            unmapPageTable(pd, pdIndex);
            flushTable(pd, pdIndex, pt);
            clearMemory((void *)pt, cap_get_capSizeBits(cap));
        }
        cdtUpdate(cte, cap_page_table_cap_set_capPTMappedObject(cap, 0));

        return EXCEPTION_NONE;
    }

    if (label != IA32PageTableMap ) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1297, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32PageTable: Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (length < 2 || extraCaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1303, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32PageTable: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (cdtFindWithExtra(cap)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1309, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32PageTable: Page table is already mapped to a page directory."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type =
            seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;

        return EXCEPTION_SYSCALL_ERROR;
    }

    vaddr = getSyscallArg(0, buffer) & (~((1ul<<(10 + IA32_4K_bits))-1ul));
    attr = vmAttributesFromWord(getSyscallArg(1, buffer));
    vspaceCap = extraCaps.excaprefs[0]->cap;

    if (!isValidNativeRoot(vspaceCap)) {
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 1;

        return EXCEPTION_SYSCALL_ERROR;
    }

    vspace = (void*)(pptr_t)cap_get_capPtr(vspaceCap);

    if (vaddr >= (0xe0000000 & (~((1ul<<(IA32_4M_bits))-1ul)))) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1331, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32PageTable: Mapping address too high."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 0;

        return EXCEPTION_SYSCALL_ERROR;
    }

    pdSlot = lookupPDSlot(vspace, vaddr);
    if (pdSlot.status != EXCEPTION_NONE) {
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = false;

        return EXCEPTION_SYSCALL_ERROR;
    }

    if (((pde_ptr_get_page_size(pdSlot.pdSlot) == pde_pde_small) && pde_pde_small_ptr_get_present(pdSlot.pdSlot)) ||
            ((pde_ptr_get_page_size(pdSlot.pdSlot) == pde_pde_large) && pde_pde_large_ptr_get_present(pdSlot.pdSlot))) {
        current_syscall_error.type = seL4_DeleteFirst;

        return EXCEPTION_SYSCALL_ERROR;
    }

    paddr = pptr_to_paddr(((pte_t *)(cap_page_table_cap_get_capPTBasePtr(cap))));
    pde = pde_pde_small_new(
              paddr, /* pt_base_address  */
              mdb_node_get_cdtDepth(cte->cteMDBNode), /* avl_cte_depth    */
              0, /* accessed         */
              vm_attributes_get_ia32PCDBit(attr), /* cache_disabled   */
              vm_attributes_get_ia32PWTBit(attr), /* write_through    */
              1, /* super_user       */
              1, /* read_write       */
              1 /* present          */
          );

    cap = cap_page_table_cap_set_capPTMappedObject(cap, ((unsigned int)(pdSlot.pd)));
    cap = cap_page_table_cap_set_capPTMappedIndex(cap, pdSlot.pdIndex);

    cdtUpdate(cte, cap);
    *pdSlot.pdSlot = pde;

    setThreadState(ksCurThread, ThreadState_Restart);
    invalidatePageStructureCache();
    return EXCEPTION_NONE;
}

static exception_t
decodeIA32PDFrameMap(
    cap_t vspaceCap,
    cte_t *cte,
    cap_t cap,
    vm_rights_t vmRights,
    vm_attributes_t vmAttr,
    word_t vaddr)
{
    void * vspace;
    word_t vtop;
    paddr_t paddr;
    vm_page_size_t frameSize;

    frameSize = cap_frame_cap_get_capFSize(cap);

    vtop = vaddr + (1ul<<(pageBitsForSize(frameSize)));

    vspace = (void*)(pptr_t)cap_get_capPtr(vspaceCap);

    if (vtop > (0xe0000000 & (~((1ul<<(IA32_4M_bits))-1ul)))) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1397, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32Frame: Mapping address too high."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 0;

        return EXCEPTION_SYSCALL_ERROR;
    }

    paddr = pptr_to_paddr((void*)cap_frame_cap_get_capFBasePtr(cap));

    switch (frameSize) {
        /* PTE mappings */
    case IA32_SmallPage: {
        lookupPTSlot_ret_t lu_ret;

        lu_ret = lookupPTSlot(vspace, vaddr);

        if (lu_ret.status != EXCEPTION_NONE) {
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = false;
            /* current_lookup_fault will have been set by lookupPTSlot */
            return EXCEPTION_SYSCALL_ERROR;
        }
        if (pte_get_present(*lu_ret.ptSlot)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1420, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32FrameMap: Mapping already present"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_DeleteFirst;
            return EXCEPTION_SYSCALL_ERROR;
        }

        cap = cap_frame_cap_set_capFMappedObject(cap, ((unsigned int)(lu_ret.pt)));
        cap = cap_frame_cap_set_capFMappedIndex(cap, lu_ret.ptIndex);
        cap = cap_frame_cap_set_capFMappedType(cap, IA32_MAPPING_PD);
        cdtUpdate(cte, cap);
        *lu_ret.ptSlot = makeUserPTE(paddr, vmAttr, vmRights, mdb_node_get_cdtDepth(cte->cteMDBNode));

        invalidatePageStructureCache();
        setThreadState(ksCurThread, ThreadState_Restart);
        return EXCEPTION_NONE;
    }

    /* PDE mappings */
    case IA32_LargePage: {
        lookupPDSlot_ret_t lu_ret;

        lu_ret = lookupPDSlot(vspace, vaddr);
        if (lu_ret.status != EXCEPTION_NONE) {
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = false;
            /* current_lookup_fault will have been set by lookupPDSlot */
            return EXCEPTION_SYSCALL_ERROR;
        }
        if ( (pde_ptr_get_page_size(lu_ret.pdSlot) == pde_pde_small && (pde_pde_small_ptr_get_present(lu_ret.pdSlot))) ||
                (pde_ptr_get_page_size(lu_ret.pdSlot) == pde_pde_large && (pde_pde_large_ptr_get_present(lu_ret.pdSlot)))) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1449, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32FrameMap: Mapping already present"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_DeleteFirst;

            return EXCEPTION_SYSCALL_ERROR;
        }

        *lu_ret.pdSlot = makeUserPDE(paddr, vmAttr, vmRights, mdb_node_get_cdtDepth(cte->cteMDBNode));
        cap = cap_frame_cap_set_capFMappedObject(cap, ((unsigned int)(lu_ret.pd)));
        cap = cap_frame_cap_set_capFMappedIndex(cap, lu_ret.pdIndex);
        cap = cap_frame_cap_set_capFMappedType(cap, IA32_MAPPING_PD);
        cdtUpdate(cte, cap);

        invalidatePageStructureCache();
        setThreadState(ksCurThread, ThreadState_Restart);
        return EXCEPTION_NONE;
    }

    default:
        _fail("Invalid page type", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1467, __func__);
    }
}

static void IA32PageUnmapPD(cap_t cap)
{
    void *object = (void*)cap_frame_cap_get_capFMappedObject(cap);
    uint32_t index = cap_frame_cap_get_capFMappedIndex(cap);
    switch (cap_frame_cap_get_capFSize(cap)) {
    case IA32_SmallPage:
        unmapPageSmall(((pte_t *)(object)), index);
        flushPageSmall(((pte_t *)(object)), index);
        break;
    case IA32_LargePage:
        unmapPageLarge(((pde_t *)(object)), index);
        flushPageLarge(((pde_t *)(object)), index);
        break;
    default:
        _fail("Invalid page type", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1485, __func__);
    }
}

static exception_t
decodeIA32FrameInvocation(
    word_t label,
    unsigned int length,
    cte_t* cte,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    switch (label) {
    case IA32PageMap: { /* Map */
        word_t vaddr;
        word_t w_rightsMask;
        cap_t vspaceCap;
        vm_rights_t capVMRights;
        vm_rights_t vmRights;
        vm_attributes_t vmAttr;
        vm_page_size_t frameSize;

        if (length < 3 || extraCaps.excaprefs[0] == ((void *)0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1510, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32Frame: Truncated message"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_TruncatedMessage;

            return EXCEPTION_SYSCALL_ERROR;
        }

        vaddr = getSyscallArg(0, buffer);
        w_rightsMask = getSyscallArg(1, buffer);
        vmAttr = vmAttributesFromWord(getSyscallArg(2, buffer));
        vspaceCap = extraCaps.excaprefs[0]->cap;

        frameSize = cap_frame_cap_get_capFSize(cap);
        capVMRights = cap_frame_cap_get_capFVMRights(cap);

        if (cap_frame_cap_get_capFMappedObject(cap) != 0) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1525, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32Frame: Frame already mapped."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;

            return EXCEPTION_SYSCALL_ERROR;
        }

        vmRights = maskVMRights(capVMRights, rightsFromWord(w_rightsMask));

        if (!checkVPAlignment(frameSize, vaddr)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1535, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32Frame: Alignment error when mapping"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_AlignmentError;

            return EXCEPTION_SYSCALL_ERROR;
        }

        if (isVTableRoot(vspaceCap)) {
            return decodeIA32PDFrameMap(vspaceCap, cte, cap, vmRights, vmAttr, vaddr);

        } else if (cap_get_capType(vspaceCap) == cap_ept_page_directory_pointer_table_cap) {
            return decodeIA32EPTFrameMap(vspaceCap, cte, cap, vmRights, vmAttr, vaddr);

        } else {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1548, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32Frame: Attempting to map frame into invalid page directory cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 1;

            return EXCEPTION_SYSCALL_ERROR;
        }


        return EXCEPTION_NONE;
    }

    case IA32PageUnmap: { /* Unmap */
        if (cap_frame_cap_get_capFMappedObject(cap)) {
            switch (cap_frame_cap_get_capFMappedType(cap)) {
            case IA32_MAPPING_PD:
                IA32PageUnmapPD(cap);
                break;

            case IA32_MAPPING_EPT:
                IA32PageUnmapEPT(cap);
                break;


            case IA32_MAPPING_IO:
                unmapIOPage(cap);
                break;

            default:
                _fail("Unknown mapping type for frame", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1576, __func__);
            }
        }
        cap = cap_frame_cap_set_capFMappedObject(cap, 0);
        cdtUpdate(cte, cap);

        setThreadState(ksCurThread, ThreadState_Restart);
        return EXCEPTION_NONE;
    }


    case IA32PageMapIO: { /* MapIO */
        return decodeIA32IOMapInvocation(label, length, cte, cap, extraCaps, buffer);
    }


    case IA32PageGetAddress: {
        /* Return it in the first message register. */
        if(!(n_msgRegisters >= 1)) _assert_fail("n_msgRegisters >= 1", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1594, __FUNCTION__);

        setThreadState(ksCurThread, ThreadState_Restart);
        return performPageGetAddress((void*)cap_frame_cap_get_capFBasePtr(cap));
    }

    default:
        current_syscall_error.type = seL4_IllegalOperation;

        return EXCEPTION_SYSCALL_ERROR;
    }
}

exception_t
decodeIA32MMUInvocation(
    word_t label,
    unsigned int length,
    cptr_t cptr,
    cte_t* cte,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    switch (cap_get_capType(cap)) {
    case cap_pdpt_cap:
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;

    case cap_page_directory_cap:
        return decodeIA32PageDirectoryInvocation(label, length, cte, cap, extraCaps, buffer);

    case cap_page_table_cap:
        return decodeIA32PageTableInvocation(label, length, cte, cap, extraCaps, buffer);

    case cap_frame_cap:
        return decodeIA32FrameInvocation(label, length, cte, cap, extraCaps, buffer);

    default:
        _fail("Invalid arch cap type", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1633, __func__);
    }
}


struct lookupEPTPDSlot_ret {
    exception_t status;
    ept_pde_t* pd;
    uint32_t pdIndex;
};
typedef struct lookupEPTPDSlot_ret lookupEPTPDSlot_ret_t;

struct lookupEPTPTSlot_ret {
    exception_t status;
    ept_pte_t* pt;
    uint32_t ptIndex;
};
typedef struct lookupEPTPTSlot_ret lookupEPTPTSlot_ret_t;

static ept_pdpte_t* __attribute__((__const__)) lookupEPTPDPTSlot(ept_pdpte_t *pdpt, vptr_t vptr)
{
    unsigned int pdptIndex;

    pdptIndex = vptr >> (IA32_4K_bits + 9 + 9);
    return pdpt + pdptIndex;
}

static lookupEPTPDSlot_ret_t lookupEPTPDSlot(ept_pdpte_t* pdpt, vptr_t vptr)
{
    lookupEPTPDSlot_ret_t ret;
    ept_pdpte_t* pdptSlot;

    pdptSlot = lookupEPTPDPTSlot(pdpt, vptr);

    if (!ept_pdpte_ptr_get_read(pdptSlot)) {
        current_lookup_fault = lookup_fault_missing_capability_new(22);

        ret.pd = ((void *)0);
        ret.pdIndex = 0;
        ret.status = EXCEPTION_LOOKUP_FAULT;
        return ret;
    } else {
        ret.pd = paddr_to_pptr(ept_pdpte_ptr_get_pd_base_address(pdptSlot));
        ret.pdIndex = (vptr >> (IA32_4K_bits + 9)) & ((1ul<<(9))-1ul);

        ret.status = EXCEPTION_NONE;
        return ret;
    }
}

static lookupEPTPTSlot_ret_t lookupEPTPTSlot(ept_pdpte_t* pdpt, vptr_t vptr)
{
    lookupEPTPTSlot_ret_t ret;
    lookupEPTPDSlot_ret_t lu_ret;
    ept_pde_t *pdSlot;

    lu_ret = lookupEPTPDSlot(pdpt, vptr);
    if (lu_ret.status != EXCEPTION_NONE) {
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = false;
        /* current_lookup_fault will have been set by lookupEPTPDSlot */
        ret.pt = ((void *)0);
        ret.ptIndex = 0;
        ret.status = EXCEPTION_LOOKUP_FAULT;
        return ret;
    }

    pdSlot = lu_ret.pd + lu_ret.pdIndex;

    if ((ept_pde_ptr_get_page_size(pdSlot) != ept_pde_ept_pde_4k) ||
            !ept_pde_ept_pde_4k_ptr_get_read(pdSlot)) {
        current_lookup_fault = lookup_fault_missing_capability_new(22);

        ret.pt = ((void *)0);
        ret.ptIndex = 0;
        ret.status = EXCEPTION_LOOKUP_FAULT;
        return ret;
    } else {
        ret.pt = paddr_to_pptr(ept_pde_ept_pde_4k_ptr_get_pt_base_address(pdSlot));
        ret.ptIndex = (vptr >> (IA32_4K_bits)) & ((1ul<<(9))-1ul);

        ret.status = EXCEPTION_NONE;
        return ret;
    }
}

ept_pdpte_t *lookupEPTPDPTFromPD(ept_pde_t *pd)
{
    cte_t *pd_cte;

    /* First query the cdt and find the cap */
    pd_cte = cdtFindWithExtra(cap_ept_page_directory_cap_new(0, 0, ((unsigned int)(pd))));
    /* We will not be returned a slot if there was no 'extra' information (aka if it is not mapped) */
    if (!pd_cte) {
        return ((void *)0);
    }

    /* Return the mapping information from the cap. */
    return ((ept_pdpte_t *)(cap_ept_page_directory_cap_get_capPDMappedObject(pd_cte->cap)));
}

static ept_pdpte_t *lookupEPTPDPTFromPT(ept_pte_t *pt)
{
    cte_t *pt_cte;
    cap_t pt_cap;
    ept_pde_t *pd;

    /* First query the cdt and find the cap */
    pt_cte = cdtFindWithExtra(cap_ept_page_table_cap_new(0, 0, ((unsigned int)(pt))));
    /* We will not be returned a slot if there was no 'extra' information (aka if it is not mapped) */
    if (!pt_cte) {
        return ((void *)0);
    }

    /* Get any mapping information from the cap */
    pt_cap = pt_cte->cap;
    pd = ((ept_pde_t *)(cap_ept_page_table_cap_get_capPTMappedObject(pt_cap)));
    /* If we found it then it *should* have information */
    if(!(pd)) _assert_fail("pd", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1751, __FUNCTION__);
    /* Now lookup the PDPT from the PD */
    return lookupEPTPDPTFromPD(pd);
}

void unmapEPTPD(ept_pdpte_t *pdpt, uint32_t index, ept_pde_t *pd)
{
    pdpt[index] = ept_pdpte_new(
                      0, /* pd_base_address  */
                      0, /* avl_cte_depth    */
                      0, /* execute          */
                      0, /* write            */
                      0 /* read             */
                  );
}

void unmapEPTPT(ept_pde_t *pd, uint32_t index, ept_pte_t *pt)
{
    pd[index] = ept_pde_ept_pde_4k_new(
                    0, /* pt_base_address  */
                    0, /* avl_cte_depth    */
                    0, /* execute          */
                    0, /* write            */
                    0 /* read             */
                );
}

void unmapAllEPTPD(ept_pdpte_t *pdpt)
{
    uint32_t i;

    for (i = 0; i < (1ul<<(9)); i++) {
        ept_pdpte_t *pdpte = pdpt + i;
        if (ept_pdpte_ptr_get_pd_base_address(pdpte)) {
            cap_t cap;
            cte_t *pdCte;

            ept_pde_t *pd = ((ept_pde_t *)(paddr_to_pptr(ept_pdpte_ptr_get_pd_base_address(pdpte))));
            uint32_t depth = ept_pdpte_ptr_get_avl_cte_depth(pdpte);
            pdCte = cdtFindAtDepth(cap_ept_page_directory_cap_new(((unsigned int)(pdpt)), i, ((unsigned int)(pd))), depth);
            if(!(pdCte)) _assert_fail("pdCte", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1791, __FUNCTION__);

            cap = pdCte->cap;
            cap = cap_ept_page_directory_cap_set_capPDMappedObject(cap, 0);
            cdtUpdate(pdCte, cap);
        }
    }
}

void unmapAllEPTPT(ept_pde_t *pd)
{
    uint32_t i;

    for (i = 0; i < (1ul<<(9)); i++) {
        ept_pde_t *pde = pd + i;
        switch (ept_pde_ptr_get_page_size(pde)) {
        case ept_pde_ept_pde_4k:
            if (ept_pde_ept_pde_4k_ptr_get_pt_base_address(pde)) {
                cap_t cap;
                cte_t *ptCte;

                ept_pte_t *pt = ((ept_pte_t *)(paddr_to_pptr(ept_pde_ept_pde_4k_ptr_get_pt_base_address(pde))));
                uint32_t depth = ept_pde_ept_pde_4k_ptr_get_avl_cte_depth(pde);
                ptCte = cdtFindAtDepth(cap_ept_page_table_cap_new(((unsigned int)(pd)), i, ((unsigned int)(pt))), depth);
                if(!(ptCte)) _assert_fail("ptCte", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1815, __FUNCTION__);

                cap = ptCte->cap;
                cap = cap_ept_page_table_cap_set_capPTMappedObject(cap, 0);
                cdtUpdate(ptCte, cap);
            }
            break;
        case ept_pde_ept_pde_2m:
            if (ept_pde_ept_pde_2m_ptr_get_page_base_address(pde)) {
                cap_t newCap;
                cte_t *frameCte;

                void *frame = paddr_to_pptr(ept_pde_ept_pde_2m_ptr_get_page_base_address(pde));
                uint32_t depth = ept_pde_ept_pde_2m_ptr_get_avl_cte_depth(pde);
                frameCte = cdtFindAtDepth(cap_frame_cap_new(IA32_LargePage, ((unsigned int)(pd)), i, IA32_MAPPING_EPT, 0, (uint32_t)frame), depth);
                if(!(frameCte)) _assert_fail("frameCte", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1830, __FUNCTION__);

                newCap = cap_frame_cap_set_capFMappedObject(frameCte->cap, 0);
                cdtUpdate(frameCte, newCap);
                if (IA32_4M_bits == IA32_4M_bits) {
                    /* If we found a 2m mapping then the next entry will be the other half
                    * of this 4M frame, so skip it */
                    i++;
                }
            }
            break;
        default:
            _fail("Unknown EPT PDE page size", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1842, __func__);
        }
    }
}

void unmapAllEPTPages(ept_pte_t *pt)
{
    uint32_t i;

    for (i = 0; i < (1ul<<(9)); i++) {
        ept_pte_t *pte = pt + i;
        if (ept_pte_ptr_get_page_base_address(pte)) {
            cap_t newCap;
            cte_t *frameCte;

            void *frame = paddr_to_pptr(ept_pte_ptr_get_page_base_address(pte));
            uint32_t depth = ept_pte_ptr_get_avl_cte_depth(pte);
            frameCte = cdtFindAtDepth(cap_frame_cap_new(IA32_SmallPage, ((unsigned int)(pt)), i, IA32_MAPPING_EPT, 0, (uint32_t)frame), depth);
            if(!(frameCte)) _assert_fail("frameCte", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1860, __FUNCTION__);

            newCap = cap_frame_cap_set_capFMappedObject(frameCte->cap, 0);
            cdtUpdate(frameCte, newCap);
        }
    }
}

enum ept_cache_options {
    EPTUncacheable = 0,
    EPTWriteCombining = 1,
    EPTWriteThrough = 4,
    EPTWriteProtected = 5,
    EPTWriteBack = 6
};
typedef enum ept_cache_options ept_cache_options_t;

static ept_cache_options_t
eptCacheFromVmAttr(vm_attributes_t vmAttr)
{
    /* PAT cache options are 1-1 with ept_cache_options. But need to
       verify user has specified a sensible option */
    ept_cache_options_t option = vmAttr.words[0];
    if (option != EPTUncacheable ||
            option != EPTWriteCombining ||
            option != EPTWriteThrough ||
            option != EPTWriteBack) {
        /* No failure mode is supported here, vmAttr settings should be verified earlier */
        option = EPTWriteBack;
    }
    return option;
}

exception_t
decodeIA32EPTInvocation(
    word_t label,
    unsigned int length,
    cptr_t cptr,
    cte_t* cte,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    switch (cap_get_capType(cap)) {
    case cap_ept_page_directory_pointer_table_cap:
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    case cap_ept_page_directory_cap:
        return decodeIA32EPTPageDirectoryInvocation(label, length, cte, cap, extraCaps, buffer);
    case cap_ept_page_table_cap:
        return decodeIA32EPTPageTableInvocation(label, length, cte, cap, extraCaps, buffer);
    default:
        _fail("Invalid cap type", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 1913, __func__);
    }
}

exception_t
decodeIA32EPTPageDirectoryInvocation(
    word_t label,
    unsigned int length,
    cte_t* cte,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    word_t vaddr;
    word_t pdptIndex;
    cap_t pdptCap;
    ept_pdpte_t* pdpt;
    ept_pdpte_t* pdptSlot;
    ept_pdpte_t pdpte;
    paddr_t paddr;


    if (label == IA32EPTPageDirectoryUnmap) {
        setThreadState(ksCurThread, ThreadState_Restart);

        pdpt = ((ept_pdpte_t *)(cap_ept_page_directory_cap_get_capPDMappedObject(cap)));
        if (pdpt) {
            ept_pde_t* pd = (ept_pde_t*)cap_ept_page_directory_cap_get_capPDBasePtr(cap);
            unmapEPTPD(pdpt, cap_ept_page_directory_cap_get_capPDMappedIndex(cap), pd);
            invept((void*)((uint32_t)pdpt - (1 << (9 +3))));
        }

        cap = cap_ept_page_directory_cap_set_capPDMappedObject(cap, 0);
        cdtUpdate(cte, cap);

        return EXCEPTION_NONE;
    }

    if (label != IA32EPTPageDirectoryMap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1953, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTPageDirectory Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (length < 2 || extraCaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1959, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTPageDirectoryMap: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (cap_ept_page_directory_cap_get_capPDMappedObject(cap)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1965, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTPageDirectoryMap: EPT Page directory is already mapped to an EPT page directory pointer table."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type =
            seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;

        return EXCEPTION_SYSCALL_ERROR;
    }

    vaddr = getSyscallArg(0, buffer);
    pdptCap = extraCaps.excaprefs[0]->cap;

    if (cap_get_capType(pdptCap) != cap_ept_page_directory_pointer_table_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1977, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTPageDirectoryMap: Not a valid EPT page directory pointer table."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 1;

        return EXCEPTION_SYSCALL_ERROR;
    }

    pdpt = (ept_pdpte_t*)cap_ept_page_directory_pointer_table_cap_get_capPDPTBasePtr(pdptCap);

    if (vaddr >= 0xe0000000) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1987, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTPageDirectoryMap: vaddr not in kernel window."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 0;

        return EXCEPTION_SYSCALL_ERROR;
    }

    pdptIndex = vaddr >> (IA32_4K_bits + 9 + 9);
    pdptSlot = &pdpt[pdptIndex];

    if (ept_pdpte_ptr_get_read(pdptSlot)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 1998, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTPageDirectoryMap: Page directory already mapped here."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_DeleteFirst;
        return EXCEPTION_SYSCALL_ERROR;
    }

    paddr = pptr_to_paddr((void*)(cap_ept_page_directory_cap_get_capPDBasePtr(cap)));
    pdpte = ept_pdpte_new(
                paddr, /* pd_base_address  */
                mdb_node_get_cdtDepth(cte->cteMDBNode), /* avl_cte_depth    */
                1, /* execute          */
                1, /* write            */
                1 /* read             */
            );

    cap = cap_ept_page_directory_cap_set_capPDMappedObject(cap, ((unsigned int)(pdpt)));
    cap = cap_ept_page_directory_cap_set_capPDMappedIndex(cap, pdptIndex);

    cdtUpdate(cte, cap);

    *pdptSlot = pdpte;
    invept((void*)((uint32_t)pdpt - (1 << (9 +3))));

    setThreadState(ksCurThread, ThreadState_Restart);
    return EXCEPTION_NONE;
}

exception_t
decodeIA32EPTPageTableInvocation(
    word_t label,
    unsigned int length,
    cte_t* cte,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    word_t vaddr;
    cap_t pdptCap;
    ept_pdpte_t* pdpt;
    ept_pde_t* pd;
    unsigned int pdIndex;
    ept_pde_t* pdSlot;
    ept_pde_t pde;
    paddr_t paddr;
    lookupEPTPDSlot_ret_t lu_ret;

    if (label == IA32EPTPageTableUnmap) {
        setThreadState(ksCurThread, ThreadState_Restart);

        pd = ((ept_pde_t *)(cap_ept_page_table_cap_get_capPTMappedObject(cap)));
        if (pd) {
            ept_pte_t* pt = (ept_pte_t*)cap_ept_page_table_cap_get_capPTBasePtr(cap);
            unmapEPTPT(pd, cap_ept_page_table_cap_get_capPTMappedIndex(cap), pt);
            pdpt = lookupEPTPDPTFromPD(pd);
            if (pdpt) {
                invept((void*)((uint32_t)pdpt - (1 << (9 +3))));
            }
        }

        cap = cap_ept_page_table_cap_set_capPTMappedObject(cap, 0);
        cdtUpdate(cte, cap);

        return EXCEPTION_NONE;
    }

    if (label != IA32EPTPageTableMap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 2064, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTPageTable Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (length < 2 || extraCaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 2070, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTPageTable: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (cap_ept_page_table_cap_get_capPTMappedObject(cap)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 2076, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTPageTable EPT Page table is already mapped to an EPT page directory."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type =
            seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;

        return EXCEPTION_SYSCALL_ERROR;
    }

    vaddr = getSyscallArg(0, buffer);
    pdptCap = extraCaps.excaprefs[0]->cap;

    if (cap_get_capType(pdptCap) != cap_ept_page_directory_pointer_table_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 2088, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTPageTableMap: Not a valid EPT page directory pointer table."); kprintf(">>" "\033[0m" "\n"); } while (0);
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 2089, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32ASIDPool: Invalid vspace root."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 1;

        return EXCEPTION_SYSCALL_ERROR;
    }

    pdpt = (ept_pdpte_t*)(cap_ept_page_directory_pointer_table_cap_get_capPDPTBasePtr(pdptCap));

    if (vaddr >= 0xe0000000) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 2099, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTPageTableMap: vaddr not in kernel window."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 0;

        return EXCEPTION_SYSCALL_ERROR;
    }

    lu_ret = lookupEPTPDSlot(pdpt, vaddr);
    if (lu_ret.status != EXCEPTION_NONE) {
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = false;
        /* current_lookup_fault will have been set by lookupPTSlot */
        return EXCEPTION_SYSCALL_ERROR;
    }

    pd = lu_ret.pd;
    pdIndex = lu_ret.pdIndex;
    pdSlot = pd + pdIndex;

    if (((ept_pde_ptr_get_page_size(pdSlot) == ept_pde_ept_pde_4k) &&
            ept_pde_ept_pde_4k_ptr_get_read(pdSlot)) ||
            ((ept_pde_ptr_get_page_size(pdSlot) == ept_pde_ept_pde_2m) &&
             ept_pde_ept_pde_2m_ptr_get_read(pdSlot))) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 2122, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTPageTableMap: Page table already mapped here"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_DeleteFirst;
        return EXCEPTION_SYSCALL_ERROR;
    }

    paddr = pptr_to_paddr((void*)(cap_ept_page_table_cap_get_capPTBasePtr(cap)));
    pde = ept_pde_ept_pde_4k_new(
              paddr, /* pt_base_address  */
              mdb_node_get_cdtDepth(cte->cteMDBNode), /* avl_cte_depth    */
              1, /* execute          */
              1, /* write            */
              1 /* read             */
          );

    cap = cap_ept_page_table_cap_set_capPTMappedObject(cap, ((unsigned int)(pd)));
    cap = cap_ept_page_table_cap_set_capPTMappedIndex(cap, pdIndex);

    cdtUpdate(cte, cap);

    *pdSlot = pde;
    invept((void*)((uint32_t)pdpt - (1 << (9 +3))));

    setThreadState(ksCurThread, ThreadState_Restart);
    return EXCEPTION_NONE;
}

static exception_t
decodeIA32EPTFrameMap(
    cap_t pdptCap,
    cte_t *cte,
    cap_t cap,
    vm_rights_t vmRights,
    vm_attributes_t vmAttr,
    word_t vaddr)
{
    paddr_t paddr;
    ept_pdpte_t* pdpt;
    vm_page_size_t frameSize;

    frameSize = cap_frame_cap_get_capFSize(cap);
    pdpt = (ept_pdpte_t*)(cap_ept_page_directory_pointer_table_cap_get_capPDPTBasePtr(pdptCap));

    paddr = pptr_to_paddr((void*)cap_frame_cap_get_capFBasePtr(cap));

    switch (frameSize) {
        /* PTE mappings */
    case IA32_SmallPage: {
        lookupEPTPTSlot_ret_t lu_ret;
        ept_pte_t *ptSlot;

        lu_ret = lookupEPTPTSlot(pdpt, vaddr);
        if (lu_ret.status != EXCEPTION_NONE) {
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = false;
            /* current_lookup_fault will have been set by lookupEPTPTSlot */
            return EXCEPTION_SYSCALL_ERROR;
        }

        ptSlot = lu_ret.pt + lu_ret.ptIndex;

        if (ept_pte_ptr_get_page_base_address(ptSlot) != 0) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 2183, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTFrameMap: Mapping already present."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_DeleteFirst;
            return EXCEPTION_SYSCALL_ERROR;
        }

        *ptSlot = ept_pte_new(
                      paddr,
                      mdb_node_get_cdtDepth(cte->cteMDBNode),
                      0,
                      eptCacheFromVmAttr(vmAttr),
                      1,
                      WritableFromVMRights(vmRights),
                      1);

        invept((void*)((uint32_t)pdpt - (1 << (9 +3))));

        cap = cap_frame_cap_set_capFMappedObject(cap, ((unsigned int)(lu_ret.pt)));
        cap = cap_frame_cap_set_capFMappedIndex(cap, lu_ret.ptIndex);
        cap = cap_frame_cap_set_capFMappedType(cap, IA32_MAPPING_EPT);
        cdtUpdate(cte, cap);

        setThreadState(ksCurThread, ThreadState_Restart);
        return EXCEPTION_NONE;
    }

    /* PDE mappings */
    case IA32_LargePage: {
        lookupEPTPDSlot_ret_t lu_ret;
        ept_pde_t *pdSlot;

        lu_ret = lookupEPTPDSlot(pdpt, vaddr);
        if (lu_ret.status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 2215, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTFrameMap: Need a page directory first."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = false;
            /* current_lookup_fault will have been set by lookupEPTPDSlot */
            return EXCEPTION_SYSCALL_ERROR;
        }

        pdSlot = lu_ret.pd + lu_ret.pdIndex;

        if ((ept_pde_ptr_get_page_size(pdSlot) == ept_pde_ept_pde_4k) &&
                ept_pde_ept_pde_4k_ptr_get_read(pdSlot)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 2226, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTFrameMap: Page table already present."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_DeleteFirst;
            return EXCEPTION_SYSCALL_ERROR;
        }
        if ((ept_pde_ptr_get_page_size(pdSlot + 1) == ept_pde_ept_pde_4k) &&
                ept_pde_ept_pde_4k_ptr_get_read(pdSlot + 1)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 2232, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTFrameMap: Page table already present."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_DeleteFirst;
            return EXCEPTION_SYSCALL_ERROR;
        }
        if ((ept_pde_ptr_get_page_size(pdSlot) == ept_pde_ept_pde_2m) &&
                ept_pde_ept_pde_2m_ptr_get_read(pdSlot)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 2238, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32EPTFrameMap: Mapping already present."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_DeleteFirst;
            return EXCEPTION_SYSCALL_ERROR;
        }

        if (IA32_4M_bits == IA32_4M_bits) {
            pdSlot[1] = ept_pde_ept_pde_2m_new(
                            paddr + (1 << 21),
                            mdb_node_get_cdtDepth(cte->cteMDBNode),
                            0,
                            eptCacheFromVmAttr(vmAttr),
                            1,
                            WritableFromVMRights(vmRights),
                            1);
        }
        pdSlot[0] = ept_pde_ept_pde_2m_new(
                        paddr,
                        mdb_node_get_cdtDepth(cte->cteMDBNode),
                        0,
                        eptCacheFromVmAttr(vmAttr),
                        1,
                        WritableFromVMRights(vmRights),
                        1);

        invept((void*)((uint32_t)pdpt - (1 << (9 +3))));

        cap = cap_frame_cap_set_capFMappedObject(cap, ((unsigned int)(lu_ret.pd)));
        cap = cap_frame_cap_set_capFMappedIndex(cap, lu_ret.pdIndex);
        cap = cap_frame_cap_set_capFMappedType(cap, IA32_MAPPING_EPT);
        cdtUpdate(cte, cap);

        setThreadState(ksCurThread, ThreadState_Restart);
        return EXCEPTION_NONE;
    }

    default:
        _fail("Invalid page type", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 2274, __func__);
    }
}

void IA32EptPdpt_Init(ept_pml4e_t * pdpt)
{
    /* Map in a PDPT for the 512GB region. */
    pdpt[0] = ept_pml4e_new(
                  pptr_to_paddr((void*)(pdpt + (1ul<<(9)))),
                  1,
                  1,
                  1
              );
    invept(pdpt);
}

void IA32PageUnmapEPT(cap_t cap)
{
    void *object = (void*)cap_frame_cap_get_capFMappedObject(cap);
    uint32_t index = cap_frame_cap_get_capFMappedIndex(cap);
    ept_pdpte_t *pdpt;
    switch (cap_frame_cap_get_capFSize(cap)) {
    case IA32_SmallPage: {
        ept_pte_t *pt = ((ept_pte_t *)(object));
        pt[index] = ept_pte_new(0, 0, 0, 0, 0, 0, 0);
        pdpt = lookupEPTPDPTFromPT(pt);
        break;
    }
    case IA32_LargePage: {
        ept_pde_t *pd = ((ept_pde_t *)(object));
        pd[index] = ept_pde_ept_pde_2m_new(0, 0, 0, 0, 0, 0, 0);
        if (IA32_4M_bits == IA32_4M_bits) {
            pd[index + 1] = ept_pde_ept_pde_2m_new(0, 0, 0, 0, 0, 0, 0);
        }
        pdpt = lookupEPTPDPTFromPD(pd);
        break;
    }
    default:
        _fail("Invalid page type", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace.c", 2312, __func__);
    }
    if (pdpt) {
        invept((void*)((uint32_t)pdpt - (1 << (9 +3))));
    }
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c" 2
# 1 "./arch/api/invocation.h" 1
/* @LICENSE(OKL_CORE) */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/apic.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c" 2



/* setup initial boot page directory */

/* The boot pd is referenced by code that runs before paging, so
 * place it in PHYS_DATA */
pde_t _boot_pd[(1ul<<(10))] __attribute__((aligned((1ul<<(IA32_4K_bits))))) __attribute__((__section__(".phys.data")));

__attribute__((__section__(".boot.text")))
pde_t *get_boot_pd()
{
    return _boot_pd;
}

/* This function is duplicated from pde_pde_large_ptr_new, generated by the
 * bitfield tool in structures_gen.h. It is required by functions that need to
 * call it before the MMU is turned on. Any changes made to the bitfield
 * generation need to be replicated here.
 */
__attribute__((__section__(".phys.text")))
static inline void
pde_pde_large_ptr_new_phys(pde_t *pde_ptr, uint32_t page_base_address,
                           uint32_t pat, uint32_t avl, uint32_t global, uint32_t dirty,
                           uint32_t accessed, uint32_t cache_disabled, uint32_t write_through,
                           uint32_t super_user, uint32_t read_write, uint32_t present)
{
    pde_ptr->words[0] = 0;

    pde_ptr->words[0] |= (page_base_address & 0xffc00000) >> 0;
    pde_ptr->words[0] |= (pat & 0x1) << 12;
    pde_ptr->words[0] |= (avl & 0x7) << 9;
    pde_ptr->words[0] |= (global & 0x1) << 8;
    pde_ptr->words[0] |= (pde_pde_large & 0x1) << 7;
    pde_ptr->words[0] |= (dirty & 0x1) << 6;
    pde_ptr->words[0] |= (accessed & 0x1) << 5;
    pde_ptr->words[0] |= (cache_disabled & 0x1) << 4;
    pde_ptr->words[0] |= (write_through & 0x1) << 3;
    pde_ptr->words[0] |= (super_user & 0x1) << 2;
    pde_ptr->words[0] |= (read_write & 0x1) << 1;
    pde_ptr->words[0] |= (present & 0x1) << 0;
}

__attribute__((__section__(".phys.text"))) __attribute__((externally_visible)) void
init_boot_pd(void)
{
    unsigned int i;

    /* identity mapping from 0 up to PPTR_BASE (virtual address) */
    for (i = 0; i < (0xe0000000 >> IA32_4M_bits); i++) {
        pde_pde_large_ptr_new_phys(
            _boot_pd + i,
            i << IA32_4M_bits, /* physical address */
            0, /* pat            */
            0, /* avl            */
            1, /* global         */
            0, /* dirty          */
            0, /* accessed       */
            0, /* cache_disabled */
            0, /* write_through  */
            0, /* super_user     */
            1, /* read_write     */
            1 /* present        */
        );
    }

    /* mapping of PPTR_BASE (virtual address) to PADDR_BASE up to end of virtual address space */
    for (i = 0; i < ((-0xe0000000) >> IA32_4M_bits); i++) {
        pde_pde_large_ptr_new_phys(
            _boot_pd + i + (0xe0000000 >> IA32_4M_bits),
            (i << IA32_4M_bits) + 0x00000000, /* physical address */
            0, /* pat            */
            0, /* avl            */
            1, /* global         */
            0, /* dirty          */
            0, /* accessed       */
            0, /* cache_disabled */
            0, /* write_through  */
            0, /* super_user     */
            1, /* read_write     */
            1 /* present        */
        );
    }
}

__attribute__((__section__(".boot.text"))) void
map_it_pd_cap(cap_t pd_cap)
{
    /* this shouldn't be called, and it does nothing */
    _fail("Should not be called", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_32.c", 112, __func__);
}

/* ==================== BOOT CODE FINISHES HERE ==================== */

lookupPDSlot_ret_t lookupPDSlot(void *vspace, vptr_t vptr)
{
    lookupPDSlot_ret_t pdSlot;
    pde_t *pd = ((pde_t *)(vspace));
    unsigned int pdIndex;

    pdIndex = vptr >> (IA32_4K_bits + 10);
    pdSlot.status = EXCEPTION_NONE;
    pdSlot.pdSlot = pd + pdIndex;
    pdSlot.pd = pd;
    pdSlot.pdIndex = pdIndex;
    return pdSlot;
}

bool_t __attribute__((__const__)) isVTableRoot(cap_t cap)
{
    return cap_get_capType(cap) == cap_page_directory_cap;
}

bool_t __attribute__((__const__)) isValidNativeRoot(cap_t cap)
{
    return isVTableRoot(cap);
}

bool_t __attribute__((__const__)) isValidVTableRoot(cap_t cap)
{

    if (cap_get_capType(cap) == cap_ept_page_directory_pointer_table_cap) {
        return true;
    }

    return isValidNativeRoot(cap);
}

void *getValidNativeRoot(cap_t vspace_cap)
{
    if (isValidNativeRoot(vspace_cap)) {
        return ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(vspace_cap)));
    }
    return ((void *)0);
}

void copyGlobalMappings(void* new_vspace)
{
    unsigned int i;
    pde_t *newPD = (pde_t*)new_vspace;

    for (i = 0xe0000000 >> IA32_4M_bits; i < (1ul<<(10)); i++) {
        newPD[i] = ia32KSkernelPD[i];
    }
}

void unmapPageDirectory(pdpte_t *pdpt, uint32_t pdptIndex, pde_t *pd)
{
}

void unmapAllPageDirectories(pdpte_t *pdpt)
{
}

void flushAllPageDirectories(pdpte_t *pdpt)
{
}

void flushPageSmall(pte_t *pt, uint32_t ptIndex)
{
    cap_t threadRoot;
    cte_t *ptCte;
    pde_t *pd;
    uint32_t pdIndex;

    /* We know this pt can only be mapped into one single pd. So
     * lets find a cap with that mapping information */
    ptCte = cdtFindWithExtra(cap_page_table_cap_new(0, 0, ((unsigned int)(pt))));
    if (ptCte) {
        pd = ((pde_t *)(cap_page_table_cap_get_capPTMappedObject(ptCte->cap)));
        pdIndex = cap_page_table_cap_get_capPTMappedIndex(ptCte->cap);

        /* check if page belongs to current address space */
        threadRoot = (((cte_t *)((unsigned int)(ksCurThread)&~((1ul<<(10))-1ul)))+(tcbVTable))->cap;
        if (isValidNativeRoot(threadRoot) && (void*)(pptr_t)cap_get_capPtr(threadRoot) == pd) {
            invalidateTLBentry( (pdIndex << (10 + IA32_4K_bits)) | (ptIndex << IA32_4K_bits));
            invalidatePageStructureCache();
        }
    }
}

void flushPageLarge(pde_t *pd, uint32_t pdIndex)
{
    cap_t threadRoot;

    /* check if page belongs to current address space */
    threadRoot = (((cte_t *)((unsigned int)(ksCurThread)&~((1ul<<(10))-1ul)))+(tcbVTable))->cap;
    if (cap_get_capType(threadRoot) == cap_page_directory_cap &&
            ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(threadRoot))) == pd) {
        invalidateTLBentry(pdIndex << (10 + IA32_4K_bits));
        invalidatePageStructureCache();
    }
}

void flushAllPageTables(pde_t *pd)
{
    cap_t threadRoot;
    /* check if this is the current address space */
    threadRoot = (((cte_t *)((unsigned int)(ksCurThread)&~((1ul<<(10))-1ul)))+(tcbVTable))->cap;
    if (cap_get_capType(threadRoot) == cap_page_directory_cap &&
            ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(threadRoot))) == pd) {
        invalidateTLB();
    }
    invalidatePageStructureCache();
}

void flushPageDirectory(pdpte_t *pdpt, uint32_t pdptIndex, pde_t *pd)
{
    flushAllPageTables(pd);
}

exception_t
decodeIA32PageDirectoryInvocation(
    word_t label,
    unsigned int length,
    cte_t* cte,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    current_syscall_error.type = seL4_IllegalOperation;
    return EXCEPTION_SYSCALL_ERROR;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_pae.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_pae.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_pae.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_pae.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_pae.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/kernel/vspace_pae.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/capdl.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/capdl.c" 2



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/capdl.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/capdl.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/capdl.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/capdl.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/capdl.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/capdl.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/capdl.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/debug_helpers.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




void putDebugChar(unsigned char a);
unsigned char getDebugChar(void);
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/capdl.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/capdl.c" 2







static int getDecodedChar(unsigned char *result)
{
    unsigned char c;
    c = getDebugChar();
    if (c == 0xff) {
        return 1;
    }
    if (c == 0xaa) {
        c = getDebugChar();
        if (c == 0xff) {
            return 1;
        }
        switch (c) {
        case 0xa1:
            *result = 0xaa;
            break;
        case 0xa0:
            *result = 0xff;
            break;
        case 0xa2:
            *result = 0xbb;
            break;
        default:
            if (c >= 20 && c < 40) {
                *result = c - 20;
            }
        }
        return 0;
    } else {
        *result = c;
        return 0;
    }
}

static void putEncodedChar(unsigned char c)
{
    switch (c) {
    case 0xaa:
        putDebugChar(0xaa);
        putDebugChar(0xa1);
        break;
    case 0xff:
        putDebugChar(0xaa);
        putDebugChar(0xa0);
        break;
    case 0xbb:
        putDebugChar(0xaa);
        putDebugChar(0xa2);
        break;
    default:
        if (c < 20) {
            putDebugChar(0xaa);
            putDebugChar(c + 20);
        } else {
            putDebugChar(c);
        }
    }
}

static int getArg32(unsigned int *res)
{
    unsigned char b1 = 0;
    unsigned char b2 = 0;
    unsigned char b3 = 0;
    unsigned char b4 = 0;
    if (getDecodedChar(&b1)) {
        return 1;
    }
    if (getDecodedChar(&b2)) {
        return 1;
    }
    if (getDecodedChar(&b3)) {
        return 1;
    }
    if (getDecodedChar(&b4)) {
        return 1;
    }
    *res = (b1 << 24 ) | (b2 << 16) | (b3 << 8) | b4;
    return 0;
}

static void sendWord(unsigned int word)
{
    putEncodedChar(word & 0xff);
    putEncodedChar((word >> 8) & 0xff);
    putEncodedChar((word >> 16) & 0xff);
    putEncodedChar((word >> 24) & 0xff);
}

static void sendPD(unsigned int address)
{
    unsigned int i;
    unsigned int exists;
    pde_t *start = (pde_t *)address;
    for (i = 0; i < (1ul<<(10)); i++) {
        pde_t pde = start[i];
        exists = 1;
        if (pde_get_page_size(pde) == pde_pde_small && (pde_pde_small_get_pt_base_address(pde) == 0 ||
                                                        !pde_pde_small_get_present(pde) || !pde_pde_small_get_super_user(pde))) {
            exists = 0;
        } else if (pde_get_page_size(pde) == pde_pde_large && (pde_pde_large_get_page_base_address(pde) == 0 ||
                                                               !pde_pde_large_get_present(pde) || !pde_pde_large_get_super_user(pde))) {
            exists = 0;
        }
        if (exists != 0 && i < 0xe0000000 >> pageBitsForSize(IA32_LargePage)) {
            sendWord(i);
            sendWord(pde.words[0]);
        }
    }
}

static void sendPT(unsigned int address)
{
    unsigned int i;
    pte_t *start = (pte_t *)address;
    for (i = 0; i < (1ul<<(10)); i++) {
        pte_t pte = start[i];
        if (pte_get_page_base_address(pte) != 0 && pte_get_present(pte) && pte_get_super_user(pte)) {
            sendWord(i);
            sendWord(pte.words[0]);
        }
    }
}



static void sendIOPT(unsigned int address, unsigned int level)
{
    unsigned int i;
    vtd_pte_t *start = (vtd_pte_t *)address;
    for (i = 0; i < (1ul<<(9)); i++) {
        vtd_pte_t vtd_pte = start[i];
        if (vtd_pte_get_addr(vtd_pte) != 0) {
            sendWord(i);
            sendWord(vtd_pte.words[0]);
            sendWord(vtd_pte.words[1]);
            if (level == ia32KSnumIOPTLevels) {
                sendWord(1);
            } else {
                sendWord(0);
            }
        }
    }
}

static void sendIOSpace(uint32_t pci_request_id)
{
    uint32_t vtd_root_index;
    uint32_t vtd_context_index;
    vtd_rte_t* vtd_root_slot;
    vtd_cte_t* vtd_context;
    vtd_cte_t* vtd_context_slot;

    vtd_root_index = vtd_get_root_index(pci_request_id);
    vtd_root_slot = ia32KSvtdRootTable + vtd_root_index;

    vtd_context = (vtd_cte_t*)paddr_to_pptr(vtd_rte_ptr_get_ctp(vtd_root_slot));
    vtd_context_index = vtd_get_context_index(pci_request_id);
    vtd_context_slot = &vtd_context[vtd_context_index];

    if (vtd_cte_ptr_get_present(vtd_context_slot)) {
        sendWord(vtd_cte_ptr_get_asr(vtd_context_slot));
    } else {
        sendWord(0);
    }
}



static void sendRunqueues(void)
{
    unsigned int i;
    sendWord((unsigned int)ksCurThread);
    for (i = 0; i < (1 * 256); i++) {
        tcb_t *current = ksReadyQueues[i].head;
        if (current != 0) {
            while (current != ksReadyQueues[i].end) {
                sendWord((unsigned int)current);
                current = current -> tcbSchedNext;
            }
            sendWord((unsigned int)current);
        }
    }
}

static void sendEPQueue(unsigned int epptr)
{
    tcb_t *current = (tcb_t *)endpoint_ptr_get_epQueue_head((endpoint_t *)epptr);
    tcb_t *tail = (tcb_t *)endpoint_ptr_get_epQueue_tail((endpoint_t *)epptr);
    if (current == 0) {
        return;
    }
    while (current != tail) {
        sendWord((unsigned int)current);
        current = current->tcbEPNext;
    }
    sendWord((unsigned int)current);
}

static void sendCNode(unsigned int address, unsigned int sizebits)
{
    unsigned int i;
    cte_t *start = (cte_t *)address;
    for (i = 0; i < (1 << sizebits); i++) {
        cap_t cap = start[i].cap;
        if (cap_get_capType(cap) != cap_null_cap) {
            sendWord(i);
            sendWord(cap.words[0]);
            sendWord(cap.words[1]);
        }
    }
}

static void sendIRQNode(void)
{
    sendCNode((unsigned int)intStateIRQNode, 8);
}

static void sendVersion(void)
{
    sendWord(0xe1);
    sendWord(0);
}

void capDL(void)
{
    int result;
    int done = 0;
    while (done == 0) {
        unsigned char c;
        do {
            c = getDebugChar();
        } while (c != 0xff);
        do {
            result = getDecodedChar(&c);
            if (result) {
                continue;
            }
            switch (c) {
            case 0xf0: {
                /*pgdir */
                unsigned int arg;
                result = getArg32(&arg);
                if (result) {
                    continue;
                }
                sendPD(arg);
                putDebugChar(0xbb);
            }
            break;
            case 0xf5: {
                /*pg table */
                unsigned int arg;
                result = getArg32(&arg);
                if (result) {
                    continue;
                }
                sendPT(arg);
                putDebugChar(0xbb);
            }
            break;

            case 0xf6: {
                /*io pt table */
                unsigned int address, level;
                result = getArg32(&address);
                if (result) {
                    continue;
                }
                result = getArg32(&level);
                if (result) {
                    continue;
                }
                sendIOPT(address, level);
                putDebugChar(0xbb);
            }
            break;
            case 0xf7: {
                /*io space */
                unsigned int arg;
                result = getArg32(&arg);
                if (result) {
                    continue;
                }
                sendIOSpace(arg);
                putDebugChar(0xbb);
            }
            break;

            case 0xf1: {
                /*runqueues */
                sendRunqueues();
                putDebugChar(0xbb);
                result = 0;
            }
            break;
            case 0xf2: {
                /*endpoint waiters */
                unsigned int arg;
                result = getArg32(&arg);
                if (result) {
                    continue;
                }
                sendEPQueue(arg);
                putDebugChar(0xbb);
            }
            break;
            case 0xf3: {
                /*cnode */
                unsigned int address, sizebits;
                result = getArg32(&address);
                if (result) {
                    continue;
                }
                result = getArg32(&sizebits);
                if (result) {
                    continue;
                }

                sendCNode(address, sizebits);
                putDebugChar(0xbb);
            }
            break;
            case 0xf4: {
                sendIRQNode();
                putDebugChar(0xbb);
                result = 0;
            }
            break;
            case 0xf8: {
                sendVersion();
                putDebugChar(0xbb);
            }
            break;
            case 0xf9: {
                done = 1;
                putDebugChar(0xbb);
            }
            default:
                result = 0;
                break;
            }
        } while (result);
    }
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/fpu.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/fpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/fpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/fpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/fpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/fpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/cpu_registers.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/fpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/fpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/fpu.c" 2

/*
 * Setup the FPU register state for a new thread.
 */
void
Arch_initFpuContext(user_context_t *context)
{
    context->fpuState = ia32KSnullFpuState;
}

/*
 * Switch the owner of the FPU to the given thread.
 */
static void
switchFpuOwner(tcb_t *new_owner)
{
    enableFpu();
    if (ia32KSfpuOwner) {
        saveFpuState(&ia32KSfpuOwner->tcbArch.tcbContext.fpuState);
    }
    if (new_owner) {
        loadFpuState(&new_owner->tcbArch.tcbContext.fpuState);
    } else {
        disableFpu();
    }
    ia32KSfpuOwner = new_owner;
}

/*
 * Handle a FPU fault.
 *
 * This CPU exception is thrown when userspace attempts to use the FPU while
 * it is disabled. We need to save the current state of the FPU, and hand
 * it over.
 */
__attribute__((externally_visible)) exception_t
handleUnimplementedDevice(void)
{
    /*
     * If we have already given the FPU to the user, we should not reach here.
     *
     * This should only be able to occur on CPUs without an FPU at all, which
     * we presumably are happy to assume will not be running seL4.
     */
    if(!(ksCurThread != ia32KSfpuOwner)) _assert_fail("ksCurThread != ia32KSfpuOwner", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/fpu.c", 62, __FUNCTION__);

    /* Otherwise, lazily switch over the FPU. */
    switchFpuOwner(ksCurThread);

    return EXCEPTION_NONE;
}

/*
 * Prepare for the deletion of the given thread.
 */
void
Arch_fpuThreadDelete(tcb_t *thread)
{
    /*
     * If the thread being deleted currently owns the FPU, switch away from it
     * so that 'ia32KSfpuOwner' doesn't point to invalid memory.
     */
    if (ia32KSfpuOwner == thread) {
        switchFpuOwner(((void *)0));
    }
}

/*
 * Initialise the FPU for this machine.
 */
__attribute__((__section__(".boot.text"))) void
Arch_initFpu(void)
{
    /* Enable FPU / SSE / SSE2 / SSE3 / SSSE3 / SSE4 Extensions. */
    write_cr4(read_cr4() | (1ul<<(9)) /* Enable SSE et. al. features. */);

    /* Enable the FPU in general. Although leave it in a state where it will
     * generate a fault if someone tries to use it as we implement lazy
     * switching */
    write_cr0((read_cr0() & ~(1ul<<(2)) /* Enable OS emulation of FPU. */) | (1ul<<(1)) /* Trap on FPU "WAIT" commands. */ | (1ul<<(5)) /* Internally handle FPU problems. */ | (1ul<<(3)) /* Trap on any FPU usage, for lazy FPU. */);
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/hardware.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/hardware.c" 2

/* initialises MSRs required to setup sysenter and sysexit */
__attribute__((__section__(".boot.text"))) void
init_sysenter_msrs(void)
{
    ia32_wrmsr(0x174, 0, (uint32_t)(1 << 3));
    ia32_wrmsr(0x176, 0, (uint32_t)&handle_syscall);
    ia32_wrmsr(0x175, 0, (uint32_t)&ia32KStss.words[1]);
}

word_t __attribute__((__pure__)) getRestartPC(tcb_t *thread)
{
    return getRegister(thread, FaultEIP);
}

void setNextPC(tcb_t *thread, word_t v)
{
    setRegister(thread, NextEIP, v);
}

/* Returns the size of CPU's cacheline */
__attribute__((__section__(".boot.text"))) uint32_t __attribute__((__const__))
getCacheLineSizeBits(void)
{
    uint32_t line_size;
    uint32_t n;

    line_size = getCacheLineSize();
    if (line_size == 0) {
        kprintf("Cacheline size must be >0\n");
        return 0;
    }

    /* determine size_bits */
    n = 0;
    while (!(line_size & 1)) {
        line_size >>= 1;
        n++;
    }

    if (line_size != 1) {
        kprintf("Cacheline size must be a power of two\n");
        return 0;
    }

    return n;
}

/* Flushes a specific memory range from the CPU cache */

void flushCacheRange(void* vaddr, uint32_t size_bits)
{
    uint32_t v;

    if(!(size_bits < (8 * sizeof(word_t)))) _assert_fail("size_bits < WORD_BITS", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/hardware.c", 73, __FUNCTION__);
    if(!((!(((uint32_t)vaddr) & ((1ul<<(size_bits))-1ul))))) _assert_fail("IS_ALIGNED((uint32_t)vaddr, size_bits)", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/hardware.c", 74, __FUNCTION__);

    ia32_mfence();

    for (v = ((((uint32_t)vaddr) >> (ia32KScacheLineSizeBits)) << (ia32KScacheLineSizeBits));
            v < (uint32_t)vaddr + (1ul<<(size_bits));
            v += (1ul<<(ia32KScacheLineSizeBits))) {
        flushCacheLine((void*)v);
    }
    ia32_mfence();
}

/* Disables as many prefetchers as possible */
__attribute__((__section__(".boot.text"))) bool_t
disablePrefetchers()
{
    uint32_t version_info;
    uint32_t low, high;
    int i;

    uint32_t valid_models[] = { 0xD4, 0xC3, 0xA9,
                                0x2A /* Sandy Bridge */, 0x2D /* Sandy Bridge-E, Sandy Bridge-EN and Sandy Bridge-EP */, 0x25 /* Arrandale and Clarksdale */, 0x2C /* Gulftown and Westmere-EP */,
                                0x2F /* Westemere-EX */, 0x1E /* Clarksfield, Lynnfield and Jasper Forest */, 0x1A /* Bloomfield and Nehalem-EP */, 0x2E /* Nehalem-EX */
                              };

    version_info = ia32_cpuid_eax(0x1, 0x0);

    for (i = 0; i < (sizeof(typeof(valid_models))/sizeof(typeof((valid_models)[0]))); ++i) {
        if (( ((version_info & 0xf0000) >> 16) + (version_info & 0xf0) ) == valid_models[i]) {
            low = ia32_rdmsr_low(0x1A4);
            high = ia32_rdmsr_high(0x1A4);

            low |= (1ul<<(0));
            low |= (1ul<<(1));
            low |= (1ul<<(2));
            low |= (1ul<<(3));

            ia32_wrmsr(0x1A4, high, low);

            return true;
        }
    }

    kprintf("Disabling prefetchers not implemented for CPU model: %x\n", ( ((version_info & 0xf0000) >> 16) + (version_info & 0xf0) ));
    return false;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/registerset.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/registerset.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/registerset.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/fpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/registerset.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/machine/registerset.c" 2

const register_t msgRegisters[] = {
    EDI, EBP
};

const register_t frameRegisters[] = {
    FaultEIP, ESP, EFLAGS, EAX, EBX, ECX, EDX, ESI, EDI, EBP
};

const register_t gpRegisters[] = {
    TLS_BASE, FS, GS
};

const register_t exceptionMessage[] = {
    FaultEIP, ESP, EFLAGS
};

const register_t syscallMessage[] = {
    EAX, EBX, ECX, EDX, ESI, EDI, EBP, NextEIP, ESP, EFLAGS
};


const register_t crExitRegs[] = {
    EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
};


void Arch_initContext(user_context_t* context)
{
    context->registers[EAX] = 0;
    context->registers[EBX] = 0;
    context->registers[ECX] = 0;
    context->registers[EDX] = 0;
    context->registers[ESI] = 0;
    context->registers[EDI] = 0;
    context->registers[EBP] = 0;
    context->registers[DS] = ((4 << 3) | 3);
    context->registers[ES] = ((4 << 3) | 3);
    context->registers[FS] = 0;
    context->registers[GS] = 0;
    context->registers[TLS_BASE] = 0;
    context->registers[Error] = 0;
    context->registers[FaultEIP] = 0;
    context->registers[NextEIP] = 0; /* overwritten by setNextPC() later on */
    context->registers[CS] = ((3 << 3) | 3);
    context->registers[EFLAGS] = (1ul<<(9)) | (1ul<<(1)); /* enable interrupts and set bit 1 which is always 1 */
    context->registers[ESP] = 0; /* userland has to set it after entry */
    context->registers[SS] = ((4 << 3) | 3);

    Arch_initFpuContext(context);
}

word_t sanitiseRegister(register_t reg, word_t v)
{
    if (reg == EFLAGS) {
        v |= (1ul<<(1)); /* reserved bit that must be set to 1 */
        v &= ~(1ul<<(3)); /* reserved bit that must be set to 0 */
        v &= ~(1ul<<(5)); /* reserved bit that must be set to 0 */
        v |= (1ul<<(9)); /* interrupts must be enabled in userland */
        v &= ((1ul<<(12))-1ul); /* bits 12:31 have to be 0 */
    }
    if (reg == FS || reg == GS) {
        if (v != ((6 << 3) | 3) && v != ((7 << 3) | 3)) {
            v = 0;
        }
    }
    return v;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/model/statedata.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/model/statedata.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/model/statedata.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/model/statedata.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/model/statedata.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/model/statedata.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/model/statedata.c" 2

/* ==== read/write kernel state not preserved across kernel entries ==== */

/* Interrupt currently being handled */
interrupt_t ia32KScurInterrupt __attribute__((externally_visible));

/* ==== proper read/write kernel state ==== */

/* Task State Segment (TSS), contains currently running TCB in ESP0 */
tss_t ia32KStss __attribute__((externally_visible));

/* Global Descriptor Table (GDT) */
gdt_entry_t ia32KSgdt[8];

/*
 * Current thread whose state is installed in the FPU, or NULL if
 * the FPU is currently invalid.
 */
tcb_t *ia32KSfpuOwner __attribute__((externally_visible));

/* ==== read-only kernel state (only written during bootstrapping) ==== */

/* The privileged kernel mapping PD & PT */
pdpte_t* ia32KSkernelPDPT;
pde_t* ia32KSkernelPD;
pte_t* ia32KSkernelPT;

/* CPU Cache Line Size */
uint32_t ia32KScacheLineSizeBits;

/* Interrupt Descriptor Table (IDT) */
idt_entry_t ia32KSidt[256];

/* A valid initial FPU state, copied to every new thread. */
user_fpu_state_t ia32KSnullFpuState __attribute__((__aligned__(16)));

/* Current active page directory. This is really just a shadow of CR3 */
paddr_t ia32KSCurrentPD __attribute__((externally_visible));


/* Number of IOMMUs (DMA Remapping Hardware Units) */
uint32_t ia32KSnumDrhu;

/* Intel VT-d Root Entry Table */
vtd_rte_t* ia32KSvtdRootTable;
uint32_t ia32KSnumIOPTLevels;
uint32_t ia32KSnumIODomainIDBits;
int ia32KSFirstValidIODomain;



uint16_t ia32KSconsolePort;
uint16_t ia32KSdebugPort;


node_id_t ia32KSNodeID;
uint32_t ia32KSNumNodes;
cpu_id_t* ia32KSCPUList;
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/interrupt.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/interrupt.c" 2

exception_t Arch_decodeInterruptControl(unsigned int length, extra_caps_t extraCaps)
{
    current_syscall_error.type = seL4_IllegalOperation;
    return EXCEPTION_SYSCALL_ERROR;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ioport.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ioport.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ioport.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ioport.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ioport.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/ioport.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ioport.c" 2
# 1 "./arch/api/invocation.h" 1
/* @LICENSE(OKL_CORE) */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ioport.c" 2

static exception_t
ensurePortOperationAllowed(cap_t cap, uint32_t start_port, uint32_t size)
{
    uint32_t first_allowed = cap_io_port_cap_get_capIOPortFirstPort(cap);
    uint32_t last_allowed = cap_io_port_cap_get_capIOPortLastPort(cap);
    uint32_t end_port = start_port + size - 1;
    if(!(first_allowed <= last_allowed)) _assert_fail("first_allowed <= last_allowed", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ioport.c", 24, __FUNCTION__);
    if(!(start_port <= end_port)) _assert_fail("start_port <= end_port", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ioport.c", 25, __FUNCTION__);

    if ((start_port < first_allowed) || (end_port > last_allowed)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 30, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IOPort: Ports %d--%d fall outside permitted range %d--%d.", (int)start_port, (int)end_port, (int)first_allowed, (int)last_allowed); kprintf(">>" "\033[0m" "\n"); } while (0)

                                                        ;
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    return EXCEPTION_NONE;
}

exception_t
decodeIA32PortInvocation(
    word_t label,
    unsigned int length,
    cptr_t cptr,
    cte_t* slot,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    uint32_t res;
    uint32_t len;
    uint16_t port;
    exception_t ret;

    /* Ensure user specified at very least a port. */
    if (length < 1) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 56, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IOPort: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Get the port the user is trying to write to. */
    port = getSyscallArg(0, buffer) & 0xffff;

    switch (label) {
    case IA32IOPortIn8: { /* inport 8 bits */

        /* Check we are allowed to perform the operation. */
        ret = ensurePortOperationAllowed(cap, port, 1);
        if (ret != EXCEPTION_NONE) {
            return ret;
        }

        /* Perform the read. */
        res = in8(port);
        len = 1;
        break;
    }

    case IA32IOPortIn16: { /* inport 16 bits */

        /* Check we are allowed to perform the operation. */
        ret = ensurePortOperationAllowed(cap, port, 2);
        if (ret != EXCEPTION_NONE) {
            return ret;
        }

        /* Perform the read. */
        res = in16(port);
        len = 1;
        break;
    }

    case IA32IOPortIn32: { /* inport 32 bits */

        /* Check we are allowed to perform the operation. */
        ret = ensurePortOperationAllowed(cap, port, 4);
        if (ret != EXCEPTION_NONE) {
            return ret;
        }

        /* Perform the read. */
        res = in32(port);
        len = 1;
        break;
    }

    case IA32IOPortOut8: { /* outport 8 bits */
        uint8_t data;

        /* Check we are allowed to perform the operation. */
        ret = ensurePortOperationAllowed(cap, port, 1);
        if (ret != EXCEPTION_NONE) {
            return ret;
        }

        /* Perform the write. */
        data = (getSyscallArg(0, buffer) >> 16) & 0xff;
        out8(port, data);
        len = 0;
        break;
    }

    case IA32IOPortOut16: { /* outport 16 bits */
        uint16_t data;

        /* Check we are allowed to perform the operation. */
        ret = ensurePortOperationAllowed(cap, port, 2);
        if (ret != EXCEPTION_NONE) {
            return ret;
        }

        /* Perform the write. */
        data = (getSyscallArg(0, buffer) >> 16) & 0xffff;
        out16(port, data);
        len = 0;
        break;
    }

    case IA32IOPortOut32: { /* outport 32 bits */
        uint32_t data;

        /* Ensure the incoming message is long enough for the write. */
        if (length < 2) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 144, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IOPort Out32: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_TruncatedMessage;
            return EXCEPTION_SYSCALL_ERROR;
        }

        /* Check we are allowed to perform the operation. */
        ret = ensurePortOperationAllowed(cap, port, 4);
        if (ret != EXCEPTION_NONE) {
            return ret;
        }

        /* Perform the write. */
        data = getSyscallArg(1, buffer);
        out32(port, data);
        len = 0;
        break;
    }

    default:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 163, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IOPort: Unknown operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (len > 0) {
        /* return the value read from the port */
        setRegister(ksCurThread, badgeRegister, 0);
        if (n_msgRegisters < 1) {
            word_t* ipcBuffer;
            ipcBuffer = lookupIPCBuffer(true, ksCurThread);
            if (ipcBuffer != ((void *)0)) {
                ipcBuffer[1] = res;
                len = 1;
            } else {
                len = 0;
            }
        } else {
            setRegister(ksCurThread, msgRegisters[0], res);
            len = 1;
        }
    }
    setRegister(ksCurThread, msgInfoRegister,
                wordFromMessageInfo(message_info_new(0, 0, 0, len)));

    setThreadState(ksCurThread, ThreadState_Restart);
    return EXCEPTION_NONE;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c" 2



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c" 2
# 1 "./arch/api/invocation.h" 1
/* @LICENSE(OKL_CORE) */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/iospace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/intel-vtd.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c" 2

typedef struct lookupVTDContextSlot_ret {
    vtd_cte_t *cte;
    uint32_t index;
} lookupVTDContextSlot_ret_t;

__attribute__((__section__(".boot.text"))) cap_t
master_iospace_cap(void)
{
    if (ia32KSnumDrhu == 0) {
        return cap_null_cap_new();
    }

    return
        cap_io_space_cap_new(
            0, /* capDomainID  */
            0 /* capPCIDevice */
        );
}

/* parent[index] IS child */
void unmapVTDPT(vtd_pte_t *parent, vtd_pte_t *child, uint32_t index)
{
    parent[index] = vtd_pte_new(0, 0, 0, 0);
    flushCacheRange(parent + index, 3);
    invalidate_iotlb();
}

void unmapAllIOPT(vtd_pte_t *pt, int level)
{
    uint32_t i;

    for (i = 0; i < (1ul<<(9)); i++) {
        /* see if there is anything here */
        vtd_pte_t *pte = pt + i;
        if (vtd_pte_ptr_get_read(pte)) {
            uint32_t depth = vtd_pte_ptr_get_cte_depth(pte);
            /* work out if we are searching for frames or more page tables */
            if (level == ia32KSnumIOPTLevels - 1) {
                cap_t cap;
                void *frame = paddr_to_pptr(vtd_pte_ptr_get_addr(pte));
                cte_t *cte = cdtFindAtDepth(cap_frame_cap_new(IA32_SmallPage, ((unsigned int)(pt)), i, IA32_MAPPING_IO, 0, (uint32_t)frame), depth);
                if(!(cte)) _assert_fail("cte", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c", 65, __FUNCTION__);
                cap = cap_frame_cap_set_capFMappedObject(cte->cap, 0);
                cdtUpdate(cte, cap);
            } else {
                cap_t cap;
                vtd_pte_t *pt2 = ((vtd_pte_t*)(paddr_to_pptr(vtd_pte_ptr_get_addr(pte))));
                cte_t *cte = cdtFindAtDepth(cap_io_page_table_cap_new(0, ((unsigned int)(pt)), i, ((unsigned int)(pt2))), depth);
                if(!(cte)) _assert_fail("cte", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c", 72, __FUNCTION__);
                cap = cap_io_page_table_cap_set_capIOPTMappedObject(cte->cap, 0);
                cdtUpdate(cte, cap);
            }
        }
    }
}

static void unmapVTDContextEntryAt(vtd_cte_t *cte, uint32_t index)
{
    /* Lookup the page table and unmap it */
    vtd_pte_t *vtd_pt;
    cte_t *ptCte;
    cap_t ptCap;
    vtd_cte_t *vtd_context_slot = cte + index;
    /* First see if there is a page table */
    if (!vtd_cte_ptr_get_present(vtd_context_slot)) {
        return;
    }
    /* see if it reserved, and thus shouldn't be unmapped */
    if (vtd_cte_ptr_get_rmrr(vtd_context_slot)) {
        return;
    }
    /* Lookup the slot */
    vtd_pt = (vtd_pte_t*)paddr_to_pptr(vtd_cte_ptr_get_asr(vtd_context_slot));
    ptCte = cdtFindAtDepth(cap_io_page_table_cap_new(0, (uint32_t)cte, index, ((unsigned int)(vtd_pt))), vtd_cte_ptr_get_cte_depth(vtd_context_slot));
    if(!(ptCte)) _assert_fail("ptCte", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c", 98, __FUNCTION__);
    /* unmap */
    ptCap = cap_io_page_table_cap_set_capIOPTMappedObject(ptCte->cap, 0);
    cdtUpdate(ptCte, ptCap);
    if(!(vtd_cte_ptr_get_present(vtd_context_slot))) _assert_fail("vtd_cte_ptr_get_present(vtd_context_slot)", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c", 102, __FUNCTION__);
    vtd_cte_ptr_new(
        vtd_context_slot,
        0, /* Domain ID          */
        0, /* CTE Depth          */
        0, /* RMRR Mapping       */
        0, /* Address Width      */
        0, /* Address Space Root */
        0, /* Translation Type   */
        0 /* Present            */
    );
    flushCacheRange(vtd_context_slot, 3);
    invalidate_iotlb();
}

static lookupVTDContextSlot_ret_t lookupVTDContextSlot_helper(cap_t cap)
{
    uint32_t vtd_root_index;
    uint32_t vtd_context_index;
    dev_id_t pci_request_id;
    vtd_rte_t* vtd_root_slot;
    vtd_cte_t* vtd_context;

    if(!(cap_get_capType(cap) == cap_io_space_cap)) _assert_fail("cap_get_capType(cap) == cap_io_space_cap", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/iospace.c", 125, __FUNCTION__);
    pci_request_id = cap_io_space_cap_get_capPCIDevice(cap);

    vtd_root_index = vtd_get_root_index(pci_request_id);
    vtd_root_slot = ia32KSvtdRootTable + vtd_root_index;

    vtd_context = (vtd_cte_t*)paddr_to_pptr(vtd_rte_ptr_get_ctp(vtd_root_slot));
    vtd_context_index = vtd_get_context_index(pci_request_id);

    return (lookupVTDContextSlot_ret_t) {
        .cte = vtd_context, .index = vtd_context_index
    };

}

vtd_cte_t *lookupVTDContextSlot(cap_t cap)
{
    lookupVTDContextSlot_ret_t ret = lookupVTDContextSlot_helper(cap);
    return ret.cte + ret.index;
}

void unmapVTDContextEntry(cap_t cap)
{
    lookupVTDContextSlot_ret_t ret = lookupVTDContextSlot_helper(cap);
    unmapVTDContextEntryAt(ret.cte, ret.index);
}

static lookupIOPTSlot_ret_t lookupIOPTSlot_helper(vtd_pte_t* iopt, word_t translation, word_t levels)
{
    lookupIOPTSlot_ret_t ret;
    uint32_t iopt_index;
    vtd_pte_t* vtd_pte_slot;
    vtd_pte_t* vtd_next_level_iopt;

    if (9 * levels >= 32) {
        iopt_index = 0;
    } else {
        iopt_index = (translation >> (9 * levels)) & ((1ul<<(9))-1ul);
    }

    vtd_pte_slot = iopt + iopt_index;

    if (!vtd_pte_ptr_get_write(vtd_pte_slot) || levels == 0) {
        /* Slot is in this page table level */
        ret.iopt = iopt;
        ret.index = iopt_index;
        ret.level = ia32KSnumIOPTLevels - levels;
        ret.status = EXCEPTION_NONE;
        return ret;
    } else {
        vtd_next_level_iopt = (vtd_pte_t*)paddr_to_pptr(vtd_pte_ptr_get_addr(vtd_pte_slot));
        return lookupIOPTSlot_helper(vtd_next_level_iopt, translation, levels - 1);
    }
}

static inline lookupIOPTSlot_ret_t lookupIOPTSlot(vtd_pte_t* iopt, word_t io_address)
{
    lookupIOPTSlot_ret_t ret;

    if (iopt == 0) {
        ret.iopt = 0;
        ret.index = 0;
        ret.level = 0;
        ret.status = EXCEPTION_LOOKUP_FAULT;
        return ret;
    } else {
        return lookupIOPTSlot_helper(iopt, io_address >> IA32_4K_bits, ia32KSnumIOPTLevels - 1);
    }
}

void
unmapIOPTCap(cap_t cap)
{

    int level = cap_io_page_table_cap_get_capIOPTLevel(cap);
    vtd_pte_t *pt = ((vtd_pte_t*)(cap_get_capPtr(cap)));
    if (level == 0) {
        vtd_cte_t *ct = ((vtd_cte_t*)(cap_io_page_table_cap_get_capIOPTMappedObject(cap)));
        uint32_t index = cap_io_page_table_cap_get_capIOPTMappedIndex(cap);
        if (ct) {
            unmapVTDContextEntryAt(ct, index);
        }
    } else {
        vtd_pte_t *parent = ((vtd_pte_t*)(cap_io_page_table_cap_get_capIOPTMappedObject(cap)));
        if (parent) {
            uint32_t index = cap_io_page_table_cap_get_capIOPTMappedIndex(cap);
            unmapVTDPT(parent, pt, index);
        }
    }
}

exception_t
decodeIA32IOPTInvocation(
    word_t label,
    uint32_t length,
    cte_t* slot,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    cap_t io_space;
    paddr_t paddr;
    uint32_t io_address;
    uint16_t domain_id;
    vtd_cte_t* vtd_context_slot;
    vtd_pte_t* vtd_pte;
    lookupVTDContextSlot_ret_t lookup_ret;

    if (label == IA32IOPageTableUnmap) {
        unmapIOPTCap(cap);

        cap = cap_io_page_table_cap_set_capIOPTMappedObject(cap, 0);
        cdtUpdate(slot, cap);

        setThreadState(ksCurThread, ThreadState_Restart);
        return EXCEPTION_NONE;
    }

    if (extraCaps.excaprefs[0] == ((void *)0) || length < 1) {
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (label != IA32IOPageTableMap ) {
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    io_space = extraCaps.excaprefs[0]->cap;
    io_address = getSyscallArg(0, buffer);

    if (cap_io_page_table_cap_get_capIOPTMappedObject(cap)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 258, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32IOPageTableMap: Page table already mapped"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if ((cap_get_capType(io_space) != cap_io_space_cap)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 265, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32IOPageTableMap: Not a valid IO Space"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;
    }

    domain_id = cap_io_space_cap_get_capDomainID(io_space);
    if (domain_id == 0) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 273, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32IOPageTableMap: IOSpace has no domain ID"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;

        return EXCEPTION_SYSCALL_ERROR;
    }

    paddr = pptr_to_paddr(((vtd_pte_t*)(cap_io_page_table_cap_get_capIOPTBasePtr(cap))));
    lookup_ret = lookupVTDContextSlot_helper(io_space);
    vtd_context_slot = lookup_ret.cte + lookup_ret.index;

    if (!vtd_cte_ptr_get_present(vtd_context_slot)) {
        /* 1st Level Page Table */
        vtd_cte_ptr_new(
            vtd_context_slot,
            domain_id, /* Domain ID */
            mdb_node_get_cdtDepth(slot->cteMDBNode), /* CTE Depth */
            false, /* RMRR Mapping */
            ia32KSnumIOPTLevels - 2, /* Address Width (x = levels - 2)       */
            paddr, /* Address Space Root                   */
            0, /* Translation Type                     */
            true /* Present                              */
        );

        flushCacheRange(vtd_context_slot, 3);

        cap = cap_io_page_table_cap_set_capIOPTMappedObject(cap, ((unsigned int)(lookup_ret.cte)));
        cap = cap_io_page_table_cap_set_capIOPTMappedIndex(cap, lookup_ret.index);
        cap = cap_io_page_table_cap_set_capIOPTLevel(cap, 0);
    } else {
        lookupIOPTSlot_ret_t lu_ret;

        vtd_pte = (vtd_pte_t*)paddr_to_pptr(vtd_cte_ptr_get_asr(vtd_context_slot));
        lu_ret = lookupIOPTSlot(vtd_pte, io_address);

        if (lu_ret.status != EXCEPTION_NONE) {
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = false;
            return EXCEPTION_SYSCALL_ERROR;
        }
        if (lu_ret.level == ia32KSnumIOPTLevels) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 314, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32IOPageTableMap: Cannot map any more levels of page tables"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }
        if (vtd_pte_ptr_get_read(lu_ret.iopt + lu_ret.index)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 320, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32IOPageTableMap: Mapping already exists"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }

        vtd_pte_ptr_new(
            lu_ret.iopt + lu_ret.index,
            paddr, /* Physical Address         */
            mdb_node_get_cdtDepth(slot->cteMDBNode), /* CTE depth */
            1, /* Read permission flag     */
            1 /* Write permission flag    */
        );

        flushCacheRange(lu_ret.iopt + lu_ret.index, 3);

        cap = cap_io_page_table_cap_set_capIOPTMappedObject(cap, ((unsigned int)(lu_ret.iopt)));
        cap = cap_io_page_table_cap_set_capIOPTMappedIndex(cap, lu_ret.index);
        cap = cap_io_page_table_cap_set_capIOPTLevel(cap, lu_ret.level);
    }

    cdtUpdate(slot, cap);

    setThreadState(ksCurThread, ThreadState_Restart);
    return EXCEPTION_NONE;
}

exception_t
decodeIA32IOMapInvocation(
    word_t label,
    uint32_t length,
    cte_t* slot,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    cap_t io_space;
    uint32_t io_address;
    uint32_t domain_id;
    vtd_cte_t* vtd_context_slot;
    vtd_pte_t* vtd_pte;
    paddr_t paddr;
    vm_rights_t capVMRights;
    vm_rights_t vmRights;
    word_t w_rightsMask;
    lookupIOPTSlot_ret_t lu_ret;

    if (extraCaps.excaprefs[0] == ((void *)0) || length < 2) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 369, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32IOFrameMap: Truncated message"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (cap_frame_cap_get_capFSize(cap) != IA32_SmallPage) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 375, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32IOFrameMap: Only 4K frames supported"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (cap_frame_cap_get_capFMappedObject(cap) != 0) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 382, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32IOFrameMap: Frame already mapped"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;
    }

    io_space = extraCaps.excaprefs[0]->cap;
    w_rightsMask = getSyscallArg(0, buffer);
    io_address = getSyscallArg(1, buffer);
    paddr = pptr_to_paddr((void*)cap_frame_cap_get_capFBasePtr(cap));
    capVMRights = cap_frame_cap_get_capFVMRights(cap);
    vmRights = maskVMRights(capVMRights, rightsFromWord(w_rightsMask));

    if (cap_get_capType(io_space) != cap_io_space_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 396, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32IOFrameMap: IOSpace cap invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }

    domain_id = cap_io_space_cap_get_capDomainID(io_space);

    if (domain_id == 0) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 405, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32IOFrameMap: IOSpace has no domain ID"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;
    }

    vtd_context_slot = lookupVTDContextSlot(io_space);

    if (!vtd_cte_ptr_get_present(vtd_context_slot)) {
        /* 1st Level Page Table is not installed */
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = false;
        return EXCEPTION_SYSCALL_ERROR;
    }

    vtd_pte = (vtd_pte_t*)paddr_to_pptr(vtd_cte_ptr_get_asr(vtd_context_slot));
    lu_ret = lookupIOPTSlot(vtd_pte, io_address);

    if (lu_ret.status != EXCEPTION_NONE || lu_ret.level != ia32KSnumIOPTLevels) {
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = false;
        return EXCEPTION_SYSCALL_ERROR;
    }
    if (vtd_pte_ptr_get_read(lu_ret.iopt + lu_ret.index)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 429, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IA32IOFrameMap: Mapping already present"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_DeleteFirst;
        return EXCEPTION_SYSCALL_ERROR;
    }

    vtd_pte_ptr_new(
        lu_ret.iopt + lu_ret.index,
        paddr, /* Physical Address */
        mdb_node_get_cdtDepth(slot->cteMDBNode),
        1, /* Read permission  */
        WritableFromVMRights(vmRights) /* Write permission */
    );
    cap = cap_frame_cap_set_capFMappedObject(cap, ((unsigned int)(lu_ret.iopt)));
    cap = cap_frame_cap_set_capFMappedIndex(cap, lu_ret.index);
    cap = cap_frame_cap_set_capFMappedType(cap, IA32_MAPPING_IO);
    cdtUpdate(slot, cap);

    flushCacheRange(lu_ret.iopt + lu_ret.index, 3);

    setThreadState(ksCurThread, ThreadState_Restart);
    return EXCEPTION_NONE;
}

void unmapIOPage(cap_t cap)
{
    vtd_pte_t *vtd_pt = ((vtd_pte_t*)(cap_frame_cap_get_capFMappedObject(cap)));
    uint32_t index = cap_frame_cap_get_capFMappedIndex(cap);
    vtd_pte_t *vtd_pte = vtd_pt + index;

    if (!vtd_pt) {
        return;
    }

    vtd_pte_ptr_new(vtd_pte, 0, 0, 0, 0);

    flushCacheRange(vtd_pte, 3);
    invalidate_iotlb();
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ipi.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ipi.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ipi.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ipi.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/ipi.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/ipi.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/ipi.h" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/ipi.h" 2

exception_t decodeIA32IPIInvocation(word_t label, unsigned int length, cptr_t cptr, cte_t *slot, cap_t cap, extra_caps_t extraCaps, word_t* buffer);
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ipi.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/apic.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ipi.c" 2
# 1 "./arch/api/invocation.h" 1
/* @LICENSE(OKL_CORE) */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/ipi.c" 2

exception_t
decodeIA32IPIInvocation(
    word_t label,
    unsigned int length,
    cptr_t cptr,
    cte_t* slot,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    node_id_t node_id;
    irq_t irq;

    if (label != IA32IPISend) {
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (length < 1) {
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    node_id = getSyscallArg(0, buffer) & 0xff;
    irq = (getSyscallArg(0, buffer) >> 8) & 0xff;

    if (node_id >= ia32KSNumNodes || irq < irq_ipi_min || irq > irq_ipi_max) {
        current_syscall_error.type = seL4_InvalidArgument;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* send the IPI */
    apic_send_ipi(ia32KSCPUList[node_id], irq + 0x20);

    /* setup reply message */
    setRegister(ksCurThread, badgeRegister, 0);
    setRegister(ksCurThread, msgInfoRegister,
                wordFromMessageInfo(message_info_new(0, 0, 0, 0)));
    setThreadState(ksCurThread, ThreadState_Restart);

    return EXCEPTION_NONE;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/fpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/ioport.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/ipi.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2


# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/iospace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 28 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/intel-vtd.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 29 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/vtx.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 33 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/vcpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 34 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c" 2


deriveCap_ret_t Arch_deriveCap(cte_t* slot, cap_t cap)
{
    deriveCap_ret_t ret;

    switch (cap_get_capType(cap)) {
    case cap_page_table_cap:
        ret.cap = cap_page_table_cap_set_capPTMappedObject(cap, 0);
        ret.status = EXCEPTION_NONE;
        return ret;

    case cap_page_directory_cap:
        ret.cap = cap_page_directory_cap_set_capPDMappedObject(cap, 0);
        ret.status = EXCEPTION_NONE;
        return ret;

    case cap_pdpt_cap:
        ret.cap = cap;
        ret.status = EXCEPTION_NONE;
        return ret;

    case cap_frame_cap:
        ret.cap = cap_frame_cap_set_capFMappedObject(cap, 0);
        ret.status = EXCEPTION_NONE;
        return ret;
    case cap_io_port_cap:
        ret.cap = cap;
        ret.status = EXCEPTION_NONE;
        return ret;


    case cap_io_space_cap:
        ret.cap = cap;
        ret.status = EXCEPTION_NONE;
        return ret;
    case cap_io_page_table_cap:
        ret.cap = cap_io_page_table_cap_set_capIOPTMappedObject(cap, 0);
        ret.status = EXCEPTION_NONE;
        return ret;

    case cap_ipi_cap:
        ret.cap = cap;
        ret.status = EXCEPTION_NONE;
        return ret;


    case cap_ept_page_directory_pointer_table_cap:
        ret.cap = cap;
        ret.status = EXCEPTION_NONE;
        return ret;
    case cap_ept_page_directory_cap:
        ret.cap = cap_ept_page_directory_cap_set_capPDMappedObject(cap, 0);
        ret.status = EXCEPTION_NONE;
        return ret;
    case cap_ept_page_table_cap:
        ret.cap = cap_ept_page_table_cap_set_capPTMappedObject(cap, 0);
        ret.status = EXCEPTION_NONE;
        return ret;


    case cap_vcpu_cap:
        ret.cap = cap;
        ret.status = EXCEPTION_NONE;
        return ret;


    default:
        /* This assert has no equivalent in haskell,
         * as the options are restricted by type */
        _fail("Invalid arch cap type", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c", 104, __func__);
    }
}

cap_t __attribute__((__const__)) Arch_updateCapData(bool_t preserve, word_t data, cap_t cap)
{
    switch (cap_get_capType(cap)) {

    case cap_io_space_cap: {
        io_space_capdata_t w = { { data } };
        uint16_t PCIDevice = io_space_capdata_get_PCIDevice(w);
        uint16_t domainID = io_space_capdata_get_domainID(w);
        if (!preserve && cap_io_space_cap_get_capPCIDevice(cap) == 0 &&
                domainID >= ia32KSFirstValidIODomain &&
                domainID != 0 &&
                domainID <= ((1ul<<(ia32KSnumIODomainIDBits))-1ul)) {
            return cap_io_space_cap_new(domainID, PCIDevice);
        } else {
            return cap_null_cap_new();
        }
    }

    case cap_io_port_cap: {
        io_port_capdata_t w = { .words = { data } };
        uint16_t firstPort = io_port_capdata_get_firstPort(w);
        uint16_t lastPort = io_port_capdata_get_lastPort(w);
        uint16_t capFirstPort = cap_io_port_cap_get_capIOPortFirstPort(cap);
        uint16_t capLastPort = cap_io_port_cap_get_capIOPortLastPort(cap);
        if(!(capFirstPort <= capLastPort)) _assert_fail("capFirstPort <= capLastPort", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c", 132, __FUNCTION__);

        /* Ensure input data is ordered correctly. */
        if (firstPort > lastPort) {
            return cap_null_cap_new();
        }

        /* Allow the update if the new cap has range no larger than the old
         * cap. */
        if ((firstPort >= capFirstPort) && (lastPort <= capLastPort)) {
            return cap_io_port_cap_new(firstPort, lastPort);
        } else {
            return cap_null_cap_new();
        }
    }

    default:
        return cap;
    }
}

cap_t __attribute__((__const__)) Arch_maskCapRights(cap_rights_t cap_rights_mask, cap_t cap)
{
    if (cap_get_capType(cap) == cap_frame_cap) {
        vm_rights_t vm_rights;

        vm_rights = vmRightsFromWord(cap_frame_cap_get_capFVMRights(cap));
        vm_rights = maskVMRights(vm_rights, cap_rights_mask);
        return cap_frame_cap_set_capFVMRights(cap, wordFromVMRights(vm_rights));
    } else {
        return cap;
    }
}

static void finalisePDMappedFrame(cap_t cap)
{
    void *object = (void*)cap_frame_cap_get_capFMappedObject(cap);
    uint32_t index = cap_frame_cap_get_capFMappedIndex(cap);
    switch (cap_frame_cap_get_capFSize(cap)) {
    case IA32_SmallPage:
        unmapPageSmall(((pte_t *)(object)), index);
        flushPageSmall(((pte_t *)(object)), index);
        break;
    case IA32_LargePage:
        unmapPageLarge(((pde_t *)(object)), index);
        flushPageLarge(((pde_t *)(object)), index);
        break;
    default:
        _fail("Unknown frame size", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c", 180, __func__);
    }
}

cap_t Arch_finaliseCap(cap_t cap, bool_t final)
{
    switch (cap_get_capType(cap)) {
    case cap_pdpt_cap:
        if (final) {
            pdpte_t *capPtr = ((pdpte_t *)(cap_pdpt_cap_get_capPDPTBasePtr(cap)));
            unmapAllPageDirectories(capPtr);
            flushAllPageDirectories(capPtr);
            clearMemory((void *)cap_get_capPtr(cap), cap_get_capSizeBits(cap));
            copyGlobalMappings(capPtr);
        }
        break;

    case cap_page_directory_cap:
        if (cap_page_directory_cap_get_capPDMappedObject(cap)) {
            unmapPageDirectory(
                ((pdpte_t*)(cap_page_directory_cap_get_capPDMappedObject(cap))),
                cap_page_directory_cap_get_capPDMappedIndex(cap),
                ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(cap)))
            );
        }
        if (final) {
            unmapAllPageTables(
                ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(cap)))
            );
            flushAllPageTables(((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(cap))));
            clearMemory((void *)cap_get_capPtr(cap), cap_get_capSizeBits(cap));

            copyGlobalMappings((void*)cap_get_capPtr(cap));

        }
        if (cap_page_directory_cap_get_capPDMappedObject(cap) || final) {
            invalidateTLB();
            invalidatePageStructureCache();
        }
        break;

    case cap_page_table_cap:
        if (cap_page_table_cap_get_capPTMappedObject(cap)) {
            unmapPageTable(
                ((pde_t *)(cap_page_table_cap_get_capPTMappedObject(cap))),
                cap_page_table_cap_get_capPTMappedIndex(cap)
            );
        }
        if (final) {
            unmapAllPages(
                ((pte_t *)(cap_page_table_cap_get_capPTBasePtr(cap)))
            );
            clearMemory((void *)cap_get_capPtr(cap), cap_get_capSizeBits(cap));
        }
        if (cap_page_table_cap_get_capPTMappedObject(cap) || final) {
            flushTable(
                ((pde_t *)(cap_page_table_cap_get_capPTMappedObject(cap))),
                cap_page_table_cap_get_capPTMappedIndex(cap),
                ((pte_t *)(cap_page_table_cap_get_capPTBasePtr(cap)))
            );
        }
        break;

    case cap_frame_cap:
        if (cap_frame_cap_get_capFMappedObject(cap)) {
            switch (cap_frame_cap_get_capFMappedType(cap)) {
            case IA32_MAPPING_PD:
                finalisePDMappedFrame(cap);
                break;

            case IA32_MAPPING_EPT:
                /* The unmap function for EPT will unmap and flush */
                IA32PageUnmapEPT(cap);
                break;


            case IA32_MAPPING_IO:
                unmapIOPage(cap);
                break;

            default:
                _fail("Unknown mapping type for frame", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c", 261, __func__);
            }
        }
        break;


    case cap_vcpu_cap:
        if (final) {
            vcpu_finalise(((vcpu_t *)(cap_vcpu_cap_get_capVCPUPtr(cap))));
        }
        break;


    case cap_io_port_cap:
        break;

    case cap_io_space_cap:
        if (final) {
            /* Unmap any first level page table. */
            unmapVTDContextEntry(cap);
        }
        break;
    case cap_io_page_table_cap: {
        unmapIOPTCap(cap);
        if (final) {
            unmapAllIOPT(((vtd_pte_t*)(cap_get_capPtr(cap))),
                         cap_io_page_table_cap_get_capIOPTLevel(cap));
            memzero((void*)cap_get_capPtr(cap), (1ul<<(cap_get_capSizeBits(cap))));
            flushCacheRange(cap_get_capPtr(cap), cap_get_capSizeBits(cap));
            invalidate_iotlb();
        }
    }
    break;

    case cap_ipi_cap:
        break;


    case cap_ept_page_directory_pointer_table_cap:
        if (final) {
            ept_pdpte_t *pdpt = ((ept_pdpte_t *)(cap_ept_page_directory_pointer_table_cap_get_capPDPTBasePtr(cap)));
            unmapAllEPTPD(pdpt);
            memzero(pdpt, (1ul<<((9 +3))));
            invept((void*) ((uint32_t)pdpt - (1 << (9 +3))));
        }
        break;

    case cap_ept_page_directory_cap: {
        ept_pdpte_t *pdpt = ((ept_pdpte_t *)(cap_ept_page_directory_cap_get_capPDMappedObject(cap)));
        int index = cap_ept_page_directory_cap_get_capPDMappedIndex(cap);
        ept_pde_t *pd = ((ept_pde_t *)(cap_get_capPtr(cap)));
        if (pdpt) {
            unmapEPTPD(pdpt, index, pd);
        }
        if (final) {
            unmapAllEPTPT(pd);
            memzero((void *)cap_get_capPtr(cap), (1ul<<(cap_get_capSizeBits(cap))));
        }
        if (pdpt && final) {
            invept((void*) ((uint32_t)pdpt - (1 << (9 +3))));
        }
        break;
    }

    case cap_ept_page_table_cap: {
        ept_pde_t *pd = ((ept_pde_t *)(cap_ept_page_table_cap_get_capPTMappedObject(cap)));
        int index = cap_ept_page_table_cap_get_capPTMappedIndex(cap);
        ept_pte_t *pt = ((ept_pte_t *)(cap_get_capPtr(cap)));
        if (pd) {
            unmapEPTPT(pd, index, pt);
        }
        if (final) {
            unmapAllEPTPages(pt);
            memzero((void *)cap_get_capPtr(cap), (1ul<<(cap_get_capSizeBits(cap))));
        }
        if (pd && final) {
            ept_pdpte_t *pdpt;
            pdpt = lookupEPTPDPTFromPD(pd);
            if (pdpt) {
                invept((void*) ((uint32_t)pdpt - (1 << (9 +3))));
            }
        }
        break;
    }


    default:
        _fail("Invalid arch cap type", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c", 348, __func__);
    }

    return cap_null_cap_new();
}

static cap_t __attribute__((__const__))
resetMemMapping(cap_t cap)
{
    switch (cap_get_capType(cap)) {
    case cap_frame_cap:
        return cap_frame_cap_set_capFMappedObject(cap, 0);
    case cap_page_table_cap:
        return cap_page_table_cap_set_capPTMappedObject(cap, 0);
    case cap_page_directory_cap:
        return cap_page_directory_cap_set_capPDMappedObject(cap, 0);

    case cap_ept_page_directory_cap:
        return cap_ept_page_directory_cap_set_capPDMappedObject(cap, 0);
    case cap_ept_page_table_cap:
        return cap_ept_page_table_cap_set_capPTMappedObject(cap, 0);


    case cap_io_page_table_cap:
        return cap_io_page_table_cap_set_capIOPTMappedObject(cap, 0);

    default:
        break;
    }

    return cap;
}

cap_t Arch_recycleCap(bool_t is_final, cap_t cap)
{
    switch (cap_get_capType(cap)) {
    case cap_frame_cap:
        Arch_finaliseCap(cap, is_final);
        if (inKernelWindow((void *)cap_get_capPtr(cap))) {
            clearMemory((void *)cap_get_capPtr(cap), cap_get_capSizeBits(cap));
        }
        return resetMemMapping(cap);

    case cap_page_table_cap:
        Arch_finaliseCap(cap, true);
        return resetMemMapping(cap);

    case cap_page_directory_cap:
        Arch_finaliseCap(cap, true);
        return resetMemMapping(cap);

    case cap_pdpt_cap:
        Arch_finaliseCap(cap, true);
        return cap;


    case cap_vcpu_cap:
        vcpu_finalise(((vcpu_t *)(cap_vcpu_cap_get_capVCPUPtr(cap))));
        vcpu_init(((vcpu_t *)(cap_vcpu_cap_get_capVCPUPtr(cap))));
        return cap;



    case cap_io_port_cap:
        return cap;

    case cap_io_space_cap:
        Arch_finaliseCap(cap, true);
        return cap;

    case cap_io_page_table_cap:
        Arch_finaliseCap(cap, true);
        return resetMemMapping(cap);

    case cap_ipi_cap:
        return cap;


    case cap_ept_page_directory_pointer_table_cap:
        Arch_finaliseCap(cap, true);
        return cap;

    case cap_ept_page_directory_cap:
    case cap_ept_page_table_cap:
        Arch_finaliseCap(cap, true);
        return resetMemMapping(cap);

    default:
        _fail("Invalid arch cap type", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c", 436, __func__);
    }
}


bool_t __attribute__((__const__))
Arch_hasRecycleRights(cap_t cap)
{
    switch (cap_get_capType(cap)) {
    case cap_frame_cap:
        return cap_frame_cap_get_capFVMRights(cap) == VMReadWrite;

    default:
        return true;
    }
}


bool_t __attribute__((__const__)) Arch_sameRegionAs(cap_t cap_a, cap_t cap_b)
{
    switch (cap_get_capType(cap_a)) {
    case cap_frame_cap:
        if (cap_get_capType(cap_b) == cap_frame_cap) {
            word_t botA, botB, topA, topB;
            botA = cap_frame_cap_get_capFBasePtr(cap_a);
            botB = cap_frame_cap_get_capFBasePtr(cap_b);
            topA = botA + ((1ul<<(pageBitsForSize(cap_frame_cap_get_capFSize(cap_a))))-1ul);
            topB = botB + ((1ul<<(pageBitsForSize(cap_frame_cap_get_capFSize(cap_b))))-1ul);
            return ((botA <= botB) && (topA >= topB) && (botB <= topB));
        }
        break;

    case cap_page_table_cap:
        if (cap_get_capType(cap_b) == cap_page_table_cap) {
            return cap_page_table_cap_get_capPTBasePtr(cap_a) ==
                   cap_page_table_cap_get_capPTBasePtr(cap_b);
        }
        break;

    case cap_page_directory_cap:
        if (cap_get_capType(cap_b) == cap_page_directory_cap) {
            return cap_page_directory_cap_get_capPDBasePtr(cap_a) ==
                   cap_page_directory_cap_get_capPDBasePtr(cap_b);
        }
        break;
    case cap_pdpt_cap:
        if (cap_get_capType(cap_b) == cap_pdpt_cap) {
            return cap_pdpt_cap_get_capPDPTBasePtr(cap_a) ==
                   cap_pdpt_cap_get_capPDPTBasePtr(cap_b);
        }
        break;


    case cap_vcpu_cap:
        if (cap_get_capType(cap_b) == cap_vcpu_cap) {
            return cap_vcpu_cap_get_capVCPUPtr(cap_a) ==
                   cap_vcpu_cap_get_capVCPUPtr(cap_b);
        }
        break;


    case cap_io_port_cap:
        if (cap_get_capType(cap_b) == cap_io_port_cap) {
            return true;
        }
        break;

    case cap_io_space_cap:
        if (cap_get_capType(cap_b) == cap_io_space_cap) {
            return cap_io_space_cap_get_capPCIDevice(cap_a) ==
                   cap_io_space_cap_get_capPCIDevice(cap_b);
        }
        break;

    case cap_io_page_table_cap:
        if (cap_get_capType(cap_b) == cap_io_page_table_cap) {
            return cap_io_page_table_cap_get_capIOPTBasePtr(cap_a) ==
                   cap_io_page_table_cap_get_capIOPTBasePtr(cap_b);
        }
        break;

    case cap_ipi_cap:
        if (cap_get_capType(cap_b) == cap_ipi_cap) {
            return true;
        }
        break;


    case cap_ept_page_directory_pointer_table_cap:
        if (cap_get_capType(cap_b) == cap_ept_page_directory_pointer_table_cap) {
            return cap_ept_page_directory_pointer_table_cap_get_capPDPTBasePtr(cap_a) ==
                   cap_ept_page_directory_pointer_table_cap_get_capPDPTBasePtr(cap_b);
        }
        break;
    case cap_ept_page_directory_cap:
        if (cap_get_capType(cap_b) == cap_ept_page_directory_cap) {
            return cap_ept_page_directory_cap_get_capPDBasePtr(cap_a) ==
                   cap_ept_page_directory_cap_get_capPDBasePtr(cap_b);
        }
        break;
    case cap_ept_page_table_cap:
        if (cap_get_capType(cap_b) == cap_ept_page_table_cap) {
            return cap_ept_page_table_cap_get_capPTBasePtr(cap_a) ==
                   cap_ept_page_table_cap_get_capPTBasePtr(cap_b);
        }
        break;

    }

    return false;
}

bool_t __attribute__((__const__)) Arch_sameObjectAs(cap_t cap_a, cap_t cap_b)
{
    if (cap_get_capType(cap_a) == cap_frame_cap) {
        if (cap_get_capType(cap_b) == cap_frame_cap) {
            return ((cap_frame_cap_get_capFBasePtr(cap_a) ==
                     cap_frame_cap_get_capFBasePtr(cap_b)) &&
                    (cap_frame_cap_get_capFSize(cap_a) ==
                     cap_frame_cap_get_capFSize(cap_b)));
        }
    }
    return Arch_sameRegionAs(cap_a, cap_b);
}

word_t
Arch_getObjectSize(word_t t)
{
    switch (t) {
    case seL4_IA32_4K:
        return pageBitsForSize(IA32_SmallPage);
    case seL4_IA32_LargePage:
        return pageBitsForSize(IA32_LargePage);
    case seL4_IA32_PageTableObject:
        return 2 + 10;
    case seL4_IA32_PageDirectoryObject:
        return 2 + 10;
    case seL4_IA32_PDPTObject:
        return 0 + 0;

    case seL4_IA32_IOPageTableObject:
        return (9 + 3);


    case seL4_IA32_VCPUObject:
        return 14;
    case seL4_IA32_EPTPageDirectoryPointerTableObject:
        return 3 + 9 + 1;
    case seL4_IA32_EPTPageDirectoryObject:
        return 3 + 9;
    case seL4_IA32_EPTPageTableObject:
        return 3 + 9;

    default:
        _fail("Invalid object type", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c", 590, __func__);
        return 0;
    }
}

bool_t
Arch_isFrameType(word_t t)
{
    switch (t) {
    case seL4_IA32_4K:
        return true;
    case seL4_IA32_LargePage:
        return true;
    default:
        return false;
    }
}

cap_t
Arch_createObject(object_t t, void *regionBase, unsigned int userSize, bool_t deviceMemory)
{
    switch (t) {
    case seL4_IA32_4K:
        if (!deviceMemory) {
            memzero(regionBase, 1 << pageBitsForSize(IA32_SmallPage));
        }
        return cap_frame_cap_new(
                   IA32_SmallPage, /* capFSize             */
                   0, /* capFMappedObject     */
                   0, /* capFMappedIndex      */
                   IA32_MAPPING_PD, /* capFMappedType       */
                   VMReadWrite, /* capFVMRights         */
                   (word_t)regionBase /* capFBasePtr          */
               );

    case seL4_IA32_LargePage:
        if (!deviceMemory) {
            memzero(regionBase, 1 << pageBitsForSize(IA32_LargePage));
        }
        return cap_frame_cap_new(
                   IA32_LargePage, /* capFSize             */
                   0, /* capFMappedObject     */
                   0, /* capFMappedIndex      */
                   IA32_MAPPING_PD, /* capFMappedType       */
                   VMReadWrite, /* capFVMRights         */
                   (word_t)regionBase /* capFBasePtr          */
               );

    case seL4_IA32_PageTableObject:
        memzero(regionBase, 1 << (10 + 2));
        return cap_page_table_cap_new(
                   0, /* capPTMappedObject    */
                   0, /* capPTMappedIndex     */
                   (word_t)regionBase /* capPTBasePtr         */
               );

    case seL4_IA32_PageDirectoryObject:
        memzero(regionBase, 1 << (10 + 2));

        copyGlobalMappings(regionBase);

        return cap_page_directory_cap_new(
                   0, /* capPDmappedObject */
                   0, /* capPDMappedIndex  */
                   (word_t)regionBase /* capPDBasePtr      */
               );
# 668 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c"
    case seL4_IA32_IOPageTableObject:
        memzero(regionBase, 1 << (9 + 3));
        return cap_io_page_table_cap_new(
                   0, /* CapIOPTMappedLevel   */
                   0, /* capIOPTMappedObject  */
                   0, /* capIOPTMappedIndex   */
                   (word_t)regionBase /* capIOPTBasePtr */
               );


    case seL4_IA32_VCPUObject: {
        vcpu_t *vcpu;
        if (!vtx_enabled) {
            _fail("vtx not enabled", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c", 681, __func__);
        }
        memzero(regionBase, 1 << 14);
        vcpu = ((vcpu_t *)((word_t)regionBase));
        vcpu_init(vcpu);
        return cap_vcpu_cap_new(((unsigned int)(vcpu)));
    }
    case seL4_IA32_EPTPageDirectoryPointerTableObject: {
        ept_pml4e_t *pml4;
        memzero(regionBase, 1 << (3 + 9 + 1));
        pml4 = (ept_pml4e_t*)((word_t)regionBase);
        IA32EptPdpt_Init(pml4);
        return cap_ept_page_directory_pointer_table_cap_new(
                   (word_t)regionBase + (1 << (9 +3)) /* capPTBasePtr   */);
    }
    case seL4_IA32_EPTPageDirectoryObject:
        memzero(regionBase, 1 << (3 + 9));

        return cap_ept_page_directory_cap_new(
                   0, /* capPDMappedObject    */
                   0, /* capPDMappedIndex     */
                   (word_t)regionBase /* capPTBasePtr         */
               );
    case seL4_IA32_EPTPageTableObject:
        memzero(regionBase, 1 << (3 + 9));

        return cap_ept_page_table_cap_new(
                   0, /* capPTMappedObject    */
                   0, /* capPTMappedIndex     */
                   (word_t)regionBase /* capPTBasePtr         */
               );


    default:
        /*
         * This is a conflation of the haskell error: "Arch.createNewCaps
         * got an API type" and the case where an invalid object type is
         * passed (which is impossible in haskell).
         */
        _fail("Arch_createObject got an API type or invalid object type", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/objecttype.c", 720, __func__);
    }
}

exception_t
Arch_decodeInvocation(
    word_t label,
    unsigned int length,
    cptr_t cptr,
    cte_t* slot,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    switch (cap_get_capType(cap)) {
    case cap_pdpt_cap:
    case cap_page_directory_cap:
    case cap_page_table_cap:
    case cap_frame_cap:
        return decodeIA32MMUInvocation(label, length, cptr, slot, cap, extraCaps, buffer);

    case cap_io_port_cap:
        return decodeIA32PortInvocation(label, length, cptr, slot, cap, extraCaps, buffer);

    case cap_io_space_cap:
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;
    case cap_io_page_table_cap:
        return decodeIA32IOPTInvocation(label, length, slot, cap, extraCaps, buffer);

    case cap_ipi_cap:
        return decodeIA32IPIInvocation(label, length, cptr, slot, cap, extraCaps, buffer);


    case cap_ept_page_directory_pointer_table_cap:
    case cap_ept_page_directory_cap:
    case cap_ept_page_table_cap:
        return decodeIA32EPTInvocation(label, length, cptr, slot, cap, extraCaps, buffer);



    case cap_vcpu_cap:
        return decodeIA32VCPUInvocation(label, length, cptr, slot, cap, extraCaps, buffer);

    default:
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;
    }
}

void
Arch_prepareThreadDelete(tcb_t *thread)
{
    /* Notify the lazy FPU module about this thread's deletion. */
    Arch_fpuThreadDelete(thread);


    if (thread->tcbArch.vcpu) {
        dissociateVcpuTcb(thread, thread->tcbArch.vcpu);
    }

}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c" 2

/* NOTE: offset is either 1 or 3 */
static inline unsigned int
setMRs_lookup_failure(tcb_t *receiver, word_t* receiveIPCBuffer, lookup_fault_t luf, unsigned int offset)
{
    word_t lufType = lookup_fault_get_lufType(luf);

    if(!(n_msgRegisters == 2)) _assert_fail("n_msgRegisters == 2", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c", 25, __FUNCTION__);

    if (offset < n_msgRegisters) {
        setRegister(receiver, msgRegisters[offset], lufType + 1);
    }

    if (!receiveIPCBuffer) {
        return n_msgRegisters;
    }

    if (offset >= n_msgRegisters) {
        receiveIPCBuffer[offset + 1] = lufType + 1;
    }

    switch (lufType) {
    case lookup_fault_invalid_root:
        return offset + 1;

    case lookup_fault_missing_capability:
        receiveIPCBuffer[offset + 2] =
            lookup_fault_missing_capability_get_bitsLeft(luf);
        return offset + 2;

    case lookup_fault_depth_mismatch:
        receiveIPCBuffer[offset + 2] =
            lookup_fault_depth_mismatch_get_bitsLeft(luf);
        receiveIPCBuffer[offset + 3] =
            lookup_fault_depth_mismatch_get_bitsFound(luf);
        return offset + 3;

    case lookup_fault_guard_mismatch:
        receiveIPCBuffer[offset + 2] =
            lookup_fault_guard_mismatch_get_bitsLeft(luf);
        receiveIPCBuffer[offset + 3] =
            lookup_fault_guard_mismatch_get_guardFound(luf);
        receiveIPCBuffer[offset + 4] =
            lookup_fault_guard_mismatch_get_bitsFound(luf);
        return offset + 4;

    default:
        _fail("Invalid lookup failure", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c", 65, __func__);
    }
}

unsigned int setMRs_fault(tcb_t *sender, tcb_t* receiver, word_t *receiveIPCBuffer)
{
    if(!(n_msgRegisters == 2)) _assert_fail("n_msgRegisters == 2", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c", 71, __FUNCTION__);

    switch (fault_get_faultType(sender->tcbFault)) {
    case fault_cap_fault:
        setRegister(receiver, msgRegisters[0], getRestartPC(sender));
        setRegister(receiver, msgRegisters[1],
                    fault_cap_fault_get_address(sender->tcbFault));
        if (!receiveIPCBuffer) {
            return n_msgRegisters;
        }
        receiveIPCBuffer[2 + 1] =
            fault_cap_fault_get_inReceivePhase(sender->tcbFault);
        return setMRs_lookup_failure(receiver, receiveIPCBuffer, sender->tcbLookupFailure, 3);

    case fault_vm_fault:
        setRegister(receiver, msgRegisters[0], getRestartPC(sender));
        setRegister(receiver, msgRegisters[1],
                    fault_vm_fault_get_address(sender->tcbFault));
        if (!receiveIPCBuffer) {
            return n_msgRegisters;
        }
        receiveIPCBuffer[2 + 1] =
            fault_vm_fault_get_instructionFault(sender->tcbFault);
        receiveIPCBuffer[3 + 1] = fault_vm_fault_get_FSR(sender->tcbFault);
        return 4;

    case fault_unknown_syscall: {
        unsigned int i;

        for (i = 0; i < n_msgRegisters; i++) {
            setRegister(receiver, msgRegisters[i],
                        getRegister(sender, syscallMessage[i]));
        }
        if (receiveIPCBuffer) {
            for (; i < n_syscallMessage; i++) {
                receiveIPCBuffer[i + 1] =
                    getRegister(sender, syscallMessage[i]);
            }

            receiveIPCBuffer[i + 1] =
                fault_unknown_syscall_get_syscallNumber(sender->tcbFault);
            return n_syscallMessage + 1;
        } else {
            return n_msgRegisters;
        }
    }

    case fault_user_exception: {
        unsigned int i;

        for (i = 0; i < n_msgRegisters; i++) {
            setRegister(receiver, msgRegisters[i],
                        getRegister(sender, exceptionMessage[i]));
        }
        if (receiveIPCBuffer) {
            for (; i < n_exceptionMessage; i++) {
                receiveIPCBuffer[i + 1] =
                    getRegister(sender, exceptionMessage[i]);
            }
            receiveIPCBuffer[n_exceptionMessage + 1] =
                fault_user_exception_get_number(sender->tcbFault);
            receiveIPCBuffer[n_exceptionMessage + 2] =
                fault_user_exception_get_code(sender->tcbFault);
            return n_exceptionMessage + 2;
        } else {
            return n_msgRegisters;
        }
    }

    default:
        _fail("Invalid fault", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c", 141, __func__);
    }
}

unsigned int setMRs_syscall_error(tcb_t *thread, word_t *receiveIPCBuffer)
{
    if(!(n_msgRegisters >= 2)) _assert_fail("n_msgRegisters >= 2", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c", 147, __FUNCTION__);

    switch (current_syscall_error.type) {
    case seL4_InvalidArgument:
        setRegister(thread, msgRegisters[0],
                    current_syscall_error.invalidArgumentNumber);
        return 1;

    case seL4_InvalidCapability:
        setRegister(thread, msgRegisters[0],
                    current_syscall_error.invalidCapNumber);
        return 1;

    case seL4_IllegalOperation:
        return 0;

    case seL4_RangeError:
        setRegister(thread, msgRegisters[0],
                    current_syscall_error.rangeErrorMin);
        setRegister(thread, msgRegisters[1],
                    current_syscall_error.rangeErrorMax);
        return 2;

    case seL4_AlignmentError:
        return 0;

    case seL4_FailedLookup:
        setRegister(thread, msgRegisters[0],
                    current_syscall_error.failedLookupWasSource ? 1 : 0);
        return setMRs_lookup_failure(thread, receiveIPCBuffer,
                                     current_lookup_fault, 1);

    case seL4_TruncatedMessage:
    case seL4_DeleteFirst:
    case seL4_RevokeFirst:
        return 0;
    case seL4_NotEnoughMemory:
        setRegister(thread, msgRegisters[0],
                    current_syscall_error.memoryLeft);
        return 0;
    default:
        _fail("Invalid syscall error", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/tcb.c", 188, __func__);
    }
}

word_t __attribute__((__const__)) Arch_decodeTransfer(word_t flags)
{
    return 0;
}

exception_t __attribute__((__const__)) Arch_performTransfer(word_t arch, tcb_t *tcb_src, tcb_t *tcb_dest)
{
    return EXCEPTION_NONE;
}

void Arch_leaveVMAsyncTransfer(tcb_t *tcb)
{

    vcpu_t *vcpu = tcb->tcbArch.vcpu;
    word_t *buffer;
    if (vcpu) {
        if (current_vmcs != vcpu) {
            vmptrld(vcpu);
        }

        setRegister(tcb, msgRegisters[0], vmread(0x0000681E));
        setRegister(tcb, msgRegisters[1], vmread(0x00004002));
        buffer = lookupIPCBuffer(true, tcb);
        if (!buffer) {
            return;
        }

        buffer[3] = vmread(0x00004016);
    }

}


exception_t decodeSetEPTRoot(cap_t cap, extra_caps_t extraCaps)
{
    tcb_t *tcb;
    cte_t *rootSlot;
    exception_t e;

    if (extraCaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 232, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB SetEPTRoot: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (cap_get_capType(extraCaps.excaprefs[0]->cap) != cap_ept_page_directory_pointer_table_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 238, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB SetEPTRoot: EPT PDPT is invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    tcb = ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap)));
    rootSlot = (((cte_t *)((unsigned int)(tcb)&~((1ul<<(10))-1ul)))+(tcbArchEPTRoot));
    e = cteDelete(rootSlot, true);
    if (e != EXCEPTION_NONE) {
        return e;
    }

    cteInsert(extraCaps.excaprefs[0]->cap, extraCaps.excaprefs[0], rootSlot);

    setThreadState(ksCurThread, ThreadState_Restart);
    return EXCEPTION_NONE;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c" 2



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/cpu_registers.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/vcpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/vtx.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 26 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c" 2
# 42 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c"
/* Store fixed field values. */
uint32_t pin_control_high;
uint32_t pin_control_low;
uint32_t primary_control_high;
uint32_t primary_control_low;
uint32_t secondary_control_high;
uint32_t secondary_control_low;
uint32_t entry_control_high;
uint32_t entry_control_low;
uint32_t exit_control_high;
uint32_t exit_control_low;
uint32_t cr0_high;
uint32_t cr0_low;
uint32_t cr4_high;
uint32_t cr4_low;

static void
applyHardwareFixedBits(uint32_t msr, uint32_t* high, uint32_t* low)
{
    uint32_t old_high __attribute__((unused)), old_low __attribute__((unused));
    old_high = *high;
    old_low = *low;
    *high |= ia32_rdmsr_low(msr);
    *low &= ia32_rdmsr_high(msr);
}

static void
applyHardwareFixedBitsSplit(uint32_t msr_high, uint32_t msr_low, uint32_t* high, uint32_t* low)
{
    uint32_t old_high __attribute__((unused)), old_low __attribute__((unused));
    old_high = *high;
    old_low = *low;
    *high |= ia32_rdmsr_low(msr_high);
    *low &= ia32_rdmsr_low(msr_low);
}

bool_t
init_vtx_fixed_values(bool_t useTrueMsrs)
{
    uint32_t msr_true_offset = useTrueMsrs ? 0x48D - 0x481 : 0;
    const uint32_t pin_control_mask =
        (1ul<<(0)) | //Extern interrlt exiting
        (1ul<<(3)) | //NMI exiting
        (1ul<<(5)); //virtual NMIs
    const uint32_t primary_control_mask =
        (1ul<<(25)) | //Use I/O bitmaps
        (1ul<<(28)) | //Use MSR bitmaps
        (1ul<<(31)); //Activate secondary controls
    const uint32_t secondary_control_mask =
        (1ul<<(1)) | //Enable EPT
        (1ul<<(5)); //Enable VPID
    pin_control_high = pin_control_mask;
    pin_control_low = ~0;
    applyHardwareFixedBits(0x481 + msr_true_offset, &pin_control_high, &pin_control_low);
    if ((pin_control_low & pin_control_mask) != pin_control_mask) {
        return false;
    }
    primary_control_high = primary_control_mask;
    primary_control_low = ~0;
    applyHardwareFixedBits(0x482 + msr_true_offset, &primary_control_high, &primary_control_low);
    if ((primary_control_low & primary_control_mask) != primary_control_mask) {
        return false;
    }
    secondary_control_high = secondary_control_mask;
    secondary_control_low = ~0;
    applyHardwareFixedBits(0x48B, &secondary_control_high, &secondary_control_low);
    if ((secondary_control_low & secondary_control_mask) != secondary_control_mask) {
        return false;
    }
    exit_control_high = (1ul<<(15)); //Acknowledge interrupt on exit
    exit_control_low = ~0;
    applyHardwareFixedBits(0x483 + msr_true_offset, &exit_control_high, &exit_control_low);
    if ((exit_control_low & (1ul<<(15))) != (1ul<<(15))) {
        return false;
    }
    entry_control_high = 0;
    entry_control_low = ~0;
    applyHardwareFixedBits(0x484 + msr_true_offset, &entry_control_high, &entry_control_low);
    cr0_high = 0;
    cr0_low = ~0;
    applyHardwareFixedBitsSplit(0x486, 0x487, &cr0_high, &cr0_low);
    cr4_high = 0;
    cr4_low = ~0;
    applyHardwareFixedBitsSplit(0x488, 0x489, &cr4_high, &cr4_low);
    return true;
}

static uint32_t
applyFixedBits(uint32_t original, uint32_t high, uint32_t low)
{
    original |= high;
    original &= low;
    return original;
}

void
vcpu_init(vcpu_t *vcpu)
{
    uint32_t *vmcs = (uint32_t*)vcpu;
    vcpu->tcb = ((void *)0);
    vcpu->launched = false;

    *vmcs = vmcs_revision;

    vmclear(vcpu);
    vmptrld(vcpu);

    /* Set fixed host state. */
    /*vmwrite(VMX_HOST_PAT, 0);
    vmwrite(VMX_HOST_EFER, 0);
    vmwrite(VMX_HOST_PERF_GLOBAL_CTRL, 0);*/
    vmwrite(0x00006C00, read_cr0());
    /* CR3 is set dynamically. */
    vmwrite(0x00006C04, read_cr4());
    vmwrite(0x00006C06, 0);
    vmwrite(0x00006C08, 0);
    vmwrite(0x00006C0A, (uint32_t)&ia32KStss);
    vmwrite(0x00006C0C, (uint32_t)ia32KSgdt);
    vmwrite(0x00006C0E, (uint32_t)ia32KSidt);
    vmwrite(0x00004C00, (uint32_t)(1 << 3));
    vmwrite(0x00006C12, (uint32_t)&handle_syscall);
    vmwrite(0x00006C10, (uint32_t)&ia32KStss.words[1]);
    /* Set host SP to point just beyond the first field to be stored on exit. */
    vmwrite(0x00006C14, (uint32_t)&vcpu->gp_registers[EBP + 1]);
    vmwrite(0x00006C16, (uint32_t)&handle_vmexit);

    vmwrite(0x00000C00, (2 << 3));
    vmwrite(0x00000C02, (1 << 3));
    vmwrite(0x00000C04, (2 << 3));
    vmwrite(0x00000C06, (2 << 3));
    vmwrite(0x00000C08, 0);
    vmwrite(0x00000C0A, 0);
    vmwrite(0x00000C0C, (5 << 3));

    /* Set fixed VMCS control fields. */
    vmwrite(0x00004000, applyFixedBits(0, pin_control_high, pin_control_low));
    vmwrite(0x00004002, applyFixedBits(0, primary_control_high, primary_control_low));
    vmwrite(0x0000401E, applyFixedBits(0, secondary_control_high, secondary_control_low));
    vmwrite(0x0000400C, applyFixedBits(0, exit_control_high, exit_control_low));
    vmwrite(0x00004012, applyFixedBits(0, entry_control_high, entry_control_low));
    vmwrite(0x00002004, (uint32_t)pptr_to_paddr(msr_bitmap));
    vmwrite(0x00006800, applyFixedBits(0, cr0_high, cr0_low));
    vmwrite(0x00006804, applyFixedBits(0, cr4_high, cr4_low));
    /* VPID is the same as the VCPU */
    vmwrite(0x00000000, vpid_for_vcpu(vcpu));

    vmwrite(0x00002800, ~0);
    vmwrite(0x00002801, ~0);

    memset(vcpu->io, ~0, 8192);
    vmwrite(0x00002000, pptr_to_paddr(vcpu->io));
    vmwrite(0x00002002, pptr_to_paddr((char *)vcpu->io + 4096));
    vcpu->io_min = -1;
    vcpu->io_max = -1;
    vcpu->cr0 = applyFixedBits(0, cr0_high, cr0_low);
    vcpu->cr0_shadow = 0;
    vcpu->cr0_mask = 0;
    vcpu->exception_mask = 0;
}

void
vcpu_finalise(vcpu_t *vcpu)
{
    if (vcpu->tcb) {
        dissociateVcpuTcb(vcpu->tcb, vcpu);
    }
    if (current_vmcs == vcpu) {
        current_vmcs = ((void *)0);
    }
    vmclear(vcpu);
}

void
associateVcpuTcb(tcb_t *tcb, vcpu_t *vcpu)
{
    if (tcb->tcbArch.vcpu) {
        dissociateVcpuTcb(tcb, tcb->tcbArch.vcpu);
    }
    if (vcpu->tcb) {
        dissociateVcpuTcb(vcpu->tcb, vcpu);
    }
    vcpu->tcb = tcb;
    tcb->tcbArch.vcpu = vcpu;
}

void
dissociateVcpuTcb(tcb_t *tcb, vcpu_t *vcpu)
{
    if (tcb->tcbArch.vcpu != vcpu || vcpu->tcb != tcb) {
        _fail("TCB and VCPU not associated.", "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vcpu.c", 231, __func__);
    }
    tcb->tcbArch.vcpu = ((void *)0);
    vcpu->tcb = ((void *)0);
}

exception_t decodeIA32VCPUInvocation(
    word_t label,
    unsigned int length,
    cptr_t cptr,
    cte_t* slot,
    cap_t cap,
    extra_caps_t extraCaps,
    word_t* buffer
)
{
    switch (label) {
    case IA32VCPUSetTCB:
        return decodeSetTCB(cap, length, buffer, extraCaps);
    case IA32VCPUReadVMCS:
        return decodeReadVMCS(cap, length, buffer);
    case IA32VCPUWriteVMCS:
        return decodeWriteVMCS(cap, length, buffer);
    case IA32VCPUSetIOPort:
        return decodeSetIOPort(cap, length, buffer, extraCaps);
    case IA32VCPUSetIOPortMask:
        return decodeSetIOPortMask(cap, length, buffer);
    case IA32VCPUWriteRegisters:
        return decodeVCPUWriteRegisters(cap, length, buffer);
    default:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 261, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("VCPU: Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }
}

exception_t
decodeVCPUWriteRegisters(cap_t cap, unsigned int length, word_t *buffer)
{
    vcpu_t *vcpu;
    if (length < 7) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 272, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("VCPU WriteRegisters: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }
    vcpu = ((vcpu_t *)(cap_vcpu_cap_get_capVCPUPtr(cap)));
    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeVCPUWriteRegisters(vcpu, buffer);
}

exception_t
decodeSetIOPortMask(cap_t cap, unsigned int length, word_t *buffer)
{
    uint32_t low, high;
    int mask;
    vcpu_t *vcpu;
    if (length < 3) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 288, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("VCPU SetIOPortMask: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }
    low = getSyscallArg(0, buffer);
    high = getSyscallArg(1, buffer);
    mask = getSyscallArg(2, buffer) == 0 ? 0 : 1;
    vcpu = ((vcpu_t *)(cap_vcpu_cap_get_capVCPUPtr(cap)));
    if (low < vcpu->io_min || high > vcpu->io_max) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 297, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("VCPU SetIOPortMask: Invalid range."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }
    if (vcpu->io_min == -1 || vcpu->io_max == -1) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 302, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("VCPU SetIOPortMask: No IO port set."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }
    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeSetIOPortMask(vcpu, low, high, mask);
}

exception_t
invokeSetIOPortMask(vcpu_t *vcpu, uint32_t low, uint32_t high, int mask)
{
    while (low <= high) {
        /* See if we can optimize a whole word of bits */
        if (low % 32 == 0 && low / 32 != high / 32) {
            vcpu->io[low / 32] = mask ? ~0 : 0;
            low += 32;
        } else {
            if (mask) {
                vcpu->io[low / 32] |= (1ul<<(low % 32));
            } else {
                vcpu->io[low / 32] &= ~(1ul<<(low % 32));
            }
            low++;
        }
    }
    return EXCEPTION_NONE;
}

exception_t
decodeSetIOPort(cap_t cap, unsigned int length, word_t* buffer, extra_caps_t extraCaps)
{
    cap_t ioCap;
    cte_t *tcbSlot;
    deriveCap_ret_t dc_ret;
    if (extraCaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 337, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("VCPU SetIOPort: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }
    tcbSlot = extraCaps.excaprefs[0];
    ioCap = extraCaps.excaprefs[0]->cap;

    dc_ret = deriveCap(tcbSlot, ioCap);
    if (dc_ret.status != EXCEPTION_NONE) {
        return dc_ret.status;
    }
    ioCap = dc_ret.cap;
    if (cap_get_capType(ioCap) != cap_io_port_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 350, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IOPort cap is not a IOPort cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeSetIOPort(((vcpu_t *)(cap_vcpu_cap_get_capVCPUPtr(cap))), ioCap);
}

exception_t
invokeVCPUWriteRegisters(vcpu_t *vcpu, word_t *buffer)
{
    int i;
    for (i = 0; i <= EBP; i++) {
        vcpu->gp_registers[i] = getSyscallArg(i, buffer);
    }
    return EXCEPTION_NONE;
}

exception_t
invokeSetIOPort(vcpu_t *vcpu, cap_t cap)
{
    uint32_t high, low;
    vcpu->io_port = cap;
    low = cap_io_port_cap_get_capIOPortFirstPort(cap);
    high = cap_io_port_cap_get_capIOPortLastPort(cap) + 1;
    // Set the range
    vcpu->io_min = low;
    vcpu->io_max = high;
    // Clear the IO ports
    /* There is no point clearing the IO ports as we have no
     * security model anyway, so might as well let multiple
     * io ports be set to allow different ranges to be
     * masked */
//    memset(vcpu->io, ~0, 8192);
    return EXCEPTION_NONE;
}



exception_t
decodeWriteVMCS(cap_t cap, unsigned int length, word_t* buffer)
{
    uint32_t fields[32];
    uint32_t values[32];
    int num_fields;
    int i;
    if (length > 32 * 2) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 398, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("VCPU WriteVMCS: Too many arguments."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }
    num_fields = length / 2;
    for (i = 0; i < num_fields; i++) {
        uint32_t field = getSyscallArg(i * 2 + 0, buffer);
        uint32_t value = getSyscallArg(i * 2 + 1, buffer);
        switch (field) {
        case 0x0000681E:
        case 0x0000681C:
        case 0x00000800:
        case 0x00000802:
        case 0x00000804:
        case 0x00000806:
        case 0x00000808:
        case 0x0000080A:
        case 0x0000080C:
        case 0x0000080E:
        case 0x00002802:
        case 0x00002804:
        case 0x00002806:
        case 0x00002808:
        case 0x0000280A:
        case 0x0000280C:
        case 0x0000280E:
        case 0x00002810:
        case 0x00004800:
        case 0x00004802:
        case 0x00004804:
        case 0x00004806:
        case 0x00004808:
        case 0x0000480A:
        case 0x0000480C:
        case 0x0000480E:
        case 0x00004810:
        case 0x00004812:
        case 0x00004814:
        case 0x00004816:
        case 0x00004818:
        case 0x0000481A:
        case 0x0000481C:
        case 0x0000481E:
        case 0x00004820:
        case 0x00004822:
        case 0x00004824:
        case 0x00004826:
        case 0x00004828:
        case 0x0000482A:
        case 0x0000482E:
        case 0x00006806:
        case 0x00006808:
        case 0x0000680A:
        case 0x0000680C:
        case 0x0000680E:
        case 0x00006810:
        case 0x00006812:
        case 0x00006814:
        case 0x00006816:
        case 0x00006818:
        case 0x0000681A:
        case 0x00006820:
        case 0x00006822:
        case 0x00006824:
        case 0x00006826:
        case 0x00006000:
        case 0x00006002:
        case 0x00006004:
        case 0x00006006:
        case 0x00006802:
        case 0x00004004:
            break;
        case 0x00004016:
            value &= ~(((1ul<<(31 - 12))-1ul) << 12);
            break;
        case 0x00004000:
            value = applyFixedBits(value, pin_control_high, pin_control_low);
            break;
        case 0x00004002:
            value = applyFixedBits(value, primary_control_high, primary_control_low);
            break;
        case 0x0000401E:
            value = applyFixedBits(value, secondary_control_high, secondary_control_low);
            break;
        case 0x0000400C:
            value = applyFixedBits(value, exit_control_high, exit_control_low);
            break;
        case 0x00006800:
            value = applyFixedBits(value, cr0_high, cr0_low);
            break;
        case 0x00006804:
            value = applyFixedBits(value, cr4_high, cr4_low);
            break;
        default:
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 492, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("VCPU WriteVMCS: Invalid field %x.", field); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }
        fields[i] = field;
        values[i] = value;
    }
    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeWriteVMCS(((vcpu_t *)(cap_vcpu_cap_get_capVCPUPtr(cap))), num_fields, fields, values);
}
exception_t
invokeWriteVMCS(vcpu_t *vcpu, int num_fields, uint32_t *fields, uint32_t *values)
{
    tcb_t *thread;
    int i;
    thread = ksCurThread;
    if (current_vmcs != vcpu) {
        vmptrld(vcpu);
    }
    for (i = 0; i < num_fields; i++) {
        uint32_t field = fields[i];
        uint32_t value = values[i];
        switch (field) {
        case 0x00004004:
            vcpu->exception_mask = vcpu->written_exception_mask = value;
            break;
        case 0x00006800:
            vcpu->cr0 = vcpu->written_cr0 = value;
            break;
        case 0x00006000:
            vcpu->cr0_mask = vcpu->written_cr0_mask = value;
            break;
        case 0x00006004:
            vcpu->cr0_shadow = vcpu->written_cr0_shadow = value;
            break;
        }
        setRegister(thread, msgRegisters[0], value);
        vmwrite(field, value);
    }
    return EXCEPTION_NONE;
}

exception_t
decodeReadVMCS(cap_t cap, unsigned int length, word_t* buffer)
{
    uint32_t fields[32];
    int num_fields;
    int i;
    if (length > 32) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 541, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("VCPU ReadVMCS: Too many arguments."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }
    num_fields = length;
    for (i = 0; i < num_fields; i++) {
        uint32_t field = getSyscallArg(i, buffer);
        switch (field) {
        case 0x0000681E:
        case 0x0000681C:
        case 0x00000800:
        case 0x00000802:
        case 0x00000804:
        case 0x00000806:
        case 0x00000808:
        case 0x0000080A:
        case 0x0000080C:
        case 0x0000080E:
        case 0x00002802:
        case 0x00002804:
        case 0x00002806:
        case 0x00002808:
        case 0x0000280A:
        case 0x0000280C:
        case 0x0000280E:
        case 0x00002810:
        case 0x00004800:
        case 0x00004802:
        case 0x00004804:
        case 0x00004806:
        case 0x00004808:
        case 0x0000480A:
        case 0x0000480C:
        case 0x0000480E:
        case 0x00004810:
        case 0x00004812:
        case 0x00004814:
        case 0x00004816:
        case 0x00004818:
        case 0x0000481A:
        case 0x0000481C:
        case 0x0000481E:
        case 0x00004820:
        case 0x00004822:
        case 0x00004824:
        case 0x00004826:
        case 0x00004828:
        case 0x0000482A:
        case 0x0000482E:
        case 0x00006806:
        case 0x00006808:
        case 0x0000680A:
        case 0x0000680C:
        case 0x0000680E:
        case 0x00006810:
        case 0x00006812:
        case 0x00006814:
        case 0x00006816:
        case 0x00006818:
        case 0x0000681A:
        case 0x00006820:
        case 0x00006822:
        case 0x00006824:
        case 0x00006826:
        case 0x00006000:
        case 0x00006002:
        case 0x00006004:
        case 0x00006006:
        case 0x00004400:
        case 0x00004404:
        case 0x00004406:
        case 0x00004408:
        case 0x0000440A:
        case 0x0000440C:
        case 0x0000440E:
        case 0x00002400:
        case 0x00006402:
        case 0x00006404:
        case 0x00006406:
        case 0x00006408:
        case 0x0000640A:
        case 0x00004016:
        case 0x00004000:
        case 0x00004002:
        case 0x00004004:
        case 0x0000400C:
        case 0x00006800:
        case 0x00006802:
        case 0x00006804:
            break;
        default:
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 632, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("VCPU ReadVMCS: Invalid field %x.", field); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }
        fields[i] = field;
    }
    return invokeReadVMCS(((vcpu_t *)(cap_vcpu_cap_get_capVCPUPtr(cap))), num_fields, fields);
}

static uint32_t readVMCSfield(vcpu_t *vcpu, uint32_t field)
{
    switch (field) {
    case 0x00004404:
        return vcpu->interrupt_info;
    case 0x00004004:
        return vcpu->exception_mask;
    case 0x00006800:
        return vcpu->cr0;
    case 0x00006000:
        return vcpu->cr0_mask;
    case 0x00006004:
        return vcpu->cr0_shadow;
    }
    if (current_vmcs != vcpu) {
        vmptrld(vcpu);
    }
    return vmread(field);
}

exception_t
invokeReadVMCS(vcpu_t *vcpu, int num_fields, uint32_t *fields)
{
    tcb_t *thread;
    int i;
    word_t *sendBuf;
    thread = ksCurThread;
    sendBuf = lookupIPCBuffer(true, thread);

    for (i = 0; i < n_msgRegisters && i < num_fields; i++) {
        setRegister(thread, msgRegisters[i], readVMCSfield(vcpu, fields[i]));
    }
    if (sendBuf) {
        for (; i < num_fields; i++) {
            sendBuf[i + 1] = readVMCSfield(vcpu, fields[i]);
        }
    }
    setRegister(thread, msgInfoRegister, wordFromMessageInfo(
                    message_info_new(0, 0, 0, i)));
    setThreadState(thread, ThreadState_Running);
    return EXCEPTION_NONE;
}


exception_t
decodeSetTCB(cap_t cap, unsigned int length, word_t* buffer, extra_caps_t extraCaps)
{
    cap_t tcbCap;
    cte_t *tcbSlot;
    deriveCap_ret_t dc_ret;
    if ( extraCaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 692, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("VCPU SetTCB: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }
    tcbSlot = extraCaps.excaprefs[0];
    tcbCap = extraCaps.excaprefs[0]->cap;

    dc_ret = deriveCap(tcbSlot, tcbCap);
    if (dc_ret.status != EXCEPTION_NONE) {
        return dc_ret.status;
    }
    tcbCap = dc_ret.cap;
    if (cap_get_capType(tcbCap) != cap_thread_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 705, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB cap is not a TCB cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeSetTCB(((vcpu_t *)(cap_vcpu_cap_get_capVCPUPtr(cap))), ((tcb_t *)(cap_thread_cap_get_capTCBPtr(tcbCap))));
}

exception_t
invokeSetTCB(vcpu_t *vcpu, tcb_t *tcb)
{
    associateVcpuTcb(tcb, vcpu);

    return EXCEPTION_NONE;
}

uint16_t vpid_for_vcpu(vcpu_t *vcpu)
{
    return (((uint32_t)vcpu) >> 13) & ((1ul<<(16))-1ul);
}

void vcpu_update_vmenter_state(vcpu_t *vcpu)
{
    word_t *buffer;
    if (current_vmcs != vcpu) {
        vmptrld(vcpu);
    }
    vmwrite(0x0000681E, getRegister(ksCurThread, msgRegisters[0]));
    vmwrite(0x00004002, applyFixedBits(getRegister(ksCurThread, msgRegisters[1]), primary_control_high, primary_control_low));
    buffer = lookupIPCBuffer(false, ksCurThread);
    if (!buffer) {
        return;
    }
    vmwrite(0x00004016, buffer[3] & (~(((1ul<<(31 - 12))-1ul) << 12)));
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/faulthandler.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/cpu_registers.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 26 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/vtx.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 27 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/vcpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 28 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine/fpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 29 "/home/kq/Sources/RefOS_x86/kernel/src/arch/x86/object/vtx.c" 2





uint32_t vtx_enabled = 0;
/* Address of the current VMCS: the one loaded by the CPU. */
void *current_vmcs = ((void *)0);
uint32_t null_ept_space = 0;
uint32_t vmcs_revision = 0;
uint32_t* msr_bitmap = ((void *)0);
uint64_t vpid_capability = 0;
uint32_t vtx_memory[3];

static int is_vtx_supported(void)
{
    uint32_t reg_ecx, reg_edx;

    __asm__ volatile (
        "cpuid\n"
        : "=c"(reg_ecx), "=d"(reg_edx)
        : "a"(1)
        : "ebx"
    );
    return (reg_ecx & reg_edx & (1ul<<(5)));
}

__attribute__((__section__(".boot.text"))) bool_t vtx_allocate(void)
{
    vtx_memory[0] = alloc_region(IA32_4K_bits);
    vtx_memory[1] = alloc_region(IA32_4K_bits);
    vtx_memory[2] = alloc_region(IA32_4K_bits);
    return vtx_memory[0] && vtx_memory[1] && vtx_memory[2];
}

__attribute__((__section__(".boot.text"))) void vtx_enable(void)
{
    if (is_vtx_supported()) {
        uint64_t feature_control = ((uint64_t)ia32_rdmsr_high(0x3A)) << 32 | (uint64_t)ia32_rdmsr_low(0x3A);
        uint64_t vm_basic = ((uint64_t)ia32_rdmsr_high(0x480)) << 32 | (uint64_t)ia32_rdmsr_low(0x480);
        vmcs_revision = vm_basic;
        if ((feature_control & ((1ul<<(0)) | (1ul<<(2)))) == ((1ul<<(0)) | (1ul<<(2)))) {
            uint32_t vm_basic_high = vm_basic >> 32;
            if (init_vtx_fixed_values((vm_basic_high & (1ul<<(55 - 32))) == (1ul<<(55 - 32)))) {
                uint32_t *vmxon_region;
                uint64_t vmxon_region_arg;
                uint8_t error = 0;
                vmxon_region = (uint32_t *)vtx_memory[0];
                vmxon_region[0] = vmcs_revision;
                vmxon_region_arg = (uint64_t)(
                                       pptr_to_paddr(vmxon_region) & 0xFFFFF000L);
                write_cr4(read_cr4() | (1ul<<(13)) /* Enable VMX mode. */);
                __asm__ volatile(
                    "vmxon %1; setnae %0"
                    : "=g"(error)
                    : "m"(vmxon_region_arg)
                    : "memory", "cc");
                if (error) {
                    kprintf("vt-x: vmxon failure\n");
                } else {
                    void *null_ept_space_ptr;
                    kprintf("vt-x: on!\n");
                    msr_bitmap = (uint32_t*)vtx_memory[1];
                    memset(msr_bitmap, ~0, (1ul<<(IA32_4K_bits)));
                    /* Set sysenter MSRs to writeable and readable. */
                    msr_bitmap[11] = 0xff8fffff;
                    msr_bitmap[512 + 11] = 0xff8fffff;
                    null_ept_space_ptr = (void*)vtx_memory[2];
                    memset(null_ept_space_ptr, 0, (1ul<<(IA32_4K_bits)));
                    null_ept_space = pptr_to_paddr(null_ept_space_ptr);
                    null_ept_space |= (3 << 3) | 6;
                    vtx_enabled = 1;
                }
                vpid_capability = ((uint64_t)ia32_rdmsr_high(0x48C)) << 32 | (uint64_t)ia32_rdmsr_low(0x48C);
            } else {
                kprintf("vt-x: disabled due to lack of required features\n");
            }
        } else if (!(feature_control & 1)) {
            kprintf("vt-x: feature control not locked\n");
        } else if (!(feature_control & (1 << 2))) {
            kprintf("vt-x: disabled by feature control\n");
        }
    } else {
        kprintf("vt-x: not supported\n");
    }
}

static void setMRs_vmexit(uint32_t reason, uint32_t qualification)
{
    word_t *buffer;
    int i;

    setRegister(ksCurThread, msgRegisters[0], vmread(0x0000681E));
    setRegister(ksCurThread, msgRegisters[1], vmread(0x00004002));

    buffer = lookupIPCBuffer(true, ksCurThread);
    if (!buffer) {
        return;
    }

    buffer[3] = vmread(0x00004016);
    buffer[4] = reason;
    buffer[5] = qualification;

    buffer[6] = vmread(0x0000440C);
    buffer[7] = vmread(0x00002400);
    buffer[8] = vmread(0x00006820);
    buffer[9] = vmread(0x00004824);
    buffer[10] = vmread(0x00006802);

    for (i = 0; i <= EBP; i++) {
        buffer[11 + i] = ksCurThread->tcbArch.vcpu->gp_registers[i];
    }
}

static void handleVmxFault(uint32_t reason, uint32_t qualification)
{
    /* Indicate that we are returning the from VMEnter with a fault */
    setRegister(ksCurThread, msgInfoRegister, 1);

    setMRs_vmexit(reason, qualification);

    /* Set the thread back to running */
    setThreadState(ksCurThread, ThreadState_Running);

    /* No need to schedule because this wasn't an interrupt and
     * we run at the same priority */
    activateThread();
}

exception_t
handleVmexit(void)
{
    enum exit_reasons reason;
    uint32_t qualification, interrupt;
    finishVmexitSaving();
    reason = vmread(0x00004402) & ((1ul<<(16))-1ul);
    if (reason == EXTERNAL_INTERRUPT) {
        interrupt = vmread(0x00004404);
        ia32KScurInterrupt = interrupt & 0xff;
        return handleInterruptEntry();
    } else if (ksCurThread != ia32KSfpuOwner) {
        if (reason == EXCEPTION_OR_NMI && !(ksCurThread->tcbArch.vcpu->exception_mask & (1ul<<(7)))) {
            interrupt = vmread(0x00004404);
            if ((interrupt & 0xff) == 0x7) {
                return handleUnimplementedDevice();
            }
        } else if (reason == CONTROL_REGISTER && !(ksCurThread->tcbArch.vcpu->cr0_mask & (1ul<<(3)))) {
            qualification = vmread(0x00006400);
            if ((qualification & 0xF) == 0) {
                switch ((qualification >> 4) & 0x3) {
                case 0: { /* mov to CR0 */
                    register_t source = crExitRegs[(qualification >> 8) & 0x7];
                    uint32_t value;
                    if (source != ESP) {
                        value = ksCurThread->tcbArch.vcpu->gp_registers[source];
                        ksCurThread->tcbArch.vcpu->cr0 = (ksCurThread->tcbArch.vcpu->cr0 & ~(1ul<<(0x3))) |
                                                         (value & (1ul<<(0x3)));
                        if (!((value ^ ksCurThread->tcbArch.vcpu->cr0_shadow) &
                                ksCurThread->tcbArch.vcpu->cr0_mask)) {
                            return EXCEPTION_NONE;
                        }
                    }
                    break;
                }
                case 2: { /* CLTS */
                    ksCurThread->tcbArch.vcpu->cr0 = (ksCurThread->tcbArch.vcpu->cr0 & ~(1ul<<(0x3)));
                    return EXCEPTION_NONE;
                }
                case 3: { /* LMSW */
                    uint32_t value = (qualification >> 16) & ((1ul<<(16))-1ul);
                    ksCurThread->tcbArch.vcpu->cr0 = (ksCurThread->tcbArch.vcpu->cr0 & ~(1ul<<(0x3))) | value;
                    if (!((value ^ ksCurThread->tcbArch.vcpu->cr0_shadow) &
                            ksCurThread->tcbArch.vcpu->cr0_mask & ((1ul<<(16))-1ul))) {
                        return EXCEPTION_NONE;
                    }
                    break;
                }
                }
            }
        }
    }
    switch (reason) {
    case EXCEPTION_OR_NMI:
        ksCurThread->tcbArch.vcpu->interrupt_info = vmread(0x00004404);
    case MOV_DR:
    case TASK_SWITCH:
    case CONTROL_REGISTER:
    case IO:
    case MWAIT:
    case SIPI:
    case INVLPG:
    case INVEPT:
    case INVVPID:
    case VMCLEAR:
    case VMPTRLD:
    case VMPTRST:
    case VMREAD:
    case VMWRITE:
    case VMXON:
    case EPT_VIOLATION:
    case GDTR_OR_IDTR:
    case LDTR_OR_TR:
    case TPR_BELOW_THRESHOLD:
    case APIC_ACCESS:
        qualification = vmread(0x00006400);
        break;
    default:
        qualification = 0;
    }

    handleVmxFault(reason, qualification);

    return EXCEPTION_NONE;
}

exception_t
handleVmEntryFail(void)
{
    handleVmxFault(-1, -1);

    return EXCEPTION_NONE;
}

void
finishVmexitSaving(void)
{
    vcpu_t *vcpu = ksCurThread->tcbArch.vcpu;
    vcpu->launched = true;
    vcpu->written_cr0 = vmread(0x00006800);
    if (ksCurThread != ia32KSfpuOwner) {
        vcpu->cr0 = (vcpu->written_cr0 & ~(1ul<<(3))) | (ksCurThread->tcbArch.vcpu->cr0 & (1ul<<(3)));
    } else {
        vcpu->cr0 = vcpu->written_cr0;
    }
}

static void
setIOPort(vcpu_t* vcpu)
{
    uint32_t high, low;
    if (cap_get_capType(vcpu->io_port) == cap_io_port_cap) {
        low = cap_io_port_cap_get_capIOPortFirstPort(vcpu->io_port);
        high = cap_io_port_cap_get_capIOPortLastPort(vcpu->io_port) + 1;
    } else {
        low = -1;
        high = -1;
    }
    /* Has the range changed at all */
    if (low != vcpu->io_min || high != vcpu->io_max) {
        /* We previously had some mappings, and now our range has changed
           Just knock all the ports out */
        if (vcpu->io_min != -1) {
            memset(&vcpu->io[vcpu->io_min / 32], ~0,
                   (1 + ((vcpu->io_max - 1) / 32) - (vcpu->io_min / 32)) * 4);
        }
        vcpu->io_min = low;
        vcpu->io_max = high;
    }
}

static void invvpid_context(uint16_t vpid)
{
    struct {
        uint64_t vpid : 16;
        uint64_t rsvd : 48;
        uint64_t address;
    } __attribute__((packed)) operand = {vpid, 0, 0};
    __asm__ volatile(".byte 0x66,0x0f,0x38,0x81, 0x08\n" :: "a"(&operand), "c"(1) : "cc");
}

static void
setEPTRoot(cap_t vmxSpace, vcpu_t* vcpu)
{
    uint32_t ept_root;
    if (cap_get_capType(vmxSpace) != cap_ept_page_directory_pointer_table_cap) {
        ept_root = null_ept_space;
    } else {
        ept_root = pptr_to_paddr((void*)cap_ept_page_directory_pointer_table_cap_get_capPDPTBasePtr(vmxSpace)) - (1 << (9 +3));
    }
    if (ept_root != vcpu->last_ept_root) {
        vcpu->last_ept_root = ept_root;
        vmwrite(0x0000201A, ept_root | (3 << 3) | 6);
        invvpid_context(vpid_for_vcpu(vcpu));
    }
}

static void
handleLazyFpu(void)
{
    uint32_t cr0;
    uint32_t exception_bitmap;
    uint32_t cr0_mask;
    uint32_t cr0_shadow;
    vcpu_t *vcpu = ksCurThread->tcbArch.vcpu;
    if (ksCurThread != ia32KSfpuOwner) {
        cr0 = vcpu->cr0 | (1ul<<(3));
        exception_bitmap = vcpu->exception_mask | (1ul<<(0x7));
        if (ksCurThread->tcbArch.vcpu->cr0_mask & (1ul<<(3))) {
            /* Don't replace the userland read shadow value if userland is
             * masking CR0.TS. The important thing is that it is masked so the
             * guest can't modify it. We don't care about the read shadow
             * value. */
            cr0_mask = vcpu->cr0_mask;
            cr0_shadow = vcpu->cr0_shadow;
        } else {
            cr0_mask = vcpu->cr0_mask | (1ul<<(3));
            cr0_shadow = (vcpu->cr0 & (1ul<<(3))) | (vcpu->cr0_shadow & ~(1ul<<(3)));
        }
    } else {
        cr0 = vcpu->cr0;
        exception_bitmap = vcpu->exception_mask;
        cr0_mask = vcpu->cr0_mask;
        cr0_shadow = vcpu->cr0_shadow;
    }
    if (cr0 != vcpu->written_cr0) {
        vmwrite(0x00006800, cr0);
        vcpu->written_cr0 = cr0;
    }
    if (exception_bitmap != vcpu->written_exception_mask) {
        vmwrite(0x00004004, exception_bitmap);
        vcpu->written_exception_mask = exception_bitmap;
    }
    if (cr0_mask != vcpu->written_cr0_mask) {
        vmwrite(0x00006000, cr0_mask);
        vcpu->written_cr0_mask = cr0_mask;
    }
    if (cr0_shadow != vcpu->written_cr0_shadow) {
        vmwrite(0x00006004, cr0_shadow);
        vcpu->written_cr0_shadow = cr0_shadow;
    }
}

void
restoreVMCS(void)
{
    vcpu_t *expected_vmcs = ksCurThread->tcbArch.vcpu;

    /* Check that the right VMCS is active and current. */
    if (current_vmcs != expected_vmcs) {
        vmptrld(expected_vmcs);
    }

    if (getCurrentPD() != expected_vmcs->last_host_cr3) {
        expected_vmcs->last_host_cr3 = getCurrentPD();
        vmwrite(0x00006C02, getCurrentPD());
    }
    setEPTRoot((((cte_t *)((unsigned int)(ksCurThread)&~((1ul<<(10))-1ul)))+(tcbArchEPTRoot))->cap, expected_vmcs);
    setIOPort(ksCurThread->tcbArch.vcpu);
    handleLazyFpu();
}

uint32_t
vmread(uint32_t field)
{
    uint32_t value;
    __asm__ volatile (
        "vmread %%eax, %%ecx"
        : "=c"(value)
        : "a"(field)
        : "cc"
    );
    return value;
}

void
vmwrite(uint32_t field, uint32_t value)
{
    uint8_t error = 0;
    __asm__ volatile (
        "vmwrite %%eax, %%edx; setna %0"
        : "=q"(error)
        : "a"(value), "d"(field)
        : "cc"
    );
    if (error) {
        kprintf("error setting field %x\n", field);
    }
}

int
vmptrld(void *vmcs_ptr)
{
    uint64_t physical_address;
    uint8_t error;
    current_vmcs = vmcs_ptr;
    physical_address = pptr_to_paddr(vmcs_ptr);
    __asm__ volatile (
        "vmptrld (%%eax); setna %0"
        : "=g"(error)
        : "a"(&physical_address), "m"(physical_address)
        : "cc"
    );
    return error;
}

void
vmclear(void *vmcs_ptr)
{
    uint64_t physical_address;
    physical_address = pptr_to_paddr((void*)vmcs_ptr);
    __asm__ volatile (
        "vmclear (%%eax)"
        :
        : "a"(&physical_address), "m"(physical_address)
        : "cc"
    );
}

void
invept(void* ept_pml4)
{
    if (vpid_capability & (1ul<<(20)) && vpid_capability & ((1ul<<(25)) | (1ul<<(26)))) {
        uint64_t physical_address[2];
        uint32_t type = 2;
        if (vpid_capability & (1ul<<(25))) {
            type = 1;
        }

        physical_address[0] = pptr_to_paddr((void*)ept_pml4);
        physical_address[1] = 0;
        __asm__ volatile (
            ".byte 0x66,0x0f,0x38,0x80, 0x08\n"
            :
            : "a"(&physical_address), "c"(type)
            : "memory"
        );
    }
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/assert.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/assert.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/assert.c" 2



void _fail(
    const char* s,
    const char* file,
    unsigned int line,
    const char* function)
{
    kprintf("seL4 called fail at %s:%u in function %s, saying \"%s\"\n", file, line, function, s)





     ;
    halt();
}

void _assert_fail(
    const char* assertion,
    const char* file,
    unsigned int line,
    const char* function)
{
    kprintf("seL4 failed assertion '%s' at %s:%u in function %s\n", assertion, file, line, function)




           ;
    halt();
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/inlines.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/inlines.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/inlines.c" 2

lookup_fault_t current_lookup_fault;
fault_t current_fault;
syscall_error_t current_syscall_error;
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cdt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c" 2

/* (node-local) state accessed only during bootstrapping */

ndks_boot_t ndks_boot __attribute__((__section__(".boot.node")));

__attribute__((__section__(".boot.text"))) bool_t
insert_region(region_t reg)
{
    unsigned int i;

    if(!(reg.start <= reg.end)) _assert_fail("reg.start <= reg.end", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c", 33, __FUNCTION__);
    if (is_reg_empty(reg)) {
        return true;
    }
    for (i = 0; i < 2; i++) {
        if (is_reg_empty(ndks_boot.freemem[i])) {
            ndks_boot.freemem[i] = reg;
            return true;
        }
    }
    return false;
}

__attribute__((__section__(".boot.text"))) static inline uint32_t
reg_size(region_t reg)
{
    return reg.end - reg.start;
}

__attribute__((__section__(".boot.text"))) pptr_t
alloc_region(uint32_t size_bits)
{
    unsigned int i;
    unsigned int reg_index = 0; /* gcc cannot work out that this will not be used uninitialized */
    region_t reg = (region_t){ .start = 0, .end = 0 };
    region_t rem_small = (region_t){ .start = 0, .end = 0 };
    region_t rem_large = (region_t){ .start = 0, .end = 0 };
    region_t new_reg;
    region_t new_rem_small;
    region_t new_rem_large;

    /* Search for a freemem region that will be the best fit for an allocation. We favour allocations
     * that are aligned to either end of the region. If an allocation must split a region we favour
     * an unbalanced split. In both cases we attempt to use the smallest region possible. In general
     * this means we aim to make the size of the smallest remaining region smaller (ideally zero)
     * followed by making the size of the largest remaining region smaller */

    for (i = 0; i < 2; i++) {
        /* Determine whether placing the region at the start or the end will create a bigger left over region */
        if ((((((ndks_boot.freemem[i].start) - 1ul) >> (size_bits)) + 1ul) << (size_bits)) - ndks_boot.freemem[i].start <
                ndks_boot.freemem[i].end - (((ndks_boot.freemem[i].end) >> (size_bits)) << (size_bits))) {
            new_reg.start = (((((ndks_boot.freemem[i].start) - 1ul) >> (size_bits)) + 1ul) << (size_bits));
            new_reg.end = new_reg.start + (1ul<<(size_bits));
        } else {
            new_reg.end = (((ndks_boot.freemem[i].end) >> (size_bits)) << (size_bits));
            new_reg.start = new_reg.end - (1ul<<(size_bits));
        }
        if (new_reg.end > new_reg.start &&
                new_reg.start >= ndks_boot.freemem[i].start &&
                new_reg.end <= ndks_boot.freemem[i].end) {
            if (new_reg.start - ndks_boot.freemem[i].start < ndks_boot.freemem[i].end - new_reg.end) {
                new_rem_small.start = ndks_boot.freemem[i].start;
                new_rem_small.end = new_reg.start;
                new_rem_large.start = new_reg.end;
                new_rem_large.end = ndks_boot.freemem[i].end;
            } else {
                new_rem_large.start = ndks_boot.freemem[i].start;
                new_rem_large.end = new_reg.start;
                new_rem_small.start = new_reg.end;
                new_rem_small.end = ndks_boot.freemem[i].end;
            }
            if ( is_reg_empty(reg) ||
                    (reg_size(new_rem_small) < reg_size(rem_small)) ||
                    (reg_size(new_rem_small) == reg_size(rem_small) && reg_size(new_rem_large) < reg_size(rem_large)) ) {
                reg = new_reg;
                rem_small = new_rem_small;
                rem_large = new_rem_large;
                reg_index = i;
            }
        }
    }
    if (is_reg_empty(reg)) {
        kprintf("Kernel init failing: not enough memory\n");
        return 0;
    }
    /* Remove the region in question */
    ndks_boot.freemem[reg_index] = (region_t){ .start = 0, .end = 0 };
    /* Add the remaining regions in largest to smallest order */
    insert_region(rem_large);
    if (!insert_region(rem_small)) {
        kprintf("alloc_region(): wasted 0x%x bytes due to alignment, try to increase MAX_NUM_FREEMEM_REG\n", (unsigned int)(rem_small.end - rem_small.start))
                                                               ;
    }
    return reg.start;
}

__attribute__((__section__(".boot.text"))) void
write_slot(slot_ptr_t slot_ptr, cap_t cap)
{
    slot_ptr->cap = cap;
    cdtInsert(((void *)0), slot_ptr);

    //slot_ptr->cteMDBNode = nullMDBNode;
    //mdb_node_ptr_set_mdbRevocable  (&slot_ptr->cteMDBNode, true);
    //mdb_node_ptr_set_mdbFirstBadged(&slot_ptr->cteMDBNode, true);
}

/* Our root CNode needs to be able to fit all the initial caps and not
 * cover all of memory.
 */
typedef int __assert_failed_root_cnode_size_valid[(16 < 32 - 4 && (1U << 16) >= 12 /* slot where dynamically allocated caps start */) ? 1 : -1];



__attribute__((__section__(".boot.text"))) cap_t
create_root_cnode(void)
{
    pptr_t pptr;
    cap_t cap;

    /* write the number of root CNode slots to global state */
    ndks_boot.slot_pos_max = (1ul<<(16));

    /* create an empty root CNode */
    pptr = alloc_region(16 + 4);
    if (!pptr) {
        kprintf("Kernel init failing: could not create root cnode\n");
        return cap_null_cap_new();
    }
    memzero(((cte_t *)(pptr)), 1U << (16 + 4));
    cap =
        cap_cnode_cap_new(
            16, /* radix      */
            32 - 16, /* guard size */
            0, /* guard      */
            pptr /* pptr       */
        );

    /* write the root CNode cap into the root CNode */
    write_slot((((slot_ptr_t)(pptr)) + (2 /* initial thread's root CNode cap */)), cap);

    return cap;
}

typedef int __assert_failed_irq_cnode_size[((1ul<<(IA32_4K_bits - 4)) > maxIRQ) ? 1 : -1];

__attribute__((__section__(".boot.text"))) bool_t
create_irq_cnode(void)
{
    pptr_t pptr;
    /* create an empty IRQ CNode */
    pptr = alloc_region(IA32_4K_bits);
    if (!pptr) {
        kprintf("Kernel init failing: could not create irq cnode\n");
        return false;
    }
    memzero((void*)pptr, 1 << IA32_4K_bits);
    intStateIRQNode = (cte_t*)pptr;
    return true;
}

/* Check domain scheduler assumptions. */
typedef int __assert_failed_num_domains_valid[(1 >= 1 && 1 <= 256) ? 1 : -1];

typedef int __assert_failed_num_priorities_valid[(256 >= 1 && 256 <= 256) ? 1 : -1];


__attribute__((__section__(".boot.text"))) void
create_domain_cap(cap_t root_cnode_cap)
{
    cap_t cap;
    unsigned int i;

    /* Check domain scheduler assumptions. */
    if(!(ksDomScheduleLength > 0)) _assert_fail("ksDomScheduleLength > 0", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c", 197, __FUNCTION__);
    for (i = 0; i < ksDomScheduleLength; i++) {
        if(!(ksDomSchedule[i].domain < 1)) _assert_fail("ksDomSchedule[i].domain < CONFIG_NUM_DOMAINS", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c", 199, __FUNCTION__);
        if(!(ksDomSchedule[i].length > 0)) _assert_fail("ksDomSchedule[i].length > 0", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c", 200, __FUNCTION__);
    }

    cap = cap_domain_cap_new();
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (11 /* domain cap */)), cap);
}


__attribute__((__section__(".boot.text"))) cap_t
create_ipcbuf_frame(cap_t root_cnode_cap, cap_t pd_cap, vptr_t vptr)
{
    cap_t cap;
    pptr_t pptr;

    /* allocate the IPC buffer frame */
    pptr = alloc_region(IA32_4K_bits);
    if (!pptr) {
        kprintf("Kernel init failing: could not create ipc buffer frame\n");
        return cap_null_cap_new();
    }
    clearMemory((void*)pptr, IA32_4K_bits);

    /* create a cap of it and write it into the root CNode */
    cap = create_mapped_it_frame_cap(pd_cap, pptr, vptr, false, false);
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (9 /* initial thread's IPC buffer frame cap */)), cap);

    return cap;
}

__attribute__((__section__(".boot.text"))) void
create_bi_frame_cap(
    cap_t root_cnode_cap,
    cap_t pd_cap,
    pptr_t pptr,
    vptr_t vptr
)
{
    cap_t cap;

    /* create a cap of it and write it into the root CNode */
    cap = create_mapped_it_frame_cap(pd_cap, pptr, vptr, false, false);
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (7 /* bootinfo frame cap */)), cap);
}

__attribute__((__section__(".boot.text"))) pptr_t
allocate_bi_frame(
    node_id_t node_id,
    uint32_t num_nodes,
    vptr_t ipcbuf_vptr
)
{
    pptr_t pptr;

    /* create the bootinfo frame object */
    pptr = alloc_region(IA32_4K_bits);
    if (!pptr) {
        kprintf("Kernel init failed: could not allocate bootinfo frame\n");
        return 0;
    }
    clearMemory((void*)pptr, IA32_4K_bits);

    /* initialise bootinfo-related global state */
    ndks_boot.bi_frame = ((bi_t*)(pptr));
    ndks_boot.slot_pos_cur = 12 /* slot where dynamically allocated caps start */;

    ((bi_t*)(pptr))->node_id = node_id;
    ((bi_t*)(pptr))->num_nodes = num_nodes;
    ((bi_t*)(pptr))->num_iopt_levels = 0;
    ((bi_t*)(pptr))->ipcbuf_vptr = ipcbuf_vptr;
    ((bi_t*)(pptr))->it_cnode_size_bits = 16;
    ((bi_t*)(pptr))->it_domain = ksDomSchedule[ksDomScheduleIdx].domain;

    return pptr;
}

__attribute__((__section__(".boot.text"))) bool_t
provide_cap(cap_t root_cnode_cap, cap_t cap)
{
    if (ndks_boot.slot_pos_cur >= ndks_boot.slot_pos_max) {
        kprintf("Kernel init failed: ran out of cap slots\n");
        return false;
    }
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (ndks_boot.slot_pos_cur)), cap);
    ndks_boot.slot_pos_cur++;
    return true;
}

__attribute__((__section__(".boot.text"))) create_frames_of_region_ret_t
create_frames_of_region(
    cap_t root_cnode_cap,
    cap_t pd_cap,
    region_t reg,
    bool_t do_map,
    int32_t pv_offset
)
{
    pptr_t f;
    cap_t frame_cap;
    slot_pos_t slot_pos_before;
    slot_pos_t slot_pos_after;

    slot_pos_before = ndks_boot.slot_pos_cur;

    for (f = reg.start; f < reg.end; f += (1ul<<(IA32_4K_bits))) {
        if (do_map) {
            frame_cap = create_mapped_it_frame_cap(pd_cap, f, f - (0xe0000000 - 0x00000000) - pv_offset, false, false);
        } else {
            frame_cap = create_unmapped_it_frame_cap(f, false);
        }
        if (!provide_cap(root_cnode_cap, frame_cap))
            return (create_frames_of_region_ret_t) {
            (slot_region_t){ .start = 0, .end = 0 }, false
        };
    }

    slot_pos_after = ndks_boot.slot_pos_cur;

    return (create_frames_of_region_ret_t) {
        (slot_region_t) { slot_pos_before, slot_pos_after }, true
    };
}

__attribute__((__section__(".boot.text"))) bool_t
create_idle_thread(void)
{
    pptr_t pptr;
    pptr = alloc_region(10);
    if (!pptr) {
        kprintf("Kernel init failed: Unable to allocate tcb for idle thread\n");
        return false;
    }
    memzero((void *)pptr, 1 << 10);
    ksIdleThread = ((tcb_t *)(pptr + (1 << (4 + 4))));
    configureIdleThread(ksIdleThread);
    return true;
}

__attribute__((__section__(".boot.text"))) bool_t
create_initial_thread(
    cap_t root_cnode_cap,
    cap_t it_pd_cap,
    vptr_t ui_v_entry,
    vptr_t bi_frame_vptr,
    vptr_t ipcbuf_vptr,
    cap_t ipcbuf_cap
)
{
    pptr_t pptr;
    cap_t cap;
    tcb_t* tcb;
    deriveCap_ret_t dc_ret;

    /* allocate TCB */
    pptr = alloc_region(10);
    if (!pptr) {
        kprintf("Kernel init failed: Unable to allocate tcb for initial thread\n");
        return false;
    }
    memzero((void*)pptr, 1 << 10);
    tcb = ((tcb_t *)(pptr + (1 << (4 + 4))));
    tcb->tcbTimeSlice = 5;
    Arch_initContext(&tcb->tcbArch.tcbContext);

    /* derive a copy of the IPC buffer cap for inserting */
    dc_ret = deriveCap((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (9 /* initial thread's IPC buffer frame cap */)), ipcbuf_cap);
    if (dc_ret.status != EXCEPTION_NONE) {
        kprintf("Failed to derive copy of IPC Buffer\n");
        return false;
    }

    /* initialise TCB (corresponds directly to abstract specification) */
    cteInsert(
        root_cnode_cap,
        (((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (2 /* initial thread's root CNode cap */)),
        (((slot_ptr_t)(pptr)) + (tcbCTable))
    );
    cteInsert(
        it_pd_cap,
        (((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (3 /* initial thread's vspace root cap */)),
        (((slot_ptr_t)(pptr)) + (tcbVTable))
    );
    cteInsert(
        dc_ret.cap,
        (((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (9 /* initial thread's IPC buffer frame cap */)),
        (((slot_ptr_t)(pptr)) + (tcbBuffer))
    );
    tcb->tcbIPCBuffer = ipcbuf_vptr;
    setRegister(tcb, capRegister, bi_frame_vptr);
    setNextPC(tcb, ui_v_entry);

    /* initialise TCB */
    tcb->tcbPriority = seL4_MaxPrio;
    setupReplyMaster(tcb);
    setThreadState(tcb, ThreadState_Running);
    ksSchedulerAction = ((tcb_t*)0);
    ksCurThread = ksIdleThread;
    ksCurDomain = ksDomSchedule[ksDomScheduleIdx].domain;
    ksDomainTime = ksDomSchedule[ksDomScheduleIdx].length;
    if(!(ksCurDomain < 1 && ksDomainTime > 0)) _assert_fail("ksCurDomain < CONFIG_NUM_DOMAINS && ksDomainTime > 0", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c", 398, __FUNCTION__);

    /* initialise current thread pointer */
    switchToThread(tcb); /* initialises ksCurThread */

    /* create initial thread's TCB cap */
    cap = cap_thread_cap_new(((unsigned int)(tcb)));
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (1 /* initial thread's TCB cap */)), cap);


    setThreadName(tcb, "rootserver");


    return true;
}

__attribute__((__section__(".boot.text"))) static bool_t
provide_untyped_cap(
    cap_t root_cnode_cap,
    bool_t deviceMemory,
    pptr_t pptr,
    uint32_t size_bits,
    slot_pos_t first_untyped_slot
)
{
    bool_t ret;
    unsigned int i = ndks_boot.slot_pos_cur - first_untyped_slot;
    if (i < 800) {
        ndks_boot.bi_frame->ut_obj_paddr_list[i] = pptr_to_paddr((void*)pptr);
        ndks_boot.bi_frame->ut_obj_size_bits_list[i] = size_bits;
        ret = provide_cap(root_cnode_cap, cap_untyped_cap_new(deviceMemory, size_bits, pptr));
    } else {
        kprintf("Kernel init: Too many untyped regions for boot info\n");
        ret = true;
    }
    return ret;
}

/**
  DONT_TRANSLATE
*/
__attribute__((__section__(".boot.text"))) static uint32_t boot_clz (uint32_t x)
{
    return __builtin_clz(x);
}

/**
  DONT_TRANSLATE
*/
__attribute__((__section__(".boot.text"))) static uint32_t boot_ctz (uint32_t x)
{
    return __builtin_ctz(x);
}

__attribute__((__section__(".boot.text"))) bool_t
create_untypeds_for_region(
    cap_t root_cnode_cap,
    bool_t deviceMemory,
    region_t reg,
    slot_pos_t first_untyped_slot
)
{
    uint32_t align_bits;
    uint32_t size_bits;

    while (!is_reg_empty(reg)) {
        /* Due to a limitation on the mdb we cannot give out an untyped to the
         * the start of the kernel region. The reason for this is that cte pointers
         * in mdb nodes are stored with the high bits masked out. To recreate a cte pointer
         * we then need to put the high bits back in after reading it out. HOWEVER, we
         * still need a way to store and identify a NULL pointer. This means reserving
         * the bottom address as the 'null' address so that no one creates an cnode
         * there resulting in a 'null' (yet valid) cte
         */
        if (!deviceMemory && reg.start == 0xe0000000) {
            reg.start += (1ul<<(IA32_4K_bits));
        }
        /* Determine the maximum size of the region */
        size_bits = (8 * sizeof(word_t)) - 1 - boot_clz(reg.end - reg.start);

        /* Determine the alignment of the region */
        align_bits = boot_ctz(reg.start);

        /* Reduce size bits to align if needed */
        if (align_bits < size_bits) {
            size_bits = align_bits;
        }

        if(!(size_bits >= (8 * sizeof(word_t)) / 8)) _assert_fail("size_bits >= WORD_BITS / 8", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/boot.c", 486, __FUNCTION__);
        if (!provide_untyped_cap(root_cnode_cap, deviceMemory, reg.start, size_bits, first_untyped_slot)) {
            return false;
        }
        reg.start += (1ul<<(size_bits));
    }
    return true;
}

__attribute__((__section__(".boot.text"))) bool_t
create_untypeds(cap_t root_cnode_cap, region_t boot_mem_reuse_reg)
{
    slot_pos_t slot_pos_before;
    slot_pos_t slot_pos_after;
    uint32_t i;
    region_t reg;

    slot_pos_before = ndks_boot.slot_pos_cur;

    /* if boot_mem_reuse_reg is not empty, we can create UT objs from boot code/data frames */
    if (!create_untypeds_for_region(root_cnode_cap, false, boot_mem_reuse_reg, slot_pos_before)) {
        return false;
    }

    /* convert remaining freemem into UT objects and provide the caps */
    for (i = 0; i < 2; i++) {
        reg = ndks_boot.freemem[i];
        ndks_boot.freemem[i] = (region_t){ .start = 0, .end = 0 };
        if (!create_untypeds_for_region(root_cnode_cap, false, reg, slot_pos_before)) {
            return false;
        }
    }

    slot_pos_after = ndks_boot.slot_pos_cur;
    ndks_boot.bi_frame->ut_obj_caps = (slot_region_t) {
        slot_pos_before, slot_pos_after
    };
    return true;
}

__attribute__((__section__(".boot.text"))) void
bi_finalise(void)
{
    slot_pos_t slot_pos_start = ndks_boot.slot_pos_cur;
    slot_pos_t slot_pos_end = ndks_boot.slot_pos_max;
    ndks_boot.bi_frame->null_caps = (slot_region_t) {
        slot_pos_start, slot_pos_end
    };
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c" 2





void printCTE(char *msg, cte_t *cte);

static cte_t *aaInsert(cte_t *rootSlot, cte_t *newSlot);
static cte_t *aaRemove(bool_t isSwapped, cte_t *rootSlot, cte_t *targetSlot);
static cte_t *aaTraverseBackward(cte_t *slot);
static cte_t *aaTraverseForward(cte_t *slot);

typedef int (*comp_t)(cte_t *, cte_t *);
typedef int (*tie_comp_t)(cte_t *, cte_t *, comp_t);
typedef int (*type_comp_t)(cte_t *, cte_t *, tie_comp_t);







static inline bool_t
capsEqual(cap_t a, cap_t b)
{
    return (cap_get_capSpaceType(a) == cap_get_capSpaceType(b)) &&
           ((word_t)cap_get_capSpacePtr(a) == (word_t)cap_get_capSpacePtr(b)) &&
           (cap_get_capSpaceSize(a) == cap_get_capSpaceSize(b)) &&
           (cap_get_capBadge(a) == cap_get_capBadge(b)) &&
           (cap_get_capExtraComp(a) == cap_get_capExtraComp(b));
}

static inline int
tie_break_comparator(cte_t *a, cte_t *b, comp_t pre_slot)
{
    int cmp;
    /* Check the depth */
    cmp = ({ typeof(mdb_node_get_cdtDepth(a->cteMDBNode)) _a = (mdb_node_get_cdtDepth(a->cteMDBNode)); typeof(mdb_node_get_cdtDepth(b->cteMDBNode)) _b = (mdb_node_get_cdtDepth(b->cteMDBNode)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    if (pre_slot) {
        cmp = pre_slot(a, b);
        if (cmp != ( 0)) {
            return cmp;
        }
    }
    /* compare on the slot as a last resort */
    return ({ typeof(a) _a = (a); typeof(b) _b = (b); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
}

static inline int
untyped_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    int cmp;
    /* Compare base address and size of the untyped object */
    cmp = ({ typeof(cap_untyped_cap_get_capPtr(a->cap)) _a = (cap_untyped_cap_get_capPtr(a->cap)); typeof(cap_untyped_cap_get_capPtr(b->cap)) _b = (cap_untyped_cap_get_capPtr(b->cap)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    cmp = - ({ typeof(cap_untyped_cap_get_capBlockSize(a->cap)) _a = (cap_untyped_cap_get_capBlockSize(a->cap)); typeof(cap_untyped_cap_get_capBlockSize(b->cap)) _b = (cap_untyped_cap_get_capBlockSize(b->cap)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    /* Do common late comparisons */
    return tie_break(a, b, ((void *)0));
}

static inline int
endpoint_cap_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    int cmp;
    /* compare on the badge */
    cmp = ({ typeof(cap_endpoint_cap_get_capEPBadge(a->cap)) _a = (cap_endpoint_cap_get_capEPBadge(a->cap)); typeof(cap_endpoint_cap_get_capEPBadge(b->cap)) _b = (cap_endpoint_cap_get_capEPBadge(b->cap)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    /* tiebreak as normal */
    return tie_break(a, b, ((void *)0));
}

static inline int
async_endpoint_cap_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    int cmp;
    /* compare on the badge */
    cmp = ({ typeof(cap_async_endpoint_cap_get_capAEPBadge(a->cap)) _a = (cap_async_endpoint_cap_get_capAEPBadge(a->cap)); typeof(cap_async_endpoint_cap_get_capAEPBadge(b->cap)) _b = (cap_async_endpoint_cap_get_capAEPBadge(b->cap)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    /* tiebreak as normal */
    return tie_break(a, b, ((void *)0));
}

static inline int cap_extra_comp(cte_t *a, cte_t *b)
{
    return ({ typeof(cap_get_capExtraComp(a->cap)) _a = (cap_get_capExtraComp(a->cap)); typeof(cap_get_capExtraComp(b->cap)) _b = (cap_get_capExtraComp(b->cap)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
}

static inline int
frame_cap_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    return tie_break(a, b, cap_extra_comp);
}

static inline int
page_table_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    return tie_break(a, b, cap_extra_comp);
}

static inline int
page_directory_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    return tie_break(a, b, cap_extra_comp);
}

static inline int
pdpt_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    return tie_break(a, b, cap_extra_comp);
}

static inline int
io_page_table_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    return tie_break(a, b, cap_extra_comp);
}

static inline int
io_space_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    return tie_break(a, b, cap_extra_comp);
}

static inline int
ept_pdpt_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    return tie_break(a, b, cap_extra_comp);
}

static inline int
ept_page_directory_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    return tie_break(a, b, cap_extra_comp);
}

static inline int
ept_page_table_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    return tie_break(a, b, cap_extra_comp);
}

static inline int
just_tie_break(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    return tie_break(a, b, ((void *)0));
}

static inline int
typed_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    int cmp;
    cap_tag_t type;
    type_comp_t comp;
    static type_comp_t comparator[] = {
        [cap_endpoint_cap] = endpoint_cap_comparator,
        [cap_async_endpoint_cap] = async_endpoint_cap_comparator,
        [cap_cnode_cap] = just_tie_break,
        [cap_thread_cap] = just_tie_break,
        [cap_frame_cap] = frame_cap_comparator,
        [cap_page_table_cap] = page_table_comparator,
        [cap_page_directory_cap] = page_directory_comparator,

        [cap_pdpt_cap] = pdpt_comparator,

        [cap_zombie_cap] = just_tie_break,

        [cap_io_page_table_cap] = io_page_table_comparator,
        [cap_io_space_cap] = io_space_comparator,


        [cap_vcpu_cap] = just_tie_break,
        [cap_ept_page_directory_pointer_table_cap] = ept_pdpt_comparator,
        [cap_ept_page_directory_cap] = ept_page_directory_comparator,
        [cap_ept_page_table_cap] = ept_page_table_comparator,

    };
    /* Typed objects do not overlap, so sufficient to compare base address */
    cmp = ({ typeof(cap_get_capPtr(a->cap)) _a = (cap_get_capPtr(a->cap)); typeof(cap_get_capPtr(b->cap)) _b = (cap_get_capPtr(b->cap)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    /* at this point we *know* the types must be equal, so call the
     * per cap type comparator, if it needs one. */
    type = cap_get_capType(a->cap);
    if(!(type < (sizeof(typeof(comparator))/sizeof(typeof((comparator)[0]))))) _assert_fail("type < ARRAY_SIZE(comparator)", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 211, __FUNCTION__);
    comp = comparator[type];
    if(!(comp)) _assert_fail("comp", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 213, __FUNCTION__);
    return comp(a, b, tie_break);
}

static inline int
irq_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    int cmp;
    cap_tag_t typeA, typeB;
    /* The IRQ control cap can be thought of as having an 'address' of 0 and a 'size' of
     * the entire IRQ space. IRQ handlers then have an address that is their irq and a size
     * of 1. Since IRQ control caps cannot be subdivided this is equivalent to putting
     * all IRQ control caps first, then sorting IRQ handlers by their IRQ */
    typeA = cap_get_capType(a->cap);
    typeB = cap_get_capType(b->cap);
    if (typeA == typeB) {
        if (typeA == cap_irq_control_cap) {
            /* both control caps, tie break */
            return tie_break(a, b, ((void *)0));
        } else {
            /* both irq handlers, compare on irq */
            if(!(typeA == cap_irq_handler_cap)) _assert_fail("typeA == cap_irq_handler_cap", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 234, __FUNCTION__);
            cmp = ({ typeof(cap_irq_handler_cap_get_capIRQ(a->cap)) _a = (cap_irq_handler_cap_get_capIRQ(a->cap)); typeof(cap_irq_handler_cap_get_capIRQ(b->cap)) _b = (cap_irq_handler_cap_get_capIRQ(b->cap)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
            if (cmp != ( 0)) {
                return cmp;
            }
            return tie_break(a, b, ((void *)0));
        }
    } else if (typeA == cap_irq_control_cap) {
        return (-1);
    } else {
        if(!(typeA == cap_irq_handler_cap)) _assert_fail("typeA == cap_irq_handler_cap", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 244, __FUNCTION__);
        return ( 1);
    }
}


static inline int
ioport_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    int cmp;
    uint32_t firstA, firstB, lastA, lastB;
    /* ioports have a base address and size that is defined by their start port and end port */
    firstA = cap_io_port_cap_get_capIOPortFirstPort(a->cap);
    firstB = cap_io_port_cap_get_capIOPortFirstPort(b->cap);
    cmp = ({ typeof(firstA) _a = (firstA); typeof(firstB) _b = (firstB); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    lastA = cap_io_port_cap_get_capIOPortLastPort(a->cap);
    lastB = cap_io_port_cap_get_capIOPortLastPort(b->cap);
    cmp = - ({ typeof(lastA - firstA) _a = (lastA - firstA); typeof(lastB - firstB) _b = (lastB - firstB); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    return tie_break(a, b, ((void *)0));
}



static inline int
iospace_comparator(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    int cmp;
    /* order by pci device this is assigned to and then by domain ID */
    cmp = ({ typeof(cap_io_space_cap_get_capPCIDevice(a->cap)) _a = (cap_io_space_cap_get_capPCIDevice(a->cap)); typeof(cap_io_space_cap_get_capPCIDevice(b->cap)) _b = (cap_io_space_cap_get_capPCIDevice(b->cap)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    cmp = ({ typeof(cap_io_space_cap_get_capDomainID(a->cap)) _a = (cap_io_space_cap_get_capDomainID(a->cap)); typeof(cap_io_space_cap_get_capDomainID(b->cap)) _b = (cap_io_space_cap_get_capDomainID(b->cap)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    return tie_break(a, b, ((void *)0));
}


static inline int
compare_space(int space, cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    type_comp_t comp;
    static type_comp_t comparator[] = {
        [capSpaceUntypedMemory] = untyped_comparator,
        [capSpaceTypedMemory] = typed_comparator,
        [capSpaceDomain] = just_tie_break,
        [capSpaceIRQ] = irq_comparator,

        [capSpaceIOSpace] = iospace_comparator,


        [capSpaceIOPort] = ioport_comparator,
        [capSpaceIPI] = just_tie_break,

    };
    if(!(space < (sizeof(typeof(comparator))/sizeof(typeof((comparator)[0]))))) _assert_fail("space < ARRAY_SIZE(comparator)", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 307, __FUNCTION__);
    comp = comparator[space];
    if(!(comp)) _assert_fail("comp", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 309, __FUNCTION__);
    return comp(a, b, tie_break);
}

static inline int
compSlotWith(cte_t *a, cte_t *b, tie_comp_t tie_break)
{
    /* check space */
    int spaceA = cap_get_capSpaceType(a->cap);
    int spaceB = cap_get_capSpaceType(b->cap);
    int cmp = ({ typeof(spaceA) _a = (spaceA); typeof(spaceB) _b = (spaceB); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    /* now call the space specific comparator */
    return compare_space(spaceA, a, b, tie_break);
}

static inline int
compSlot(cte_t *a, cte_t *b)
{
    /* We know nothing, call general comparator for caps and tie break on slots */
    return compSlotWith(a, b, tie_break_comparator);
}

static inline int has_extra_comparator(cte_t *a, cte_t *b, comp_t pre_slot)
{
    int cmp;
    /* Check depth as per normal */
    cmp = ({ typeof(mdb_node_get_cdtDepth(a->cteMDBNode)) _a = (mdb_node_get_cdtDepth(a->cteMDBNode)); typeof(mdb_node_get_cdtDepth(b->cteMDBNode)) _b = (mdb_node_get_cdtDepth(b->cteMDBNode)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    if(!(pre_slot)) _assert_fail("pre_slot", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 342, __FUNCTION__);
    cmp = pre_slot(a, b);
    /* if the extra comparison was not equal then we found something, so we will claim that we found equality,
     * otherwise return a psudo-random result */
    if (cmp != ( 0)) {
        return ( 0);
    }
    return (-1);
}

cte_t *
cdtFindWithExtra(cap_t hypothetical)
{
    uint32_t i;
    unsigned int depth_bits = cte_depth_bits_cap(hypothetical);
    for (i = 0; i < (1ul<<(depth_bits)); i++) {
        cte_t *current;
        cte_t *next;

        cte_t slot = (cte_t) {
            .cap = hypothetical,
             .cteMDBNode = mdb_node_new(0, i, 0, 0)
        };

        next = ksRootCTE;
        do {
            int cmp;
            current = next;
            /* we are searching for a slot that is mostly equal to this node,
             * except that it has a non zero extra component */
            cmp = compSlotWith(current, &slot, has_extra_comparator);
            switch (cmp) {
            case (-1):
                next = ((cte_t *)(mdb_node_get_cdtRight(current->cteMDBNode)));
                break;
            case ( 1):
                next = ((cte_t *)(mdb_node_get_cdtLeft(current->cteMDBNode)));
                break;
            case ( 0):
                return current;
            }
        } while (next);
    }
    return ((void *)0);
}

static inline int slot_eq_comparator(cte_t *a, cte_t *b, comp_t pre_slot)
{
    int cmp;
    /* Check depth and pre_slot as per normal */
    cmp = ({ typeof(mdb_node_get_cdtDepth(a->cteMDBNode)) _a = (mdb_node_get_cdtDepth(a->cteMDBNode)); typeof(mdb_node_get_cdtDepth(b->cteMDBNode)) _b = (mdb_node_get_cdtDepth(b->cteMDBNode)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    if (pre_slot) {
        cmp = pre_slot(a, b);
        if (cmp != ( 0)) {
            return cmp;
        }
    }
    /* Slot is always EQ */
    return ( 0);
}

cte_t *
cdtFindAtDepth(cap_t hypothetical, uint32_t depth)
{
    cte_t *current;
    cte_t *next;

    cte_t slot = (cte_t) {
        .cap = hypothetical,
         .cteMDBNode = mdb_node_new(0, depth, 0, 0)
    };

    next = ksRootCTE;
    /* we want to find the entry in the tree that is equal to this node
     * in every way except that it will have a different slot. So we will
     * do a search with a comparator that always returns equality on slots */
    do {
        current = next;
        switch (compSlotWith(current, &slot, slot_eq_comparator)) {
        case (-1):
            next = ((cte_t *)(mdb_node_get_cdtRight(current->cteMDBNode)));
            break;
        case ( 1):
            next = ((cte_t *)(mdb_node_get_cdtLeft(current->cteMDBNode)));
            break;
        case ( 0):
            return current;
        }
    } while (next);
    return ((void *)0);
}

cte_t *
cdtFind(cap_t hypothetical)
{
    uint32_t i;
    cte_t *ret;
    unsigned int depth_bits = cte_depth_bits_cap(hypothetical);
    for (i = 0; i < (1ul<<(depth_bits)); i++) {
        ret = cdtFindAtDepth(hypothetical, i);
        if (ret) {
            return ret;
        }
    }
    return ((void *)0);
}

bool_t
cdtIsFinal(cte_t *slot)
{
    cte_t *closest;

    /* For finality testing it is sufficient to check the objects immediately
     * before and after us in cdt ordering. This is because we are only
     * interested in equivalent objects, not whether something is actually
     * a parent or not */
    closest = aaTraverseForward(slot);
    if (closest && sameObjectAs(closest->cap, slot->cap)) {
        return false;
    }
    closest = aaTraverseBackward(slot);
    if (closest && sameObjectAs(closest->cap, slot->cap)) {
        return false;
    }
    return true;
}

static inline cap_t
build_largest_child(cap_t cap)
{
    switch (cap_get_capType(cap)) {
    case cap_domain_cap:

    case cap_ipi_cap:

    case cap_irq_handler_cap:
    case cap_cnode_cap:
    case cap_thread_cap:

    case cap_vcpu_cap:

    case cap_zombie_cap:
        return cap;






    case cap_irq_control_cap:
        /* Largest child is a irq handler with biggest irq */
        return cap_irq_handler_cap_new(0xff);
    case cap_untyped_cap:
        /* untyped cap of smallest size at the end of this region */
        return cap_untyped_cap_new(0, 4, cap_untyped_cap_get_capPtr(cap) + (1ul<<(cap_untyped_cap_get_capBlockSize(cap))) - (1ul<<(4)));
    case cap_endpoint_cap:
        if (cap_endpoint_cap_get_capEPBadge(cap) == 0) {
            return cap_endpoint_cap_new((1ul<<(28)) - 1, 0, 0, 0, cap_endpoint_cap_get_capEPPtr(cap));
        }
        return cap;
    case cap_async_endpoint_cap:
        if (cap_async_endpoint_cap_get_capAEPBadge(cap) == 0) {
            return cap_async_endpoint_cap_new((1ul<<(28)) - 1, 0, 0, cap_async_endpoint_cap_get_capAEPPtr(cap));
        }
        return cap;
        /* We get away with not setting the extra higher as we will always be comparing
         * with an infinite depth, hence any 'extra' is not relevant */
    case cap_frame_cap:
    case cap_page_table_cap:
    case cap_page_directory_cap:

    case cap_pdpt_cap:


    case cap_ept_page_directory_pointer_table_cap:
    case cap_ept_page_directory_cap:
    case cap_ept_page_table_cap:


    case cap_io_page_table_cap:
    case cap_io_space_cap:

        return cap;
    default:
        _fail("Unknown cap type", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 529, __func__);
    }
}

static inline int largest_child_comparator(cte_t *a, cte_t *b, comp_t pre_slot)
{
    /* Tie breaking for largest child is easy. Their depth is always less than ours */
    return (-1);
}

static inline int slot_lt_comparator(cte_t *a, cte_t *b, comp_t pre_slot)
{
    int cmp;
    /* Check depth and pre_slot as per normal */
    cmp = ({ typeof(mdb_node_get_cdtDepth(a->cteMDBNode)) _a = (mdb_node_get_cdtDepth(a->cteMDBNode)); typeof(mdb_node_get_cdtDepth(b->cteMDBNode)) _b = (mdb_node_get_cdtDepth(b->cteMDBNode)); _a == _b ? ( 0) : (_a > _b ? ( 1) : (-1)); });
    if (cmp != ( 0)) {
        return cmp;
    }
    if (pre_slot) {
        cmp = pre_slot(a, b);
        if (cmp != ( 0)) {
            return cmp;
        }
    }
    /* Slot is always LT */
    return (-1);
}

static inline cte_t *
aaFindFromBelow(cte_t *hypothetical, tie_comp_t tie_break)
{
    cte_t *current;
    cte_t *largest;
    cte_t *next;
    next = ksRootCTE;
    largest = ((void *)0);
    do {
        int cmp;
        current = next;
        cmp = compSlotWith(current, hypothetical, tie_break);
        if (cmp == (-1)) {
            next = ((cte_t *)(mdb_node_get_cdtRight(current->cteMDBNode)));
            if (!largest || compSlot(current, largest) == ( 1)) {
                largest = current;
            }
        } else {
            next = ((cte_t *)(mdb_node_get_cdtLeft(current->cteMDBNode)));
        }
    } while (next);
    return largest;
}

/* Finding a child is complicated because your child may not
 * live directly after you in cdt order. That is, if you take
 * ever node in the tree and squash it into a list, directly
 * after you may be some N number of siblings, then your
 * children. This is why we need to do a creative search
 * where as cdtIsFinal was able to get away with checking
 * neighbouring nodes */
static cte_t *
_cdtFindChild(cte_t *parentSlot)
{
    cte_t *child;
    /* Construct a hypothetical child. This needs to be the largest
     * possible child such that anything greater than it would no
     * longer be our child and anything less than it is either
     * our sibling or our child. We do not worry about the depth
     * as we will use a fake comparator that assumes our node
     * is of infinite depth */
    cte_t hypothetical = {
        .cap = build_largest_child(parentSlot->cap),
    };

    /* Search for hypothetical cap from below. */
    child = aaFindFromBelow(&hypothetical, largest_child_comparator);

    /* Verify that this is in fact a child (we could have none). To ensure
     * we did not find ourself or a sibling we ensure that we are strictly
     * greater than ignoring slot tie breaks */
    if (!child || compSlotWith(child, parentSlot, slot_lt_comparator) != ( 1)) {
        return ((void *)0);
    }
    return child;
}

cte_t *
cdtFindTypedInRange(word_t base, unsigned int size_bits)
{
    cte_t *child;
    /* Construct the smallest typed object we know about at the top
     * of the memory range and search for it */
    cte_t hypothetical = {
        .cap = cap_endpoint_cap_new(0, 0, 0, 0, base + (1ul<<(size_bits)) - (1ul<<(4))),
    };
    /* Search for it from below */
    child = aaFindFromBelow(&hypothetical, largest_child_comparator);
    /* Check we found something in the right range. Construct a fake untyped
     * to reuse existing range checking */
    if (child && sameRegionAs(cap_untyped_cap_new(0, size_bits, base), child->cap)) {
        return child;
    }
    return ((void *)0);
}

cte_t *
cdtFindChild(cte_t *parentSlot)
{
    if (cap_get_capSpaceType(parentSlot->cap) == capSpaceUntypedMemory) {
        /* Find anything in this range that is typed */
        cte_t *result = cdtFindTypedInRange(cap_untyped_cap_get_capPtr(parentSlot->cap), cap_untyped_cap_get_capBlockSize(parentSlot->cap));
        if (result) {
            return result;
        }
    }
    return _cdtFindChild(parentSlot);
}

static inline void
cdtInsertTree(cte_t *slot)
{
    ksRootCTE = aaInsert(ksRootCTE, slot);
}

void
cdtInsert(cte_t *parentSlot, cte_t *newSlot)
{
    word_t depth;
    if(!(cap_get_capType(newSlot->cap) != cap_null_cap)) _assert_fail("cap_get_capType(newSlot->cap) != cap_null_cap", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 656, __FUNCTION__);
    if(!(!parentSlot || cap_get_capType(parentSlot->cap) != cap_null_cap)) _assert_fail("!parentSlot || cap_get_capType(parentSlot->cap) != cap_null_cap", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 657, __FUNCTION__);
    if (!parentSlot || (cap_get_capSpaceType(parentSlot->cap) != cap_get_capSpaceType(newSlot->cap))) {
        depth = 0;
    } else {
        depth = mdb_node_get_cdtDepth(parentSlot->cteMDBNode) + 1;
        if (depth == (1ul<<(cte_depth_bits_cap(newSlot->cap)))) {
            depth--;
        }
    }
    newSlot->cteMDBNode = mdb_node_new(0, depth, 0, 0);
    cdtInsertTree(newSlot);
}

void
cdtRemove(cte_t *slot)
{
    if(!(cap_get_capType(slot->cap) != cap_null_cap)) _assert_fail("cap_get_capType(slot->cap) != cap_null_cap", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 673, __FUNCTION__);
    ksRootCTE = aaRemove(false, ksRootCTE, slot);
    slot->cteMDBNode = mdb_node_new(0, false, false, 0);
}

void
cdtMove(cte_t *oldSlot, cte_t *newSlot)
{
    if(!(cap_get_capType(oldSlot->cap) != cap_null_cap)) _assert_fail("cap_get_capType(oldSlot->cap) != cap_null_cap", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 681, __FUNCTION__);
    if(!(cap_get_capType(newSlot->cap) != cap_null_cap)) _assert_fail("cap_get_capType(newSlot->cap) != cap_null_cap", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 682, __FUNCTION__);
    ksRootCTE = aaRemove(false, ksRootCTE, oldSlot);

    newSlot->cteMDBNode = mdb_node_new(0, mdb_node_get_cdtDepth(oldSlot->cteMDBNode), 0, 0);
    oldSlot->cteMDBNode = mdb_node_new(0, 0, 0, 0);

    ksRootCTE = aaInsert(ksRootCTE, newSlot);
}

void
cdtUpdate(cte_t *slot, cap_t newCap)
{
    if (capsEqual(slot->cap, newCap)) {
        slot->cap = newCap;
    } else {
        ksRootCTE = aaRemove(false, ksRootCTE, slot);
        slot->cteMDBNode = mdb_node_new(0, mdb_node_get_cdtDepth(slot->cteMDBNode), 0, 0);
        slot->cap = newCap;
        ksRootCTE = aaInsert(ksRootCTE, slot);
    }
}

void
cdtSwap(cap_t cap1, cte_t *slot1, cap_t cap2, cte_t *slot2)
{
    word_t depth1, depth2;
    if(!(slot1 != slot2)) _assert_fail("slot1 != slot2", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 708, __FUNCTION__);
    if (cap_get_capType(slot1->cap) != cap_null_cap) {
        ksRootCTE = aaRemove(false, ksRootCTE, slot1);
    }
    if (cap_get_capType(slot2->cap) != cap_null_cap) {
        ksRootCTE = aaRemove(false, ksRootCTE, slot2);
    }
    depth1 = mdb_node_get_cdtDepth(slot1->cteMDBNode);
    depth2 = mdb_node_get_cdtDepth(slot2->cteMDBNode);
    slot1->cteMDBNode = mdb_node_new(0, depth2, 0, 0);
    slot2->cteMDBNode = mdb_node_new(0, depth1, 0, 0);

    slot1->cap = cap2;
    slot2->cap = cap1;

    if (cap_get_capType(slot1->cap) != cap_null_cap) {
        ksRootCTE = aaInsert(ksRootCTE, slot1);
    }
    if (cap_get_capType(slot2->cap) != cap_null_cap) {
        ksRootCTE = aaInsert(ksRootCTE, slot2);
    }
}

/*****************************************************************************
 * AA Tree implementation
 *****************************************************************************/

/* AA Tree rebalancing functions */
static cte_t *aaRemoveNode(bool_t isSwapped, cte_t *rootSlot);
static cte_t *aaRebalance(cte_t *slot);
static cte_t *aaDecLevel(cte_t *slot);
static cte_t *aaSkew(cte_t *slot);
static cte_t *aaSplit(cte_t *slot);

static cte_t * aaSucc(cte_t *slot)
{
    cte_t *left;

    left = ((cte_t *)(mdb_node_get_cdtLeft(slot->cteMDBNode)));
    while (left) {
        slot = left;
        left = ((cte_t *)(mdb_node_get_cdtLeft(slot->cteMDBNode)));
    }
    return slot;
}

static cte_t * aaPred(cte_t *slot)
{
    cte_t *right;

    right = ((cte_t *)(mdb_node_get_cdtRight(slot->cteMDBNode)));
    while (right) {
        slot = right;
        right = ((cte_t *)(mdb_node_get_cdtRight(slot->cteMDBNode)));
    }
    return slot;
}

static cte_t *aaParent(cte_t *slot)
{
    cte_t *current = ((void *)0);
    cte_t *next;

    next = ksRootCTE;
    while (next != slot) {
        current = next;
        switch (compSlot(current, slot)) {
        case (-1):
            next = ((cte_t *)(mdb_node_get_cdtRight(current->cteMDBNode)));
            break;
        case ( 1):
            next = ((cte_t *)(mdb_node_get_cdtLeft(current->cteMDBNode)));
            break;
        case ( 0):
            return current;
        }
    }
    return current;
}

static cte_t *aaTraverseBackward(cte_t *slot)
{
    cte_t *parent;
    cte_t *left;
    /* Optimistically see if we our predecessor is a child */
    left = ((cte_t *)(mdb_node_get_cdtLeft(slot->cteMDBNode)));
    if (left) {
        return aaPred(left);
    }
    /* We need to find our parent. This is actually hard so we
     * need to find ourselves and perform a trace as we do so */

    /* search upwards until we find an ancestor on a right link,
     * we have then found something before us */
    parent = aaParent(slot);
    while (parent && ((cte_t *)(mdb_node_get_cdtRight(parent->cteMDBNode))) != slot) {
        slot = parent;
        parent = aaParent(parent);
    }
    return parent;
}

static cte_t *aaTraverseForward(cte_t *slot)
{
    cte_t *parent;
    cte_t *right;
    /* Optimistically see if we our successor is a child */
    right = ((cte_t *)(mdb_node_get_cdtRight(slot->cteMDBNode)));
    if (right) {
        return aaSucc(right);
    }
    /* We need to find our parent. This is actually hard so we
     * need to find ourselves and perform a trace as we do so */


    /* search upwards until we find an ancestor on a left link,
     * we have then found something before us */
    parent = aaParent(slot);
    while (parent && ((cte_t *)(mdb_node_get_cdtLeft(parent->cteMDBNode))) != slot) {
        slot = parent;
        parent = aaParent(parent);
    }
    return parent;
}

static inline int
aaLevel(cte_t *slot)
{
    if (!slot) {
        return 0;
    }
    return mdb_node_get_cdtLevel(slot->cteMDBNode);
}

static inline int __attribute__((__const__)) min(int a, int b)
{
    return (a < b) ? a : b;
}

static cte_t *aaInsert(cte_t *rootSlot, cte_t *newSlot)
{
    cte_t *left, *right;

    if (!newSlot) {
        _fail("inserting null CTE", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 852, __func__);
    }
    if(!(newSlot != rootSlot)) _assert_fail("newSlot != rootSlot", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 854, __FUNCTION__);

    if (!rootSlot) {

        mdb_node_ptr_set_cdtLevel(&newSlot->cteMDBNode, 1);
        return newSlot;

    } else {

        switch (compSlot(newSlot, rootSlot)) {
        case ( 1):
            right = ((cte_t *)(mdb_node_get_cdtRight(rootSlot->cteMDBNode)));
            right = aaInsert(right, newSlot);
            mdb_node_ptr_set_cdtRight(&rootSlot->cteMDBNode, ((unsigned int)(right)));
            break;

        case (-1):
            left = ((cte_t *)(mdb_node_get_cdtLeft(rootSlot->cteMDBNode)));
            left = aaInsert(left, newSlot);
            mdb_node_ptr_set_cdtLeft(&rootSlot->cteMDBNode, ((unsigned int)(left)));
            break;

        default:
            _fail("Inserting duplicate", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 877, __func__);
        }

        rootSlot = aaSkew(rootSlot);
        rootSlot = aaSplit(rootSlot);

        return rootSlot;
    }
}

static cte_t *aaRemove(bool_t isSwapped, cte_t *rootSlot, cte_t *targetSlot)
{
    cte_t *left, *right;

    if (!targetSlot) {
        _fail("removing null", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 892, __func__);
    }
    if (!rootSlot) {
        _fail("removing from null", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 895, __func__);
    }

    switch (compSlot(targetSlot, rootSlot)) {
    case ( 1):
        right = ((cte_t *)(mdb_node_get_cdtRight(rootSlot->cteMDBNode)));
        right = aaRemove(isSwapped, right, targetSlot);
        mdb_node_ptr_set_cdtRight(&rootSlot->cteMDBNode, ((unsigned int)(right)));
        break;
    case (-1):
        left = ((cte_t *)(mdb_node_get_cdtLeft(rootSlot->cteMDBNode)));
        left = aaRemove(isSwapped, left, targetSlot);
        mdb_node_ptr_set_cdtLeft(&rootSlot->cteMDBNode, ((unsigned int)(left)));
        break;
    default:
        rootSlot = aaRemoveNode(isSwapped, rootSlot);
    }
    rootSlot = aaRebalance(rootSlot);
    return rootSlot;
}

/* AA Tree rebalancing functions */

static cte_t *aaRemoveNode(bool_t isSwapped, cte_t *rootSlot)
{
    cte_t *left, *right, *pred, *succ;
    mdb_node_t mdb;

    mdb = rootSlot->cteMDBNode;

    left = ((cte_t *)(mdb_node_get_cdtLeft(mdb)));
    right = ((cte_t *)(mdb_node_get_cdtRight(mdb)));
    if (left) {
        pred = aaPred(left);
        left = aaRemove(true, left, pred);

        mdb_node_ptr_set_cdtLevel(&pred->cteMDBNode, mdb_node_get_cdtLevel(mdb));
        mdb_node_ptr_set_cdtRight(&pred->cteMDBNode, mdb_node_get_cdtRight(mdb));
        mdb_node_ptr_set_cdtLeft(&pred->cteMDBNode, ((unsigned int)(left)));

        return pred;

    } else if (right) {
        succ = aaSucc(right);
        right = aaRemove(true, right, succ);

        mdb_node_ptr_set_cdtLevel(&succ->cteMDBNode, mdb_node_get_cdtLevel(mdb));
        mdb_node_ptr_set_cdtRight(&succ->cteMDBNode, ((unsigned int)(right)));
        mdb_node_ptr_set_cdtLeft(&succ->cteMDBNode, ((unsigned int)(((void *)0))));

        return succ;

    } else {
        return ((void *)0);
    }
}

static cte_t *aaRebalance(cte_t *slot)
{
    cte_t *right, *right_right;

    if (!slot) {
        return ((void *)0);
    }

    slot = aaDecLevel(slot);
    slot = aaSkew(slot);

    right = aaSkew(((cte_t *)(mdb_node_get_cdtRight(slot->cteMDBNode))));
    mdb_node_ptr_set_cdtRight(&slot->cteMDBNode, ((unsigned int)(right)));

    if (right) {
        right_right = aaSkew(((cte_t *)(mdb_node_get_cdtRight(right->cteMDBNode))));
        mdb_node_ptr_set_cdtRight(&right->cteMDBNode, ((unsigned int)(right_right)));
    }

    slot = aaSplit(slot);

    right = aaSplit(((cte_t *)(mdb_node_get_cdtRight(slot->cteMDBNode))));
    mdb_node_ptr_set_cdtRight(&slot->cteMDBNode, ((unsigned int)(right)));

    return slot;
}

static cte_t *aaDecLevel(cte_t *slot)
{
    cte_t *left, *right;
    int should_be;

    if (!slot) {
        return ((void *)0);
    }

    left = ((cte_t *)(mdb_node_get_cdtLeft(slot->cteMDBNode)));
    right = ((cte_t *)(mdb_node_get_cdtRight(slot->cteMDBNode)));

    should_be = min(aaLevel(left), aaLevel(right)) + 1;

    if (should_be < mdb_node_get_cdtLevel(slot->cteMDBNode)) {
        mdb_node_ptr_set_cdtLevel(&slot->cteMDBNode, should_be);

        if (right && should_be < mdb_node_get_cdtLevel(right->cteMDBNode)) {
            mdb_node_ptr_set_cdtLevel(&right->cteMDBNode, should_be);
        }
    }

    return slot;
}

static cte_t *aaSplit(cte_t *slot)
{
    cte_t *right, *right_right;
    int level;

    /*
     *                             |
     *     |                      |R|
     *    |T|->|R|->|X|   =>     /        *   /    /                |T|   |X|
|
     * |A|  |B|               /        *                      |A|   |B|
|
     */

    if (!slot) {
        return ((void *)0);
    }

    right = ((cte_t *)(mdb_node_get_cdtRight(slot->cteMDBNode)));
    if (right) {

        right_right = ((cte_t *)(mdb_node_get_cdtRight(right->cteMDBNode)));
        if (right_right && mdb_node_get_cdtLevel(slot->cteMDBNode)
                == mdb_node_get_cdtLevel(right_right->cteMDBNode)) {

            mdb_node_ptr_set_cdtRight(&slot->cteMDBNode,
                                      mdb_node_get_cdtLeft(right->cteMDBNode));

            level = mdb_node_get_cdtLevel(right->cteMDBNode) + 1;
            mdb_node_ptr_set_cdtLevel(&right->cteMDBNode, level);

            /* check level dosn't overflow */
            if(!(mdb_node_get_cdtLevel(right->cteMDBNode) == level)) _assert_fail("mdb_node_get_cdtLevel(right->cteMDBNode) == level", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c", 1036, __FUNCTION__);

            mdb_node_ptr_set_cdtLeft(&right->cteMDBNode, ((unsigned int)(slot)));

            return right;
        }
    }

    return slot;
}

static cte_t *aaSkew(cte_t *slot)
{
    cte_t *left;

    /*
     *          |              |
     *    |L|<-|T|     =>     |L|->|T|
     *   /   \    \          /    /        * |A|   |B|  |R|      |A|  |B|   |R|
|
     */

    if (!slot) {
        return ((void *)0);
    }

    left = ((cte_t *)(mdb_node_get_cdtLeft(slot->cteMDBNode)));
    if (left && mdb_node_get_cdtLevel(left->cteMDBNode)
            == mdb_node_get_cdtLevel(slot->cteMDBNode)) {

        mdb_node_ptr_set_cdtLeft(&slot->cteMDBNode,
                                 mdb_node_get_cdtRight(left->cteMDBNode));
        mdb_node_ptr_set_cdtRight(&left->cteMDBNode, ((unsigned int)(slot)));

        return left;
    }

    return slot;
}

/*****************************************************************************
 * AA Tree Debug Functions
 *****************************************************************************/

static char *
printCap(cap_t cap)
{
    switch (cap_get_capType(cap)) {
    case cap_null_cap:
        return "NullCap";
    case cap_untyped_cap:
        return "Untyped";
    case cap_endpoint_cap:
        return "Endpoint";
    case cap_async_endpoint_cap:
        return "AsyncEndpoint";
    case cap_reply_cap:
        return "Reply";
    case cap_cnode_cap:
        return "CNode";
    case cap_thread_cap:
        return "Thread";
    default:
        return "?";
    }
}

void
printCTE(char *msg, cte_t *cte)
{
    (void)printCap;
    if (!cte) {
        kprintf("%s [NULL]@0x%x", msg, cte);
    } else {
        kprintf("%s [%d %s(%d) { addr = 0x%x, size = 0x%x } left: 0x%x right: 0x%x badge: %d depth: %d extra: 0x%x]@0x%x\n", msg, mdb_node_get_cdtLevel(cte->cteMDBNode), printCap(cte->cap), cap_get_capType(cte->cap), cap_get_capType(cte->cap) == cap_null_cap ? 0 : (word_t)cap_get_capSpacePtr(cte->cap), cap_get_capType(cte->cap) == cap_null_cap ? 0 : cap_get_capSpaceSize(cte->cap), mdb_node_get_cdtLeft(cte->cteMDBNode), mdb_node_get_cdtRight(cte->cteMDBNode), cap_get_capBadge(cte->cap), mdb_node_get_cdtDepth(cte->cteMDBNode), cap_get_capType(cte->cap) == cap_null_cap ? 0 : cap_get_capExtraComp(cte->cap), cte)
# 1122 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cdt.c"
                   ;
    }
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cspace.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cspace.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cspace.c" 2

lookupCap_ret_t
lookupCap(tcb_t *thread, cptr_t cPtr)
{
    lookupSlot_raw_ret_t lu_ret;
    lookupCap_ret_t ret;

    lu_ret = lookupSlot(thread, cPtr);
    if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
        ret.status = lu_ret.status;
        ret.cap = cap_null_cap_new();
        return ret;
    }

    ret.status = EXCEPTION_NONE;
    ret.cap = lu_ret.slot->cap;
    return ret;
}

lookupCapAndSlot_ret_t
lookupCapAndSlot(tcb_t *thread, cptr_t cPtr)
{
    lookupSlot_raw_ret_t lu_ret;
    lookupCapAndSlot_ret_t ret;

    lu_ret = lookupSlot(thread, cPtr);
    if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
        ret.status = lu_ret.status;
        ret.slot = ((void *)0);
        ret.cap = cap_null_cap_new();
        return ret;
    }

    ret.status = EXCEPTION_NONE;
    ret.slot = lu_ret.slot;
    ret.cap = lu_ret.slot->cap;
    return ret;
}

lookupSlot_raw_ret_t
lookupSlot(tcb_t *thread, cptr_t capptr)
{
    cap_t threadRoot;
    resolveAddressBits_ret_t res_ret;
    lookupSlot_raw_ret_t ret;

    threadRoot = (((cte_t *)((unsigned int)(thread)&~((1ul<<(10))-1ul)))+(tcbCTable))->cap;
    res_ret = resolveAddressBits(threadRoot, capptr, 32);

    ret.status = res_ret.status;
    ret.slot = res_ret.slot;
    return ret;
}

lookupSlot_ret_t
lookupSlotForCNodeOp(bool_t isSource, cap_t root, cptr_t capptr,
                     unsigned int depth)
{
    resolveAddressBits_ret_t res_ret;
    lookupSlot_ret_t ret;

    ret.slot = ((void *)0);

    if (__builtin_expect(!!(cap_get_capType(root) != cap_cnode_cap), 0)) {
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = isSource;
        current_lookup_fault = lookup_fault_invalid_root_new();
        ret.status = EXCEPTION_SYSCALL_ERROR;
        return ret;
    }

    if (__builtin_expect(!!(depth < 1 || depth > 32), 0)) {
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 1;
        current_syscall_error.rangeErrorMax = 32;
        ret.status = EXCEPTION_SYSCALL_ERROR;
        return ret;
    }

    res_ret = resolveAddressBits(root, capptr, depth);
    if (__builtin_expect(!!(res_ret.status != EXCEPTION_NONE), 0)) {
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = isSource;
        /* current_lookup_fault will have been set by resolveAddressBits */
        ret.status = EXCEPTION_SYSCALL_ERROR;
        return ret;
    }

    if (__builtin_expect(!!(res_ret.bitsRemaining != 0), 0)) {
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = isSource;
        current_lookup_fault =
            lookup_fault_depth_mismatch_new(0, res_ret.bitsRemaining);
        ret.status = EXCEPTION_SYSCALL_ERROR;
        return ret;
    }

    ret.slot = res_ret.slot;
    ret.status = EXCEPTION_NONE;
    return ret;
}

lookupSlot_ret_t
lookupSourceSlot(cap_t root, cptr_t capptr, unsigned int depth)
{
    return lookupSlotForCNodeOp(true, root, capptr, depth);
}

lookupSlot_ret_t
lookupTargetSlot(cap_t root, cptr_t capptr, unsigned int depth)
{
    return lookupSlotForCNodeOp(false, root, capptr, depth);
}

lookupSlot_ret_t
lookupPivotSlot(cap_t root, cptr_t capptr, unsigned int depth)
{
    return lookupSlotForCNodeOp(true, root, capptr, depth);
}

resolveAddressBits_ret_t
resolveAddressBits(cap_t nodeCap, cptr_t capptr, unsigned int n_bits)
{
    resolveAddressBits_ret_t ret;
    unsigned int radixBits, guardBits, levelBits, offset;
    cte_t *slot;

    ret.bitsRemaining = n_bits;
    ret.slot = ((void *)0);

    if (__builtin_expect(!!(cap_get_capType(nodeCap) != cap_cnode_cap), 0)) {
        current_lookup_fault = lookup_fault_invalid_root_new();
        ret.status = EXCEPTION_LOOKUP_FAULT;
        return ret;
    }

    guardBits = cap_cnode_cap_get_capCNodeGuardSize(nodeCap);
    if (__builtin_expect(!!(guardBits > n_bits), 0)) {
        current_lookup_fault =
            lookup_fault_guard_mismatch_new(0, n_bits, guardBits);
        ret.status = EXCEPTION_LOOKUP_FAULT;
        return ret;
    }
    n_bits -= guardBits;

    while (1) {
        radixBits = cap_cnode_cap_get_capCNodeRadix(nodeCap);
        levelBits = radixBits;

        /* Haskell error: "All CNodes must resolve bits" */
        if(!(levelBits != 0)) _assert_fail("levelBits != 0", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/cspace.c", 168, __FUNCTION__);

        if (__builtin_expect(!!(levelBits > n_bits), 0)) {
            current_lookup_fault =
                lookup_fault_depth_mismatch_new(levelBits, n_bits);
            ret.status = EXCEPTION_LOOKUP_FAULT;
            return ret;
        }

        offset = (capptr >> (n_bits - levelBits)) & ((1ul<<(radixBits))-1ul);
        slot = ((cte_t *)(cap_cnode_cap_get_capCNodePtr(nodeCap))) + offset;

        if (__builtin_expect(!!(n_bits <= levelBits), 1)) {
            ret.status = EXCEPTION_NONE;
            ret.slot = slot;
            ret.bitsRemaining = 0;
            return ret;
        }

        /** GHOSTUPD: "(\<acute>levelBits > 0, id)" */

        n_bits -= levelBits;
        nodeCap = slot->cap;

        if (__builtin_expect(!!(cap_get_capType(nodeCap) != cap_cnode_cap), 0)) {
            ret.status = EXCEPTION_NONE;
            ret.slot = slot;
            ret.bitsRemaining = n_bits;
            return ret;
        }
    }

    ret.status = EXCEPTION_NONE;
    return ret;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/faulthandler.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/faulthandler.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/faulthandler.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/faulthandler.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/faulthandler.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/faulthandler.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/faulthandler.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/faulthandler.c" 2

void
handleFault(tcb_t *tptr)
{
    exception_t status;
    fault_t fault = current_fault;

    status = sendFaultIPC(tptr);
    if (status != EXCEPTION_NONE) {
        handleDoubleFault(tptr, fault);
    }
}

exception_t
sendFaultIPC(tcb_t *tptr)
{
    cptr_t handlerCPtr;
    cap_t handlerCap;
    lookupCap_ret_t lu_ret;
    lookup_fault_t original_lookup_fault;

    original_lookup_fault = current_lookup_fault;

    handlerCPtr = tptr->tcbFaultHandler;
    lu_ret = lookupCap(tptr, handlerCPtr);
    if (lu_ret.status != EXCEPTION_NONE) {
        current_fault = fault_cap_fault_new(handlerCPtr, false);
        return EXCEPTION_FAULT;
    }
    handlerCap = lu_ret.cap;

    if (cap_get_capType(handlerCap) == cap_endpoint_cap &&
            cap_endpoint_cap_get_capCanSend(handlerCap) &&
            cap_endpoint_cap_get_capCanGrant(handlerCap)) {
        tptr->tcbFault = current_fault;
        if (fault_get_faultType(current_fault) == fault_cap_fault) {
            tptr->tcbLookupFailure = original_lookup_fault;
        }
        sendIPC(true, false,
                cap_endpoint_cap_get_capEPBadge(handlerCap),
                true, tptr,
                ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(handlerCap))));

        return EXCEPTION_NONE;
    } else {
        current_fault = fault_cap_fault_new(handlerCPtr, false);
        current_lookup_fault = lookup_fault_missing_capability_new(0);

        return EXCEPTION_FAULT;
    }
}


static void
print_fault(fault_t f)
{
    switch (fault_get_faultType(f)) {
    case fault_null_fault:
        kprintf("null fault");
        break;
    case fault_cap_fault:
        kprintf("cap fault in %s phase at address 0x%x", fault_cap_fault_get_inReceivePhase(f) ? "receive" : "send", (unsigned int)fault_cap_fault_get_address(f))

                                                            ;
        break;
    case fault_vm_fault:
        kprintf("vm fault on %s at address 0x%x with status 0x%x", fault_vm_fault_get_instructionFault(f) ? "code" : "data", (unsigned int)fault_vm_fault_get_address(f), (unsigned int)fault_vm_fault_get_FSR(f))


                                                       ;
        break;
    case fault_unknown_syscall:
        kprintf("unknown syscall 0x%x", (unsigned int)fault_unknown_syscall_get_syscallNumber(f))
                                                                        ;
        break;
    case fault_user_exception:
        kprintf("user exception 0x%x code 0x%x", (unsigned int)fault_user_exception_get_number(f), (unsigned int)fault_user_exception_get_code(f))

                                                              ;
        break;
    default:
        kprintf("unknown fault");
        break;
    }
}


/* The second fault, ex2, is stored in the global current_fault */
void
handleDoubleFault(tcb_t *tptr, fault_t ex1)
{

    fault_t ex2 = current_fault;
    kprintf("Caught ");
    print_fault(ex2);
    kprintf("\nwhile trying to handle:\n");
    print_fault(ex1);
    kprintf("\nin thread 0x%x \"%s\" ", (unsigned int)tptr, tptr->tcbName);
    kprintf("at address 0x%x\n", (unsigned int)getRestartPC(tptr));


    setThreadState(tptr, ThreadState_Inactive);
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/faults.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c" 2

static message_info_t
transferCaps(message_info_t info, extra_caps_t caps,
             endpoint_t *endpoint, tcb_t *receiver,
             word_t *receiveBuffer, bool_t diminish);

static inline bool_t __attribute__((__pure__))
isBlocked(const tcb_t *thread)
{
    switch (thread_state_get_tsType(thread->tcbState)) {
    case ThreadState_Inactive:
    case ThreadState_BlockedOnReceive:
    case ThreadState_BlockedOnSend:
    case ThreadState_BlockedOnAsyncEvent:
    case ThreadState_BlockedOnReply:
        return true;

    default:
        return false;
    }
}

static inline bool_t __attribute__((__pure__))
isRunnable(const tcb_t *thread)
{
    switch (thread_state_get_tsType(thread->tcbState)) {
    case ThreadState_Running:
    case ThreadState_RunningVM:
    case ThreadState_Restart:
        return true;

    default:
        return false;
    }
}

__attribute__((__section__(".boot.text"))) void
configureIdleThread(tcb_t *tcb)
{
    Arch_configureIdleThread(tcb);
    setThreadState(tcb, ThreadState_IdleThreadState);
}

void
activateThread(void)
{
    switch (thread_state_get_tsType(ksCurThread->tcbState)) {
    case ThreadState_Running:
    case ThreadState_RunningVM:
        break;

    case ThreadState_Restart: {
        word_t pc;

        pc = getRestartPC(ksCurThread);
        setNextPC(ksCurThread, pc);
        setThreadState(ksCurThread, ThreadState_Running);
        break;
    }

    case ThreadState_IdleThreadState:
        Arch_activateIdleThread(ksCurThread);
        break;

    default:
        _fail("Current thread is blocked", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c", 89, __func__);
    }
}

void
suspend(tcb_t *target)
{
    ipcCancel(target);
    /*if (cap_get_capType(TCB_PTR_CTE_PTR(target, tcbCaller)->cap) == cap_reply_cap)*/
    {
        deleteCallerCap(target);
    }
    setThreadState(target, ThreadState_Inactive);
    tcbSchedDequeue(target);
}

void
restart(tcb_t *target)
{
    if (isBlocked(target)) {
        ipcCancel(target);
        setupReplyMaster(target);
        setThreadState(target, ThreadState_Restart);
        tcbSchedEnqueue(target);
        switchIfRequiredTo(target);
    }
}

void
doIPCTransfer(tcb_t *sender, endpoint_t *endpoint, word_t badge,
              bool_t grant, tcb_t *receiver, bool_t diminish)
{
    void *receiveBuffer, *sendBuffer;

    receiveBuffer = lookupIPCBuffer(true, receiver);

    if (__builtin_expect(!!(!fault_get_faultType(sender->tcbFault) != fault_null_fault), 1)) {
        sendBuffer = lookupIPCBuffer(false, sender);
        doNormalTransfer(sender, sendBuffer, endpoint, badge, grant,
                         receiver, receiveBuffer, diminish);
    } else {
        doFaultTransfer(badge, sender, receiver, receiveBuffer);
    }
}

void
doReplyTransfer(tcb_t *sender, tcb_t *receiver, cte_t *slot)
{
    if(!(thread_state_get_tsType(receiver->tcbState) == ThreadState_BlockedOnReply)) _assert_fail("thread_state_get_tsType(receiver->tcbState) == ThreadState_BlockedOnReply",
 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c"
# 137 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c"
    ,
 138
# 137 "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c"
    , __FUNCTION__)
                                      ;

    if (__builtin_expect(!!(fault_get_faultType(receiver->tcbFault) == fault_null_fault), 1)) {
        doIPCTransfer(sender, ((void *)0), 0, true, receiver, false);
        /** GHOSTUPD: "(True, gs_set_assn cteDeleteOne_'proc (ucast cap_reply_cap))" */
        setThreadState(receiver, ThreadState_Running);
        attemptSwitchTo(receiver);
    } else {
        bool_t restart;

        /** GHOSTUPD: "(True, gs_set_assn cteDeleteOne_'proc (ucast cap_reply_cap))" */
        restart = handleFaultReply(receiver, sender);
        fault_null_fault_ptr_new(&receiver->tcbFault);
        if (restart) {
            setThreadState(receiver, ThreadState_Restart);
            attemptSwitchTo(receiver);
        } else {
            setThreadState(receiver, ThreadState_Inactive);
        }
    }
    finaliseCap(slot->cap, true, true);
    slot->cap = cap_null_cap_new();
}

void
doNormalTransfer(tcb_t *sender, word_t *sendBuffer, endpoint_t *endpoint,
                 word_t badge, bool_t canGrant, tcb_t *receiver,
                 word_t *receiveBuffer, bool_t diminish)
{
    unsigned int msgTransferred;
    message_info_t tag;
    exception_t status;
    extra_caps_t caps;

    tag = messageInfoFromWord(getRegister(sender, msgInfoRegister));

    if (canGrant) {
        status = lookupExtraCaps(sender, sendBuffer, tag);
        caps = current_extra_caps;
        if (__builtin_expect(!!(status != EXCEPTION_NONE), 0)) {
            caps.excaprefs[0] = ((void *)0);
        }
    } else {
        caps = current_extra_caps;
        caps.excaprefs[0] = ((void *)0);
    }

    msgTransferred = copyMRs(sender, sendBuffer, receiver, receiveBuffer,
                             message_info_get_msgLength(tag));

    tag = transferCaps(tag, caps, endpoint, receiver, receiveBuffer, diminish);

    tag = message_info_set_msgLength(tag, msgTransferred);
    setRegister(receiver, msgInfoRegister, wordFromMessageInfo(tag));
    setRegister(receiver, badgeRegister, badge);
}

void
doFaultTransfer(word_t badge, tcb_t *sender, tcb_t *receiver,
                word_t *receiverIPCBuffer)
{
    unsigned int sent;
    message_info_t msgInfo;

    sent = setMRs_fault(sender, receiver, receiverIPCBuffer);
    msgInfo = message_info_new(
                  fault_get_faultType(sender->tcbFault), 0, 0, sent);
    setRegister(receiver, msgInfoRegister, wordFromMessageInfo(msgInfo));
    setRegister(receiver, badgeRegister, badge);
}

/* Like getReceiveSlots, this is specialised for single-cap transfer. */
static message_info_t
transferCaps(message_info_t info, extra_caps_t caps,
             endpoint_t *endpoint, tcb_t *receiver,
             word_t *receiveBuffer, bool_t diminish)
{
    unsigned int i;
    cte_t* destSlot;

    info = message_info_set_msgExtraCaps(info, 0);
    info = message_info_set_msgCapsUnwrapped(info, 0);

    if (__builtin_expect(!!(!caps.excaprefs[0] || !receiveBuffer), 1)) {
        return info;
    }

    destSlot = getReceiveSlots(receiver, receiveBuffer);

    for (i = 0; i < ((1ul<<(seL4_MsgExtraCapBits))-1) && caps.excaprefs[i] != ((void *)0); i++) {
        cte_t *slot = caps.excaprefs[i];
        cap_t cap = slot->cap;

        if (cap_get_capType(cap) == cap_endpoint_cap &&
                ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(cap))) == endpoint) {
            /* If this is a cap to the endpoint on which the message was sent,
             * only transfer the badge, not the cap. */
            setExtraBadge(receiveBuffer,
                          cap_endpoint_cap_get_capEPBadge(cap), i);

            info = message_info_set_msgCapsUnwrapped(info,
                                                     message_info_get_msgCapsUnwrapped(info) | (1 << i));

        } else {
            deriveCap_ret_t dc_ret;

            if (!destSlot) {
                break;
            }

            if (diminish) {
                dc_ret = deriveCap(slot, maskCapRights(cap_rights_new(true, true, false), cap));
            } else {
                dc_ret = deriveCap(slot, cap);
            }

            if (dc_ret.status != EXCEPTION_NONE) {
                break;
            }
            if (cap_get_capType(dc_ret.cap) == cap_null_cap) {
                break;
            }

            cteInsert(dc_ret.cap, slot, destSlot);

            destSlot = ((void *)0);
        }
    }

    return message_info_set_msgExtraCaps(info, i);
}

void doPollFailedTransfer(tcb_t *thread)
{
    /* Set the badge register to 0 to indicate there was no message */
    setRegister(thread, badgeRegister, 0);
}

static void
nextDomain(void)
{
    ksDomScheduleIdx++;
    if (ksDomScheduleIdx >= ksDomScheduleLength) {
        ksDomScheduleIdx = 0;
    }
    ksWorkUnitsCompleted = 0;
    ksCurDomain = ksDomSchedule[ksDomScheduleIdx].domain;
    ksDomainTime = ksDomSchedule[ksDomScheduleIdx].length;
}

void
schedule(void)
{
    word_t action;

    action = (word_t)ksSchedulerAction;
    if (action == (word_t)((tcb_t*)~0)) {
        if (isRunnable(ksCurThread)) {
            tcbSchedEnqueue(ksCurThread);
        }
        if (1 > 1 && ksDomainTime == 0) {
            nextDomain();
        }
        chooseThread();
        ksSchedulerAction = ((tcb_t*)0);
    } else if (action != (word_t)((tcb_t*)0)) {
        if (isRunnable(ksCurThread)) {
            tcbSchedEnqueue(ksCurThread);
        }
        /* SwitchToThread */
        switchToThread(ksSchedulerAction);
        ksSchedulerAction = ((tcb_t*)0);
    }
}

void
chooseThread(void)
{
    word_t prio;
    word_t dom;
    tcb_t *thread;

    if (1 > 1) {
        dom = ksCurDomain;
    } else {
        dom = 0;
    }

    if (__builtin_expect(!!(ksReadyQueuesL1Bitmap[dom]), 1)) {
        uint32_t l1index = (32 - 1) - __builtin_clz(ksReadyQueuesL1Bitmap[dom]);
        uint32_t l2index = (32 - 1) - __builtin_clz(ksReadyQueuesL2Bitmap[dom][l1index]);
        prio = l1index_to_prio(l1index) | l2index;
        thread = ksReadyQueues[ready_queues_index(dom, prio)].head;
        if(!(thread)) _assert_fail("thread", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c", 331, __FUNCTION__);
        if(!(isRunnable(thread))) _assert_fail("isRunnable(thread)", "/home/kq/Sources/RefOS_x86/kernel/src/kernel/thread.c", 332, __FUNCTION__);
        switchToThread(thread);
        return;
    }

    switchToIdleThread();

}

void
switchToThread(tcb_t *thread)
{
    Arch_switchToThread(thread);
    tcbSchedDequeue(thread);
    ksCurThread = thread;
}

void
switchToIdleThread(void)
{
    Arch_switchToIdleThread();
    ksCurThread = ksIdleThread;
}

void
setDomain(tcb_t *tptr, dom_t dom)
{
    tcbSchedDequeue(tptr);
    tptr->tcbDomain = dom;
    if (isRunnable(tptr)) {
        tcbSchedEnqueue(tptr);
    }
    if (tptr == ksCurThread) {
        rescheduleRequired();
    }
}

void
setPriority(tcb_t *tptr, prio_t prio)
{
    tcbSchedDequeue(tptr);
    tptr->tcbPriority = prio;
    if (isRunnable(tptr)) {
        tcbSchedEnqueue(tptr);
    }
    if (tptr == ksCurThread) {
        rescheduleRequired();
    }
}

static void
possibleSwitchTo(tcb_t* target, bool_t onSamePriority)
{
    prio_t curPrio, targetPrio;
    tcb_t *action;

    curPrio = ksCurThread->tcbPriority;
    targetPrio = target->tcbPriority;
    action = ksSchedulerAction;

    if (1 > 1) {
        dom_t curDom = ksCurDomain;
        dom_t targetDom = target->tcbDomain;

        if (targetDom != curDom) {
            tcbSchedEnqueue(target);
        }
    } else {
        if ((targetPrio > curPrio || (targetPrio == curPrio && onSamePriority))
                && action == ((tcb_t*)0)) {
            ksSchedulerAction = target;
        } else {
            tcbSchedEnqueue(target);
        }
        if (action != ((tcb_t*)0)
                && action != ((tcb_t*)~0)) {
            rescheduleRequired();
        }
    }
}

void
attemptSwitchTo(tcb_t* target)
{
    possibleSwitchTo(target, true);
}

void
switchIfRequiredTo(tcb_t* target)
{
    possibleSwitchTo(target, false);
}

void
setThreadState(tcb_t *tptr, _thread_state_t ts)
{
    thread_state_ptr_set_tsType(&tptr->tcbState, ts);
    scheduleTCB(tptr);
}

void
scheduleTCB(tcb_t *tptr)
{
    if (tptr == ksCurThread &&
            ksSchedulerAction == ((tcb_t*)0) &&
            !isRunnable(tptr)) {
        rescheduleRequired();
    }
}

void
timerTick(void)
{
    if (__builtin_expect(!!(isRunnable(ksCurThread)), 1)) {
        if (ksCurThread->tcbTimeSlice > 1) {
            ksCurThread->tcbTimeSlice--;
        } else {
            ksCurThread->tcbTimeSlice = 5;
            tcbSchedAppend(ksCurThread);
            rescheduleRequired();
        }
    }

    if (1 > 1) {
        ksDomainTime--;
        if (ksDomainTime == 0) {
            rescheduleRequired();
        }
    }
}

void
rescheduleRequired(void)
{
    if (ksSchedulerAction != ((tcb_t*)0)
            && ksSchedulerAction != ((tcb_t*)~0)) {
        tcbSchedEnqueue(ksSchedulerAction);
    }
    ksSchedulerAction = ((tcb_t*)~0);
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/machine/io.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/stdarg.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */







typedef __builtin_va_list va_list;
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/machine/io.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/machine/io.c" 2



static unsigned int
print_string(const char *s)
{
    unsigned int n;

    for (n = 0; *s; s++, n++) {
        console_putchar(*s);
    }

    return n;
}

static unsigned long
xdiv(unsigned long x, unsigned int denom)
{
    switch (denom) {
    case 16:
        return x / 16;
    case 10:
        return x / 10;
    default:
        return 0;
    }
}

static unsigned long
xmod(unsigned long x, unsigned int denom)
{
    switch (denom) {
    case 16:
        return x % 16;
    case 10:
        return x % 10;
    default:
        return 0;
    }
}

unsigned int
print_unsigned_long(unsigned long x, unsigned int ui_base)
{
    char out[11];
    unsigned int i, j;
    unsigned int d;

    /*
     * Only base 10 and 16 supported for now. We want to avoid invoking the
     * compiler's support libraries through doing arbitrary divisions.
     */
    if (ui_base != 10 && ui_base != 16) {
        return 0;
    }

    if (x == 0) {
        console_putchar('0');
        return 1;
    }

    for (i = 0; x; x = xdiv(x, ui_base), i++) {
        d = xmod(x, ui_base);

        if (d >= 10) {
            out[i] = 'a' + d - 10;
        } else {
            out[i] = '0' + d;
        }
    }

    for (j = i; j > 0; j--) {
        console_putchar(out[j - 1]);
    }

    return i;
}


static unsigned int
print_unsigned_long_long(unsigned long long x, unsigned int ui_base)
{
    unsigned long upper, lower;
    unsigned int n = 0;
    unsigned int mask = 0xF0000000u;

    /* only implemented for hex, decimal is harder without 64 bit division */
    if (ui_base != 16) {
        return 0;
    }

    /* we can't do 64 bit division so break it up into two hex numbers */
    upper = (unsigned long) (x >> 32llu);
    lower = (unsigned long) x;

    /* print first 32 bits if they exist */
    if (upper > 0) {
        n += print_unsigned_long(upper, ui_base);

        /* print leading 0s */
        while (!(mask & lower)) {
            console_putchar('0');
            n++;
            mask = mask >> 4;
        }
    }

    /* print last 32 bits */
    n += print_unsigned_long(lower, ui_base);

    return n;
}


static int
vprintf(const char *format, va_list ap)
{
    unsigned int n;
    unsigned int formatting;

    if (!format) {
        return 0;
    }

    n = 0;
    formatting = 0;
    while (*format) {
        if (formatting) {
            switch (*format) {
            case '%':
                console_putchar('%');
                n++;
                format++;
                break;

            case 'd': {
                int x = __builtin_va_arg(ap,int);

                if (x < 0) {
                    console_putchar('-');
                    n++;
                    x = -x;
                }

                n += print_unsigned_long((unsigned long)x, 10);
                format++;
                break;
            }

            case 'u':
                n += print_unsigned_long(__builtin_va_arg(ap,unsigned long), 10);
                format++;
                break;

            case 'x':
                n += print_unsigned_long(__builtin_va_arg(ap,unsigned long), 16);
                format++;
                break;

            case 'p': {
                unsigned long p = __builtin_va_arg(ap,unsigned long);
                if (p == 0) {
                    n += print_string("(nil)");
                } else {
                    n += print_string("0x");
                    n += print_unsigned_long(p, 16);
                }
                format++;
                break;
            }

            case 's':
                n += print_string(__builtin_va_arg(ap,char *));
                format++;
                break;

            case 'l':
                if (*(format + 1) == 'l' && *(format + 2) == 'x') {
                    uint64_t arg = __builtin_va_arg(ap,unsigned long long);
                    n += print_unsigned_long_long(arg, 16);
                }
                format += 3;
                break;
            default:
                format++;
                break;
            }

            formatting = 0;
        } else {
            switch (*format) {
            case '%':
                formatting = 1;
                format++;
                break;

            default:
                console_putchar(*format);
                n++;
                format++;
                break;
            }
        }
    }

    return n;
}

unsigned int puts(const char *s)
{
    for (; *s; s++) {
        console_putchar(*s);
    }
    console_putchar('\n');
    return 0;
}

unsigned int
kprintf(const char *format, ...)
{
    va_list args;
    unsigned int i;

    __builtin_va_start(args,format);
    i = vprintf(format, args);
    __builtin_va_end(args);
    return i;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/model/preemption.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/model/preemption.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/preemption.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/include/model/preemption.h" 2

exception_t preemptionPoint(void);
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/model/preemption.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/model/preemption.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/model/preemption.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/model/preemption.c" 2

/*
 * Possibly preempt the current thread to allow an interrupt to be handled.
 */
exception_t
preemptionPoint(void)
{
    /* Record that we have performed some work. */
    ksWorkUnitsCompleted++;

    /*
     * If we have performed a non-trivial amount of work since last time we
     * checked for preemption, and there is an interrupt pending, handle the
     * interrupt.
     *
     * We avoid checking for pending IRQs every call, as our callers tend to
     * call us in a tight loop and checking for pending IRQs can be quite slow.
     */
    if (ksWorkUnitsCompleted >= 100) {
        ksWorkUnitsCompleted = 0;
        if (isIRQPending()) {
            return EXCEPTION_PREEMPTED;
        }
    }

    return EXCEPTION_NONE;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/model/statedata.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/model/statedata.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/model/statedata.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/model/statedata.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/model/statedata.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/model/statedata.c" 2

/* Pointer to the head of the scheduler queue for each priority */
tcb_queue_t ksReadyQueues[(1 * 256)];
word_t ksReadyQueuesL1Bitmap[1];
word_t ksReadyQueuesL2Bitmap[1][(256 / 32) + 1];
typedef int __assert_failed_ksReadyQueuesL1BitmapBigEnough[((256 / 32) <= 32) ? 1 : -1];;

/* Current thread TCB pointer */
tcb_t *ksCurThread;

/* Idle thread TCB pointer */
tcb_t *ksIdleThread;

/* Values of 0 and ~0 encode ResumeCurrentThread and ChooseNewThread
 * respectively; other values encode SwitchToThread and must be valid
 * tcb pointers */
tcb_t *ksSchedulerAction;

/* Units of work we have completed since the last time we checked for
 * pending interrupts */
word_t ksWorkUnitsCompleted;

/* Root of the cap derivation tree structure */
cte_t *ksRootCTE;

/* CNode containing interrupt handler endpoints */
irq_state_t intStateIRQTable[maxIRQ + 1];
cte_t *intStateIRQNode;

/* Currently active domain */
dom_t ksCurDomain;

/* Domain timeslice remaining */
word_t ksDomainTime;

/* An index into ksDomSchedule for active domain and length. */
uint32_t ksDomScheduleIdx;
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c" 2

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/endpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c" 2

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/asyncendpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c" 2

static inline tcb_queue_t __attribute__((__pure__))
aep_ptr_get_queue(async_endpoint_t *aepptr)
{
    tcb_queue_t aep_queue;

    aep_queue.head = (tcb_t*)async_endpoint_ptr_get_aepQueue_head(aepptr);
    aep_queue.end = (tcb_t*)async_endpoint_ptr_get_aepQueue_tail(aepptr);

    return aep_queue;
}

static inline void
aep_ptr_set_queue(async_endpoint_t *aepptr, tcb_queue_t aep_queue)
{
    async_endpoint_ptr_set_aepQueue_head(aepptr, (word_t)aep_queue.head);
    async_endpoint_ptr_set_aepQueue_tail(aepptr, (word_t)aep_queue.end);
}

static inline void
aep_set_active(async_endpoint_t *aepptr, word_t badge)
{
    async_endpoint_ptr_set_state(aepptr, AEPState_Active);
    async_endpoint_ptr_set_aepMsgIdentifier(aepptr, badge);
}


void
sendAsyncIPC(async_endpoint_t *aepptr, word_t badge)
{
    switch (async_endpoint_ptr_get_state(aepptr)) {
    case AEPState_Idle: {
        tcb_t *tcb = (tcb_t*)async_endpoint_ptr_get_aepBoundTCB(aepptr);
        /* Check if we are bound and that thread is waiting for a message */
        if (tcb) {
            if (thread_state_ptr_get_tsType(&tcb->tcbState) == ThreadState_BlockedOnReceive) {
                /* Send and start thread running */
                ipcCancel(tcb);
                setThreadState(tcb, ThreadState_Running);
                setRegister(tcb, badgeRegister, badge);
                attemptSwitchTo(tcb);
            } else if (thread_state_ptr_get_tsType(&tcb->tcbState) == ThreadState_RunningVM) {
                setThreadState(tcb, ThreadState_Running);
                setRegister(tcb, badgeRegister, badge);
                setRegister(tcb, msgInfoRegister, 0);
                Arch_leaveVMAsyncTransfer(tcb);
                attemptSwitchTo(tcb);
            } else {
                aep_set_active(aepptr, badge);
            }
        } else {
            aep_set_active(aepptr, badge);
        }
        break;
    }
    case AEPState_Waiting: {
        tcb_queue_t aep_queue;
        tcb_t *dest;

        aep_queue = aep_ptr_get_queue(aepptr);
        dest = aep_queue.head;

        /* Haskell error "WaitingAEP AEP must have non-empty queue" */
        if(!(dest)) _assert_fail("dest", "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c", 85, __FUNCTION__);

        /* Dequeue TCB */
        aep_queue = tcbEPDequeue(dest, aep_queue);
        aep_ptr_set_queue(aepptr, aep_queue);

        /* set the thread state to idle if the queue is empty */
        if (!aep_queue.head) {
            async_endpoint_ptr_set_state(aepptr, AEPState_Idle);
        }

        setThreadState(dest, ThreadState_Running);
        setRegister(dest, badgeRegister, badge);
        switchIfRequiredTo(dest);
        break;
    }

    case AEPState_Active: {
        word_t badge2;

        badge2 = async_endpoint_ptr_get_aepMsgIdentifier(aepptr);
        badge2 |= badge;

        async_endpoint_ptr_set_aepMsgIdentifier(aepptr, badge2);
        break;
    }
    }
}

void
receiveAsyncIPC(tcb_t *thread, cap_t cap, bool_t isBlocking)
{
    async_endpoint_t *aepptr;

    aepptr = ((async_endpoint_t *)(cap_async_endpoint_cap_get_capAEPPtr(cap)));

    switch (async_endpoint_ptr_get_state(aepptr)) {
    case AEPState_Idle:
        /* Fall through */
    case AEPState_Waiting: {
        tcb_queue_t aep_queue;

        if (isBlocking) {
            /* Block thread on endpoint */
            thread_state_ptr_set_tsType(&thread->tcbState,
                                        ThreadState_BlockedOnAsyncEvent);
            thread_state_ptr_set_blockingIPCEndpoint(&thread->tcbState,
                                                     ((unsigned int)(aepptr)));
            scheduleTCB(thread);

            /* Enqueue TCB */
            aep_queue = aep_ptr_get_queue(aepptr);
            aep_queue = tcbEPAppend(thread, aep_queue);

            async_endpoint_ptr_set_state(aepptr, AEPState_Waiting);
            aep_ptr_set_queue(aepptr, aep_queue);
        } else {
            doPollFailedTransfer(thread);
        }
        break;
    }

    case AEPState_Active:
        setRegister(
            thread, badgeRegister,
            async_endpoint_ptr_get_aepMsgIdentifier(aepptr));
        async_endpoint_ptr_set_state(aepptr, AEPState_Idle);
        break;
    }
}

void
aepCancelAll(async_endpoint_t *aepptr)
{
    if (async_endpoint_ptr_get_state(aepptr) == AEPState_Waiting) {
        tcb_t *thread = ((tcb_t *)(async_endpoint_ptr_get_aepQueue_head(aepptr)));

        async_endpoint_ptr_set_state(aepptr, AEPState_Idle);
        async_endpoint_ptr_set_aepQueue_head(aepptr, 0);
        async_endpoint_ptr_set_aepQueue_tail(aepptr, 0);

        /* Set all waiting threads to Restart */
        for (; thread; thread = thread->tcbEPNext) {
            setThreadState(thread, ThreadState_Restart);
            tcbSchedEnqueue(thread);
        }
        rescheduleRequired();
    }
}

void
asyncIPCCancel(tcb_t *threadPtr, async_endpoint_t *aepptr)
{
    tcb_queue_t aep_queue;

    /* Haskell error "asyncIPCCancel: async endpoint must be waiting" */
    if(!(async_endpoint_ptr_get_state(aepptr) == AEPState_Waiting)) _assert_fail("async_endpoint_ptr_get_state(aepptr) == AEPState_Waiting", "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c", 181, __FUNCTION__);

    /* Dequeue TCB */
    aep_queue = aep_ptr_get_queue(aepptr);
    aep_queue = tcbEPDequeue(threadPtr, aep_queue);
    aep_ptr_set_queue(aepptr, aep_queue);

    /* Make endpoint idle */
    if (!aep_queue.head) {
        async_endpoint_ptr_set_state(aepptr, AEPState_Idle);
    }

    /* Make thread inactive */
    setThreadState(threadPtr, ThreadState_Inactive);
}

void
completeAsyncIPC(async_endpoint_t *aepptr, tcb_t *tcb)
{
    word_t badge;

    if (__builtin_expect(!!(tcb && async_endpoint_ptr_get_state(aepptr) == AEPState_Active), 1)) {
        async_endpoint_ptr_set_state(aepptr, AEPState_Idle);
        badge = async_endpoint_ptr_get_aepMsgIdentifier(aepptr);
        setRegister(tcb, badgeRegister, badge);
    } else {
        _fail("tried to complete async ipc with inactive AEP", "/home/kq/Sources/RefOS_x86/kernel/src/object/asyncendpoint.c", 207, __func__);
    }
}

void
unbindAsyncEndpoint(tcb_t *tcb)
{
    async_endpoint_t *aepptr;
    aepptr = tcb->boundAsyncEndpoint;

    if (aepptr) {
        async_endpoint_ptr_set_aepBoundTCB(aepptr, (word_t) 0);
        tcb->boundAsyncEndpoint = ((void *)0);
    }
}

void
bindAsyncEndpoint(tcb_t *tcb, async_endpoint_t *aepptr)
{
    async_endpoint_ptr_set_aepBoundTCB(aepptr, (word_t)tcb);
    tcb->boundAsyncEndpoint = aepptr;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "./api/invocation.h" 1
/* @LICENSE(OKL_CORE) */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/untyped.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cdt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 26 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/preemption.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 27 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 28 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 29 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c" 2

struct finaliseSlot_ret {
    exception_t status;
    bool_t success;
    irq_t irq;
};
typedef struct finaliseSlot_ret finaliseSlot_ret_t;

static finaliseSlot_ret_t finaliseSlot(cte_t *slot, bool_t exposed);
static void emptySlot(cte_t *slot, irq_t irq);
static exception_t reduceZombie(cte_t* slot, bool_t exposed);

exception_t
decodeCNodeInvocation(word_t label, unsigned int length, cap_t cap,
                      extra_caps_t extraCaps, word_t *buffer)
{
    lookupSlot_ret_t lu_ret;
    cte_t *destSlot;
    word_t index, w_bits;
    exception_t status;

    /* Haskell error: "decodeCNodeInvocation: invalid cap" */
    if(!(cap_get_capType(cap) == cap_cnode_cap)) _assert_fail("cap_get_capType(cap) == cap_cnode_cap", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 51, __FUNCTION__);

    if (label < CNodeRevoke || label > CNodeSaveCaller) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 54, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNodeCap: Illegal Operation attempted."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (length < 2) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 60, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode operation: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }
    index = getSyscallArg(0, buffer);
    w_bits = getSyscallArg(1, buffer);

    lu_ret = lookupTargetSlot(cap, index, w_bits);
    if (lu_ret.status != EXCEPTION_NONE) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 69, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode operation: Target slot invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
        return lu_ret.status;
    }
    destSlot = lu_ret.slot;

    if (label >= CNodeCopy && label <= CNodeMutate) {
        cte_t *srcSlot;
        word_t srcIndex, srcDepth, capData;
        bool_t isMove;
        cap_rights_t cap_rights;
        cap_t srcRoot, newCap;
        deriveCap_ret_t dc_ret;
        cap_t srcCap;

        if (length < 4 || extraCaps.excaprefs[0] == ((void *)0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 84, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode Copy/Mint/Move/Mutate: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_TruncatedMessage;
            return EXCEPTION_SYSCALL_ERROR;
        }
        srcIndex = getSyscallArg(2, buffer);
        srcDepth = getSyscallArg(3, buffer);

        srcRoot = extraCaps.excaprefs[0]->cap;

        status = ensureEmptySlot(destSlot);
        if (status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 95, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode Copy/Mint/Move/Mutate: Destination not empty."); kprintf(">>" "\033[0m" "\n"); } while (0);
            return status;
        }

        lu_ret = lookupSourceSlot(srcRoot, srcIndex, srcDepth);
        if (lu_ret.status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 101, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode Copy/Mint/Move/Mutate: Invalid source slot."); kprintf(">>" "\033[0m" "\n"); } while (0);
            return lu_ret.status;
        }
        srcSlot = lu_ret.slot;

        if (cap_get_capType(srcSlot->cap) == cap_null_cap) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 107, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode Copy/Mint/Move/Mutate: Source slot invalid or empty."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = 1;
            current_lookup_fault =
                lookup_fault_missing_capability_new(srcDepth);
            return EXCEPTION_SYSCALL_ERROR;
        }

        switch (label) {
        case CNodeCopy:

            if (length < 5) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 119, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Truncated message for CNode Copy operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
                current_syscall_error.type = seL4_TruncatedMessage;
                return EXCEPTION_SYSCALL_ERROR;
            }

            cap_rights = rightsFromWord(getSyscallArg(4, buffer));
            srcCap = maskCapRights(cap_rights, srcSlot->cap);
            dc_ret = deriveCap(srcSlot, srcCap);
            if (dc_ret.status != EXCEPTION_NONE) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 128, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Error deriving cap for CNode Copy operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
                return dc_ret.status;
            }
            newCap = dc_ret.cap;
            isMove = false;

            break;

        case CNodeMint:
            if (length < 6) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 138, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode Mint: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
                current_syscall_error.type = seL4_TruncatedMessage;
                return EXCEPTION_SYSCALL_ERROR;
            }

            cap_rights = rightsFromWord(getSyscallArg(4, buffer));
            capData = getSyscallArg(5, buffer);
            srcCap = maskCapRights(cap_rights, srcSlot->cap);
            dc_ret = deriveCap(srcSlot,
                               updateCapData(false, capData, srcCap));
            if (dc_ret.status != EXCEPTION_NONE) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 149, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Error deriving cap for CNode Mint operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
                return dc_ret.status;
            }
            newCap = dc_ret.cap;
            isMove = false;

            break;

        case CNodeMove:
            newCap = srcSlot->cap;
            isMove = true;

            break;

        case CNodeMutate:
            if (length < 5) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 165, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode Mutate: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
                current_syscall_error.type = seL4_TruncatedMessage;
                return EXCEPTION_SYSCALL_ERROR;
            }

            capData = getSyscallArg(4, buffer);
            newCap = updateCapData(true, capData, srcSlot->cap);
            isMove = true;

            break;

        default:
            if(!(0)) _assert_fail("0", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 177, __FUNCTION__);
            return EXCEPTION_NONE;
        }

        if (cap_get_capType(newCap) == cap_null_cap) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 182, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode Copy/Mint/Move/Mutate: Mutated cap would be invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        if (isMove) {
            return invokeCNodeMove(newCap, srcSlot, destSlot);
        } else {
            return invokeCNodeInsert(newCap, srcSlot, destSlot);
        }
    }

    if (label == CNodeRevoke) {
        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeCNodeRevoke(destSlot);
    }

    if (label == CNodeDelete) {
        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeCNodeDelete(destSlot);
    }

    if (label == CNodeSaveCaller) {
        status = ensureEmptySlot(destSlot);
        if (status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 208, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode SaveCaller: Destination slot not empty."); kprintf(">>" "\033[0m" "\n"); } while (0);
            return status;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeCNodeSaveCaller(destSlot);
    }

    if (label == CNodeRecycle) {
        if (!hasRecycleRights(destSlot->cap)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 218, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode Recycle: Target cap invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }
        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeCNodeRecycle(destSlot);
    }

    if (label == CNodeRotate) {
        word_t pivotNewData, pivotIndex, pivotDepth;
        word_t srcNewData, srcIndex, srcDepth;
        cte_t *pivotSlot, *srcSlot;
        cap_t pivotRoot, srcRoot, newSrcCap, newPivotCap;

        if (length < 8 || extraCaps.excaprefs[0] == ((void *)0)
                || extraCaps.excaprefs[1] == ((void *)0)) {
            current_syscall_error.type = seL4_TruncatedMessage;
            return EXCEPTION_SYSCALL_ERROR;
        }
        pivotNewData = getSyscallArg(2, buffer);
        pivotIndex = getSyscallArg(3, buffer);
        pivotDepth = getSyscallArg(4, buffer);
        srcNewData = getSyscallArg(5, buffer);
        srcIndex = getSyscallArg(6, buffer);
        srcDepth = getSyscallArg(7, buffer);

        pivotRoot = extraCaps.excaprefs[0]->cap;
        srcRoot = extraCaps.excaprefs[1]->cap;

        lu_ret = lookupSourceSlot(srcRoot, srcIndex, srcDepth);
        if (lu_ret.status != EXCEPTION_NONE) {
            return lu_ret.status;
        }
        srcSlot = lu_ret.slot;

        lu_ret = lookupPivotSlot(pivotRoot, pivotIndex, pivotDepth);
        if (lu_ret.status != EXCEPTION_NONE) {
            return lu_ret.status;
        }
        pivotSlot = lu_ret.slot;

        if (pivotSlot == srcSlot || pivotSlot == destSlot) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 260, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode Rotate: Pivot slot the same as source or dest slot."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }

        if (srcSlot != destSlot) {
            status = ensureEmptySlot(destSlot);
            if (status != EXCEPTION_NONE) {
                return status;
            }
        }

        if (cap_get_capType(srcSlot->cap) == cap_null_cap) {
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = 1;
            current_lookup_fault = lookup_fault_missing_capability_new(srcDepth);
            return EXCEPTION_SYSCALL_ERROR;
        }

        if (cap_get_capType(pivotSlot->cap) == cap_null_cap) {
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = 0;
            current_lookup_fault = lookup_fault_missing_capability_new(pivotDepth);
            return EXCEPTION_SYSCALL_ERROR;
        }

        newSrcCap = updateCapData(true, srcNewData, srcSlot->cap);
        newPivotCap = updateCapData(true, pivotNewData, pivotSlot->cap);

        if (cap_get_capType(newSrcCap) == cap_null_cap) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 290, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode Rotate: Source cap invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }

        if (cap_get_capType(newPivotCap) == cap_null_cap) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 296, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode Rotate: Pivot cap invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeCNodeRotate(newSrcCap, newPivotCap,
                                 srcSlot, pivotSlot, destSlot);
    }

    return EXCEPTION_NONE;
}

exception_t
invokeCNodeRevoke(cte_t *destSlot)
{
    return cteRevoke(destSlot);
}

exception_t
invokeCNodeDelete(cte_t *destSlot)
{
    return cteDelete(destSlot, true);
}

exception_t
invokeCNodeRecycle(cte_t *destSlot)
{
    return cteRecycle(destSlot);
}

exception_t
invokeCNodeInsert(cap_t cap, cte_t *srcSlot, cte_t *destSlot)
{
    cteInsert(cap, srcSlot, destSlot);

    return EXCEPTION_NONE;
}

exception_t
invokeCNodeMove(cap_t cap, cte_t *srcSlot, cte_t *destSlot)
{
    cteMove(cap, srcSlot, destSlot);

    return EXCEPTION_NONE;
}

exception_t
invokeCNodeRotate(cap_t cap1, cap_t cap2, cte_t *slot1,
                  cte_t *slot2, cte_t *slot3)
{
    if (slot1 == slot3) {
        cdtSwap(cap1, slot1, cap2, slot2);
    } else {
        cteMove(cap2, slot2, slot3);
        cteMove(cap1, slot1, slot2);
    }

    return EXCEPTION_NONE;
}

exception_t
invokeCNodeSaveCaller(cte_t *destSlot)
{
    cap_t cap;
    cte_t *srcSlot;

    srcSlot = (((cte_t *)((unsigned int)(ksCurThread)&~((1ul<<(10))-1ul)))+(tcbCaller));
    cap = srcSlot->cap;

    switch (cap_get_capType(cap)) {
    case cap_null_cap:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 368, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("CNode SaveCaller: Reply cap not present."); kprintf(">>" "\033[0m" "\n"); } while (0);
        break;

    case cap_reply_cap:
        if (!cap_reply_cap_get_capReplyMaster(cap)) {
            cteMove(cap, srcSlot, destSlot);
        }
        break;

    default:
        _fail("caller capability must be null or reply", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 378, __func__);
        break;
    }

    return EXCEPTION_NONE;
}

void
cteInsert(cap_t newCap, cte_t *srcSlot, cte_t *destSlot)
{
    /* Haskell error: "cteInsert to non-empty destination" */
    if(!(cap_get_capType(destSlot->cap) == cap_null_cap)) _assert_fail("cap_get_capType(destSlot->cap) == cap_null_cap", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 389, __FUNCTION__);

    destSlot->cap = newCap;
    cdtInsert(srcSlot, destSlot);
}

void
cteMove(cap_t newCap, cte_t *srcSlot, cte_t *destSlot)
{
    /* Haskell error: "cteMove to non-empty destination" */
    if(!(cap_get_capType(destSlot->cap) == cap_null_cap)) _assert_fail("cap_get_capType(destSlot->cap) == cap_null_cap", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 399, __FUNCTION__);

    destSlot->cap = newCap;
    if (cap_get_capType(newCap) == cap_reply_cap) {
        tcb_t *replyTCB = ((tcb_t *)(cap_reply_cap_get_capTCBPtr(newCap)));
        cte_t *replySlot = (((cte_t *)((unsigned int)(replyTCB)&~((1ul<<(10))-1ul)))+(tcbReply));
        cap_reply_cap_ptr_set_capCallerSlot(&replySlot->cap, ((unsigned int)(destSlot)));
    } else {
        cdtMove(srcSlot, destSlot);
    }
    srcSlot->cap = cap_null_cap_new();
}

void
capSwapForDelete(cte_t *slot1, cte_t *slot2)
{
    cap_t cap1, cap2;

    if (slot1 == slot2) {
        return;
    }

    cap1 = slot1->cap;
    cap2 = slot2->cap;

    cdtSwap(cap1, slot1, cap2, slot2);
}

exception_t
cteRevoke(cte_t *slot)
{
    cte_t *childPtr;
    exception_t status;

    if (cap_get_capType(slot->cap) == cap_null_cap) {
        return EXCEPTION_NONE;
    }
    for (childPtr = cdtFindChild(slot); childPtr; childPtr = cdtFindChild(slot)) {
        status = cteDelete(childPtr, true);
        if (status != EXCEPTION_NONE) {
            return status;
        }

        status = preemptionPoint();
        if (status != EXCEPTION_NONE) {
            return status;
        }
    }

    return EXCEPTION_NONE;
}

exception_t
cteDelete(cte_t *slot, bool_t exposed)
{
    finaliseSlot_ret_t fs_ret;

    fs_ret = finaliseSlot(slot, exposed);
    if (fs_ret.status != EXCEPTION_NONE) {
        return fs_ret.status;
    }

    if (exposed || fs_ret.success) {
        emptySlot(slot, fs_ret.irq);
    }
    return EXCEPTION_NONE;
}

static void
emptySlot(cte_t *slot, irq_t irq)
{
    if (cap_get_capType(slot->cap) != cap_null_cap) {
        cdtRemove(slot);
        slot->cap = cap_null_cap_new();

        if (irq != irqInvalid) {
            deletedIRQHandler(irq);
        }
    }
}

static inline bool_t __attribute__((__const__))
capRemovable(cap_t cap, cte_t* slot)
{
    switch (cap_get_capType(cap)) {
    case cap_null_cap:
        return true;
    case cap_zombie_cap: {
        word_t n = cap_zombie_cap_get_capZombieNumber(cap);
        cte_t* z_slot = (cte_t*)cap_zombie_cap_get_capZombiePtr(cap);
        return (n == 0 || (n == 1 && slot == z_slot));
    }
    default:
        _fail("finaliseCap should only return Zombie or NullCap", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 492, __func__);
    }
}

static inline bool_t __attribute__((__const__))
capCyclicZombie(cap_t cap, cte_t *slot)
{
    return cap_get_capType(cap) == cap_zombie_cap &&
           ((cte_t *)(cap_zombie_cap_get_capZombiePtr(cap))) == slot;
}

static finaliseSlot_ret_t
finaliseSlot(cte_t *slot, bool_t immediate)
{
    bool_t final;
    finaliseCap_ret_t fc_ret;
    exception_t status;
    finaliseSlot_ret_t ret;

    while (cap_get_capType(slot->cap) != cap_null_cap) {
        /* If we have a zombie cap then we know it is final and can
         * avoid an expensive cdtIsFinal check */
        final = (cap_get_capType(slot->cap) == cap_zombie_cap) || cdtIsFinal(slot);
        fc_ret = finaliseCap(slot->cap, final, false);

        if (capRemovable(fc_ret.remainder, slot)) {
            ret.status = EXCEPTION_NONE;
            ret.success = true;
            ret.irq = fc_ret.irq;
            return ret;
        }

        /* if we have a zombie then we actually don't need to call
         * cdtUpdate as the cap actually hasn't changed */
        if (cap_get_capType(slot->cap) != cap_zombie_cap) {
            cdtUpdate(slot, fc_ret.remainder);
        }

        if (!immediate && capCyclicZombie(fc_ret.remainder, slot)) {
            ret.status = EXCEPTION_NONE;
            ret.success = false;
            ret.irq = fc_ret.irq;
            return ret;
        }

        status = reduceZombie(slot, immediate);
        if (status != EXCEPTION_NONE) {
            ret.status = status;
            ret.success = false;
            ret.irq = irqInvalid;
            return ret;
        }

        status = preemptionPoint();
        if (status != EXCEPTION_NONE) {
            ret.status = status;
            ret.success = false;
            ret.irq = irqInvalid;
            return ret;
        }
    }
    ret.status = EXCEPTION_NONE;
    ret.success = true;
    ret.irq = irqInvalid;
    return ret;
}

static exception_t
reduceZombie(cte_t* slot, bool_t immediate)
{
    cte_t* ptr;
    word_t n, type;
    exception_t status;

    if(!(cap_get_capType(slot->cap) == cap_zombie_cap)) _assert_fail("cap_get_capType(slot->cap) == cap_zombie_cap", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 566, __FUNCTION__);
    ptr = (cte_t*)cap_zombie_cap_get_capZombiePtr(slot->cap);
    n = cap_zombie_cap_get_capZombieNumber(slot->cap);
    type = cap_zombie_cap_get_capZombieType(slot->cap);

    /* Haskell error: "reduceZombie: expected unremovable zombie" */
    if(!(n > 0)) _assert_fail("n > 0", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 572, __FUNCTION__);

    if (immediate) {
        cte_t* endSlot = &ptr[n - 1];

        status = cteDelete(endSlot, false);
        if (status != EXCEPTION_NONE) {
            return status;
        }

        switch (cap_get_capType(slot->cap)) {
        case cap_null_cap:
            break;

        case cap_zombie_cap: {
            cte_t* ptr2 =
                (cte_t*)cap_zombie_cap_get_capZombiePtr(slot->cap);

            if (ptr == ptr2 &&
                    cap_zombie_cap_get_capZombieNumber(slot->cap) == n &&
                    cap_zombie_cap_get_capZombieType(slot->cap) == type) {
                if(!(cap_get_capType(endSlot->cap) == cap_null_cap)) _assert_fail("cap_get_capType(endSlot->cap) == cap_null_cap", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 593, __FUNCTION__);
                /* We could call cdtUpdate here, but we know it is not necessary
                 * because a zombie is not ordered in the aaTree by its zombieNumber
                 * and so cdtUpdate will always be a noop. Skipping the call to cdtUpdate
                 * here is to make revoking large cnodes faster as this gets called
                 * for every slot in the cnode */
                slot->cap = cap_zombie_cap_set_capZombieNumber(slot->cap, n - 1);
            } else {
                /* Haskell error:
                 * "Expected new Zombie to be self-referential."
                 */
                if(!(ptr2 == slot && ptr != slot)) _assert_fail("ptr2 == slot && ptr != slot", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 604, __FUNCTION__);
            }
            break;
        }

        default:
            _fail("Expected recursion to result in Zombie.", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 610, __func__);
        }
    } else {
        /* Haskell error: "Cyclic zombie passed to unexposed reduceZombie" */
        if(!(ptr != slot)) _assert_fail("ptr != slot", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 614, __FUNCTION__);

        if (cap_get_capType(ptr->cap) == cap_zombie_cap) {
            /* Haskell error: "Moving self-referential Zombie aside." */
            if(!(ptr != ((cte_t *)(cap_zombie_cap_get_capZombiePtr(ptr->cap))))) _assert_fail("ptr != CTE_PTR(cap_zombie_cap_get_capZombiePtr(ptr->cap))", "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c", 618, __FUNCTION__);
        }

        capSwapForDelete(ptr, slot);
    }
    return EXCEPTION_NONE;
}

void
cteDeleteOne(cte_t* slot)
{
    uint32_t cap_type = cap_get_capType(slot->cap);
    if (cap_type != cap_null_cap) {
        bool_t final;
        finaliseCap_ret_t fc_ret __attribute__((unused));
        final = cdtIsFinal(slot);
        /** GHOSTUPD: "(gs_get_assn cteDeleteOne_'proc \<acute>ghost'state = (-1)
            \<or> gs_get_assn cteDeleteOne_'proc \<acute>ghost'state = \<acute>cap_type, id)" */
        fc_ret = finaliseCap(slot->cap, final, true);
        /* Haskell error: "cteDeleteOne: cap should be removable" */
        if(!(capRemovable(fc_ret.remainder, slot) && fc_ret.irq == irqInvalid)) _assert_fail("capRemovable(fc_ret.remainder, slot) && fc_ret.irq == irqInvalid",
 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c"
# 638 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c"
        ,
 639
# 638 "/home/kq/Sources/RefOS_x86/kernel/src/object/cnode.c"
        , __FUNCTION__)
                                        ;
        emptySlot(slot, irqInvalid);
    }
}

exception_t
cteRecycle(cte_t* slot)
{
    exception_t status;
    finaliseSlot_ret_t fc_ret;

    status = cteRevoke(slot);
    if (status != EXCEPTION_NONE) {
        return status;
    }

    fc_ret = finaliseSlot(slot, true);
    if (fc_ret.status != EXCEPTION_NONE) {
        return fc_ret.status;
    }

    if (cap_get_capType(slot->cap) != cap_null_cap) {
        cap_t new_cap;
        bool_t is_final;
        is_final = cdtIsFinal(slot);
        new_cap = recycleCap(is_final, slot->cap);
        cdtUpdate(slot, new_cap);
    }

    return EXCEPTION_NONE;
}

void
insertNewCap(cte_t *parent, cte_t *slot, cap_t cap)
{
    slot->cap = cap;
    cdtInsert(parent, slot);
}

void
setupReplyMaster(tcb_t *thread)
{
    cte_t *slot;

    slot = (((cte_t *)((unsigned int)(thread)&~((1ul<<(10))-1ul)))+(tcbReply));
    if (cap_get_capType(slot->cap) == cap_null_cap) {
        /* Haskell asserts that no reply caps exist for this thread here. This
         * cannot be translated. */
        slot->cap = cap_reply_cap_new(((unsigned int)(((void *)0))), true, ((unsigned int)(((void *)0))));
    }
}

exception_t
ensureEmptySlot(cte_t *slot)
{
    if (cap_get_capType(slot->cap) != cap_null_cap) {
        current_syscall_error.type = seL4_DeleteFirst;
        return EXCEPTION_SYSCALL_ERROR;
    }

    return EXCEPTION_NONE;
}

bool_t __attribute__((__pure__))
slotCapLongRunningDelete(cte_t *slot)
{
    if (cap_get_capType(slot->cap) == cap_null_cap) {
        return false;
    } else if (! cdtIsFinal(slot)) {
        return false;
    }
    switch (cap_get_capType(slot->cap)) {
    case cap_thread_cap:
    case cap_zombie_cap:
    case cap_cnode_cap:
        return true;
    default:
        return false;
    }
}

/* This implementation is specialised to the (current) limit
 * of one cap receive slot. */
cte_t *
getReceiveSlots(tcb_t *thread, word_t *buffer)
{
    cap_transfer_t ct;
    cptr_t cptr;
    lookupCap_ret_t luc_ret;
    lookupSlot_ret_t lus_ret;
    cte_t *slot;
    cap_t cnode;

    if (!buffer) {
        return ((void *)0);
    }

    ct = loadCapTransfer(buffer);
    cptr = ct.ctReceiveRoot;

    luc_ret = lookupCap(thread, cptr);
    if (luc_ret.status != EXCEPTION_NONE) {
        return ((void *)0);
    }
    cnode = luc_ret.cap;

    lus_ret = lookupTargetSlot(cnode, ct.ctReceiveIndex, ct.ctReceiveDepth);
    if (lus_ret.status != EXCEPTION_NONE) {
        return ((void *)0);
    }
    slot = lus_ret.slot;

    if (cap_get_capType(slot->cap) != cap_null_cap) {
        return ((void *)0);
    }

    return slot;
}

cap_transfer_t __attribute__((__pure__))
loadCapTransfer(word_t *buffer)
{
    const int offset = seL4_MsgMaxLength + ((1ul<<(seL4_MsgExtraCapBits))-1) + 2;
    return capTransferFromWords(buffer + offset);
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/asyncendpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/endpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c" 2

static inline tcb_queue_t __attribute__((__pure__))
ep_ptr_get_queue(endpoint_t *epptr)
{
    tcb_queue_t queue;

    queue.head = (tcb_t*)endpoint_ptr_get_epQueue_head(epptr);
    queue.end = (tcb_t*)endpoint_ptr_get_epQueue_tail(epptr);

    return queue;
}

static inline void
ep_ptr_set_queue(endpoint_t *epptr, tcb_queue_t queue)
{
    endpoint_ptr_set_epQueue_head(epptr, (word_t)queue.head);
    endpoint_ptr_set_epQueue_tail(epptr, (word_t)queue.end);
}

void
sendIPC(bool_t blocking, bool_t do_call, word_t badge,
        bool_t canGrant, tcb_t *thread, endpoint_t *epptr)
{
    switch (endpoint_ptr_get_state(epptr)) {
    case EPState_Idle:
    case EPState_Send:
        if (blocking) {
            tcb_queue_t queue;

            /* Set thread state to BlockedOnSend */
            thread_state_ptr_set_tsType(&thread->tcbState,
                                        ThreadState_BlockedOnSend);
            thread_state_ptr_set_blockingIPCEndpoint(
                &thread->tcbState, ((unsigned int)(epptr)));
            thread_state_ptr_set_blockingIPCBadge(
                &thread->tcbState, badge);
            thread_state_ptr_set_blockingIPCCanGrant(
                &thread->tcbState, canGrant);
            thread_state_ptr_set_blockingIPCIsCall(
                &thread->tcbState, do_call);

            scheduleTCB(thread);

            /* Place calling thread in endpoint queue */
            queue = ep_ptr_get_queue(epptr);
            queue = tcbEPAppend(thread, queue);
            endpoint_ptr_set_state(epptr, EPState_Send);
            ep_ptr_set_queue(epptr, queue);
        }
        break;

    case EPState_Recv: {
        tcb_queue_t queue;
        tcb_t *dest;
        bool_t diminish;

        /* Get the head of the endpoint queue. */
        queue = ep_ptr_get_queue(epptr);
        dest = queue.head;

        /* Haskell error "Receive endpoint queue must not be empty" */
        if(!(dest)) _assert_fail("dest", "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c", 81, __FUNCTION__);

        /* Dequeue the first TCB */
        queue = tcbEPDequeue(dest, queue);
        ep_ptr_set_queue(epptr, queue);

        if (!queue.head) {
            endpoint_ptr_set_state(epptr, EPState_Idle);
        }

        /* Do the transfer */
        diminish =
            thread_state_get_blockingIPCDiminishCaps(dest->tcbState);
        doIPCTransfer(thread, epptr, badge, canGrant, dest, diminish);

        setThreadState(dest, ThreadState_Running);
        attemptSwitchTo(dest);

        if (do_call ||
                fault_ptr_get_faultType(&thread->tcbFault) != fault_null_fault) {
            if (canGrant && !diminish) {
                setupCallerCap(thread, dest);
            } else {
                setThreadState(thread, ThreadState_Inactive);
            }
        }

        break;
    }
    }
}

void
receiveIPC(tcb_t *thread, cap_t cap)
{
    endpoint_t *epptr;
    bool_t diminish;
    async_endpoint_t *aepptr;

    /* Haskell error "receiveIPC: invalid cap" */
    if(!(cap_get_capType(cap) == cap_endpoint_cap)) _assert_fail("cap_get_capType(cap) == cap_endpoint_cap", "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c", 121, __FUNCTION__);

    epptr = ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(cap)));
    diminish = !cap_endpoint_cap_get_capCanSend(cap);

    /* Check for anything waiting in the async endpoint*/
    aepptr = thread->boundAsyncEndpoint;
    if (aepptr && async_endpoint_ptr_get_state(aepptr) == AEPState_Active) {
        completeAsyncIPC(aepptr, thread);
    } else {
        switch (endpoint_ptr_get_state(epptr)) {
        case EPState_Idle:
        case EPState_Recv: {
            tcb_queue_t queue;

            /* Set thread state to BlockedOnReceive */
            thread_state_ptr_set_tsType(&thread->tcbState,
                                        ThreadState_BlockedOnReceive);
            thread_state_ptr_set_blockingIPCEndpoint(
                &thread->tcbState, ((unsigned int)(epptr)));
            thread_state_ptr_set_blockingIPCDiminishCaps(
                &thread->tcbState, diminish);

            scheduleTCB(thread);

            /* Place calling thread in endpoint queue */
            queue = ep_ptr_get_queue(epptr);
            queue = tcbEPAppend(thread, queue);
            endpoint_ptr_set_state(epptr, EPState_Recv);
            ep_ptr_set_queue(epptr, queue);
            break;
        }

        case EPState_Send: {
            tcb_queue_t queue;
            tcb_t *sender;
            word_t badge;
            bool_t canGrant;
            bool_t do_call;

            /* Get the head of the endpoint queue. */
            queue = ep_ptr_get_queue(epptr);
            sender = queue.head;

            /* Haskell error "Send endpoint queue must not be empty" */
            if(!(sender)) _assert_fail("sender", "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c", 166, __FUNCTION__);

            /* Dequeue the first TCB */
            queue = tcbEPDequeue(sender, queue);
            ep_ptr_set_queue(epptr, queue);

            if (!queue.head) {
                endpoint_ptr_set_state(epptr, EPState_Idle);
            }

            /* Get sender IPC details */
            badge = thread_state_ptr_get_blockingIPCBadge(&sender->tcbState);
            canGrant =
                thread_state_ptr_get_blockingIPCCanGrant(&sender->tcbState);

            /* Do the transfer */
            doIPCTransfer(sender, epptr, badge,
                          canGrant, thread, diminish);

            do_call = thread_state_ptr_get_blockingIPCIsCall(&sender->tcbState);

            if (do_call ||
                    fault_get_faultType(sender->tcbFault) != fault_null_fault) {
                if (canGrant && !diminish) {
                    setupCallerCap(sender, thread);
                } else {
                    setThreadState(sender, ThreadState_Inactive);
                }
            } else {
                setThreadState(sender, ThreadState_Running);
                switchIfRequiredTo(sender);
            }

            break;
        }
        }
    }
}

void
replyFromKernel_error(tcb_t *thread)
{
    unsigned int len;
    word_t *ipcBuffer;

    ipcBuffer = lookupIPCBuffer(true, thread);
    setRegister(thread, badgeRegister, 0);
    len = setMRs_syscall_error(thread, ipcBuffer);
    setRegister(thread, msgInfoRegister, wordFromMessageInfo(
                    message_info_new(current_syscall_error.type, 0, 0, len)));
}

void
replyFromKernel_success_empty(tcb_t *thread)
{
    setRegister(thread, badgeRegister, 0);
    setRegister(thread, msgInfoRegister, wordFromMessageInfo(
                    message_info_new(0, 0, 0, 0)));
}

void
ipcCancel(tcb_t *tptr)
{
    thread_state_t *state = &tptr->tcbState;

    switch (thread_state_ptr_get_tsType(state)) {
    case ThreadState_BlockedOnSend:
    case ThreadState_BlockedOnReceive: {
        /* blockedIPCCancel state */
        endpoint_t *epptr;
        tcb_queue_t queue;

        epptr = ((endpoint_t *)(thread_state_ptr_get_blockingIPCEndpoint(state)));

        /* Haskell error "blockedIPCCancel: endpoint must not be idle" */
        if(!(endpoint_ptr_get_state(epptr) != EPState_Idle)) _assert_fail("endpoint_ptr_get_state(epptr) != EPState_Idle", "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c", 241, __FUNCTION__);

        /* Dequeue TCB */
        queue = ep_ptr_get_queue(epptr);
        queue = tcbEPDequeue(tptr, queue);
        ep_ptr_set_queue(epptr, queue);

        if (!queue.head) {
            endpoint_ptr_set_state(epptr, EPState_Idle);
        }

        setThreadState(tptr, ThreadState_Inactive);
        break;
    }

    case ThreadState_BlockedOnAsyncEvent:
        asyncIPCCancel(tptr,
                       ((async_endpoint_t *)(thread_state_ptr_get_blockingIPCEndpoint(state))));
        break;

    case ThreadState_BlockedOnReply: {
        cte_t *slot, *callerCap;

        fault_null_fault_ptr_new(&tptr->tcbFault);

        /* Get the reply cap slot */
        slot = (((cte_t *)((unsigned int)(tptr)&~((1ul<<(10))-1ul)))+(tcbReply));

        callerCap = ((cte_t *)(cap_reply_cap_get_capCallerSlot(slot->cap)));
        if (callerCap) {
            finaliseCap(callerCap->cap, true, true);
            callerCap->cap = cap_null_cap_new();
        }
        cap_reply_cap_ptr_set_capCallerSlot(&slot->cap, ((unsigned int)(((void *)0))));

        break;
    }
    }
}

void
epCancelAll(endpoint_t *epptr)
{
    switch (endpoint_ptr_get_state(epptr)) {
    case EPState_Idle:
        break;

    default: {
        tcb_t *thread = ((tcb_t *)(endpoint_ptr_get_epQueue_head(epptr)));

        /* Make endpoint idle */
        endpoint_ptr_set_state(epptr, EPState_Idle);
        endpoint_ptr_set_epQueue_head(epptr, 0);
        endpoint_ptr_set_epQueue_tail(epptr, 0);

        /* Set all blocked threads to restart */
        for (; thread; thread = thread->tcbEPNext) {
            setThreadState (thread, ThreadState_Restart);
            tcbSchedEnqueue(thread);
        }

        rescheduleRequired();
        break;
    }
    }
}

void
epCancelBadgedSends(endpoint_t *epptr, word_t badge)
{
    switch (endpoint_ptr_get_state(epptr)) {
    case EPState_Idle:
    case EPState_Recv:
        break;

    case EPState_Send: {
        tcb_t *thread, *next;
        tcb_queue_t queue = ep_ptr_get_queue(epptr);

        /* this is a de-optimisation for verification
         * reasons. it allows the contents of the endpoint
         * queue to be ignored during the for loop. */
        endpoint_ptr_set_state(epptr, EPState_Idle);
        endpoint_ptr_set_epQueue_head(epptr, 0);
        endpoint_ptr_set_epQueue_tail(epptr, 0);

        for (thread = queue.head; thread; thread = next) {
            word_t b = thread_state_ptr_get_blockingIPCBadge(
                           &thread->tcbState);
            next = thread->tcbEPNext;
            if (b == badge) {
                setThreadState(thread, ThreadState_Restart);
                tcbSchedEnqueue(thread);
                queue = tcbEPDequeue(thread, queue);
            }
        }
        ep_ptr_set_queue(epptr, queue);

        if (queue.head) {
            endpoint_ptr_set_state(epptr, EPState_Send);
        }

        rescheduleRequired();

        break;
    }

    default:
        _fail("invalid EP state", "/home/kq/Sources/RefOS_x86/kernel/src/object/endpoint.c", 349, __func__);
    }
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2
# 1 "./api/invocation.h" 1
/* @LICENSE(OKL_CORE) */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/asyncendpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c" 2

exception_t
decodeIRQControlInvocation(word_t label, unsigned int length,
                           cte_t *srcSlot, extra_caps_t extraCaps,
                           word_t *buffer)
{
    if (label == IRQIssueIRQHandler) {
        word_t index, depth, irq_w;
        irq_t irq;
        cte_t *destSlot;
        cap_t cnodeCap;
        lookupSlot_ret_t lu_ret;
        exception_t status;

        if (length < 3 || extraCaps.excaprefs[0] == ((void *)0)) {
            current_syscall_error.type = seL4_TruncatedMessage;
            return EXCEPTION_SYSCALL_ERROR;
        }
        irq_w = getSyscallArg(0, buffer);
        irq = (irq_t) irq_w;
        index = getSyscallArg(1, buffer);
        depth = getSyscallArg(2, buffer);

        cnodeCap = extraCaps.excaprefs[0]->cap;

        if (irq_w > maxIRQ) {
            current_syscall_error.type = seL4_RangeError;
            current_syscall_error.rangeErrorMin = 0;
            current_syscall_error.rangeErrorMax = maxIRQ;
            return EXCEPTION_SYSCALL_ERROR;
        }

        if (isIRQActive(irq)) {
            current_syscall_error.type = seL4_RevokeFirst;
            return EXCEPTION_SYSCALL_ERROR;
        }

        lu_ret = lookupTargetSlot(cnodeCap, index, depth);
        if (lu_ret.status != EXCEPTION_NONE) {
            return lu_ret.status;
        }
        destSlot = lu_ret.slot;

        status = ensureEmptySlot(destSlot);
        if (status != EXCEPTION_NONE) {
            return status;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeIRQControl(irq, destSlot, srcSlot);
    } else if (label == IRQInterruptControl) {
        return Arch_decodeInterruptControl(length, extraCaps);
    } else {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 77, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IRQControl: Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }
}

exception_t
invokeIRQControl(irq_t irq, cte_t *handlerSlot, cte_t *controlSlot)
{
    setIRQState(IRQNotifyAEP, irq);
    cteInsert(cap_irq_handler_cap_new(irq), controlSlot, handlerSlot);

    return EXCEPTION_NONE;
}

exception_t
decodeIRQHandlerInvocation(word_t label, unsigned int length, irq_t irq,
                           extra_caps_t extraCaps, word_t *buffer)
{
    switch (label) {
    case IRQAckIRQ:
        setThreadState(ksCurThread, ThreadState_Restart);
        invokeIRQHandler_AckIRQ(irq);
        return EXCEPTION_NONE;

    case IRQSetIRQHandler: {
        cap_t aepCap;
        cte_t *slot;

        if (extraCaps.excaprefs[0] == ((void *)0)) {
            current_syscall_error.type = seL4_TruncatedMessage;
            return EXCEPTION_SYSCALL_ERROR;
        }
        aepCap = extraCaps.excaprefs[0]->cap;
        slot = extraCaps.excaprefs[0];

        if (cap_get_capType(aepCap) != cap_async_endpoint_cap ||
                !cap_async_endpoint_cap_get_capAEPCanSend(aepCap)) {
            if (cap_get_capType(aepCap) != cap_async_endpoint_cap) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 116, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IRQSetHandler: provided cap is not an async endpoint capability."); kprintf(">>" "\033[0m" "\n"); } while (0);
            } else {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 118, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IRQSetHandler: caller does not have send rights on the endpoint."); kprintf(">>" "\033[0m" "\n"); } while (0);
            }
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        invokeIRQHandler_SetIRQHandler(irq, aepCap, slot);
        return EXCEPTION_NONE;
    }

    case IRQClearIRQHandler:
        setThreadState(ksCurThread, ThreadState_Restart);
        invokeIRQHandler_ClearIRQHandler(irq);
        return EXCEPTION_NONE;
    case IRQSetMode: {
        bool_t trig, pol;

        if (length < 2) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 138, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IRQSetMode: Not enough arguments", length); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_TruncatedMessage;
            return EXCEPTION_SYSCALL_ERROR;
        }
        trig = getSyscallArg(0, buffer);
        pol = getSyscallArg(1, buffer);

        setThreadState(ksCurThread, ThreadState_Restart);
        invokeIRQHandler_SetMode(irq, !!trig, !!pol);
        return EXCEPTION_NONE;
    }

    default:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 151, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IRQHandler: Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }
}

void
invokeIRQHandler_AckIRQ(irq_t irq)
{
    maskInterrupt(false, irq);
}

void invokeIRQHandler_SetMode(irq_t irq, bool_t levelTrigger, bool_t polarityLow)
{
    setInterruptMode(irq, levelTrigger, polarityLow);
}

void
invokeIRQHandler_SetIRQHandler(irq_t irq, cap_t cap, cte_t *slot)
{
    cte_t *irqSlot;

    irqSlot = intStateIRQNode + irq;
    /** GHOSTUPD: "(True, gs_set_assn cteDeleteOne_'proc (-1))" */
    cteDeleteOne(irqSlot);
    cteInsert(cap, slot, irqSlot);
}

void
invokeIRQHandler_ClearIRQHandler(irq_t irq)
{
    cte_t *irqSlot;

    irqSlot = intStateIRQNode + irq;
    /** GHOSTUPD: "(True, gs_set_assn cteDeleteOne_'proc (-1))" */
    cteDeleteOne(irqSlot);
}

void
deletingIRQHandler(irq_t irq)
{
    cte_t *slot;

    do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 194, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("IRQ %d", irq); kprintf(">>" "\033[0m" "\n"); } while (0);
    slot = intStateIRQNode + irq;
    /** GHOSTUPD: "(True, gs_set_assn cteDeleteOne_'proc (ucast cap_async_endpoint_cap))" */
    cteDeleteOne(slot);
}

void
deletedIRQHandler(irq_t irq)
{
    setIRQState(IRQInactive, irq);
}



void
handleInterrupt(irq_t irq)
{
    switch (intStateIRQTable[irq]) {
    case IRQNotifyAEP: {
        cap_t cap;

        cap = intStateIRQNode[irq].cap;

        if (cap_get_capType(cap) == cap_async_endpoint_cap &&
                cap_async_endpoint_cap_get_capAEPCanSend(cap)) {
            sendAsyncIPC(((async_endpoint_t *)(cap_async_endpoint_cap_get_capAEPPtr(cap))),
                         cap_async_endpoint_cap_get_capAEPBadge(cap));
        } else {

            kprintf("Undelivered IRQ: %d\n", (int)irq);

        }
        maskInterrupt(true, irq);
        break;
    }

    case IRQTimer:
        timerTick();
        resetTimer();
        break;

    case IRQReserved:
        handleReservedIRQ(irq);
        break;

    case IRQInactive:
        /*
         * This case shouldn't happen anyway unless the hardware or
         * platform code is broken. Hopefully masking it again should make
         * the interrupt go away.
         */
        maskInterrupt(true, irq);

        kprintf("Received disabled IRQ: %d\n", (int)irq);

        break;

    default:
        /* No corresponding haskell error */
        _fail("Invalid IRQ state", "/home/kq/Sources/RefOS_x86/kernel/src/object/interrupt.c", 253, __func__);
    }

    ackInterrupt(irq);
}

bool_t
isIRQActive(irq_t irq)
{
    return intStateIRQTable[irq] != IRQInactive;
}

void
setIRQState(irq_state_t irqState, irq_t irq)
{
    intStateIRQTable[irq] = irqState;
    maskInterrupt(irqState == IRQInactive, irq);
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/asyncendpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/endpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/untyped.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 26 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 27 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 28 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 29 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 30 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 31 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/string.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 32 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c" 2

word_t getObjectSize(word_t t, word_t userObjSize)
{
    if (t >= seL4_NonArchObjectTypeCount) {
        return Arch_getObjectSize(t);
    } else {
        switch (t) {
        case seL4_TCBObject:
            return 10;
        case seL4_EndpointObject:
            return 4;
        case seL4_AsyncEndpointObject:
            return 4;
        case seL4_CapTableObject:
            return 4 + userObjSize;
        case seL4_UntypedObject:
            return userObjSize;
        default:
            _fail("Invalid object type", "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c", 50, __func__);
            return 0;
        }
    }
}

deriveCap_ret_t
deriveCap(cte_t *slot, cap_t cap)
{
    deriveCap_ret_t ret;

    if (isArchCap(cap)) {
        return Arch_deriveCap(slot, cap);
    }

    switch (cap_get_capType(cap)) {
    case cap_zombie_cap:
        ret.status = EXCEPTION_NONE;
        ret.cap = cap_null_cap_new();
        break;

    case cap_irq_control_cap:
        ret.status = EXCEPTION_NONE;
        ret.cap = cap_null_cap_new();
        break;

    case cap_reply_cap:
        ret.status = EXCEPTION_NONE;
        ret.cap = cap_null_cap_new();
        break;

    default:
        ret.status = EXCEPTION_NONE;
        ret.cap = cap;
    }

    return ret;
}

finaliseCap_ret_t
finaliseCap(cap_t cap, bool_t final, bool_t exposed)
{
    finaliseCap_ret_t fc_ret;

    if (isArchCap(cap)) {
        fc_ret.remainder = Arch_finaliseCap(cap, final);
        fc_ret.irq = irqInvalid;
        return fc_ret;
    }

    switch (cap_get_capType(cap)) {
    case cap_endpoint_cap:
        if (final) {
            epCancelAll(((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(cap))));
        }

        fc_ret.remainder = cap_null_cap_new();
        fc_ret.irq = irqInvalid;
        return fc_ret;

    case cap_async_endpoint_cap:
        if (final) {
            async_endpoint_t *aep = ((async_endpoint_t *)(cap_async_endpoint_cap_get_capAEPPtr(cap)));
            tcb_t *boundTCB = (tcb_t*)async_endpoint_ptr_get_aepBoundTCB(aep);;

            if (boundTCB) {
                unbindAsyncEndpoint(boundTCB);
            }

            aepCancelAll(aep);
        }
        fc_ret.remainder = cap_null_cap_new();
        fc_ret.irq = irqInvalid;
        return fc_ret;

    case cap_reply_cap: {
        tcb_t *callee;
        cte_t *replySlot;
        callee = ((tcb_t *)(cap_reply_cap_get_capTCBPtr(cap)));
        replySlot = (((cte_t *)((unsigned int)(callee)&~((1ul<<(10))-1ul)))+(tcbReply));
        /* Remove the reference to us */
        cap_reply_cap_ptr_set_capCallerSlot(&replySlot->cap, ((unsigned int)(((void *)0))));
        fc_ret.remainder = cap_null_cap_new();
        fc_ret.irq = irqInvalid;
        return fc_ret;
    }
    case cap_null_cap:
    case cap_domain_cap:
        fc_ret.remainder = cap_null_cap_new();
        fc_ret.irq = irqInvalid;
        return fc_ret;
    }

    if (exposed) {
        _fail("finaliseCap: failed to finalise immediately.", "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c", 144, __func__);
    }

    switch (cap_get_capType(cap)) {
    case cap_cnode_cap: {
        if (final) {
            fc_ret.remainder =
                Zombie_new(
                    1 << cap_cnode_cap_get_capCNodeRadix(cap),
                    cap_cnode_cap_get_capCNodeRadix(cap),
                    cap_cnode_cap_get_capCNodePtr(cap)
                );
            fc_ret.irq = irqInvalid;
            return fc_ret;
        }
        break;
    }

    case cap_thread_cap: {
        if (final) {
            tcb_t *tcb;
            cte_t *cte_ptr;
            cte_t *replySlot;

            tcb = ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap)));
            cte_ptr = (((cte_t *)((unsigned int)(tcb)&~((1ul<<(10))-1ul)))+(tcbCTable));
            unbindAsyncEndpoint(tcb);
            suspend(tcb);
            replySlot = (((cte_t *)((unsigned int)(tcb)&~((1ul<<(10))-1ul)))+(tcbReply));
            if (cap_get_capType(replySlot->cap) == cap_reply_cap) {
                if(!(cap_reply_cap_get_capTCBPtr(replySlot->cap) == 0)) _assert_fail("cap_reply_cap_get_capTCBPtr(replySlot->cap) == 0", "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c", 174, __FUNCTION__);
                replySlot->cap = cap_null_cap_new();
            }
            Arch_prepareThreadDelete(tcb);
            fc_ret.remainder =
                Zombie_new(
                    tcbArchCNodeEntries,
                    (1ul<<(5)),
                    ((unsigned int)(cte_ptr))
                );
            fc_ret.irq = irqInvalid;
            return fc_ret;
        }
        break;
    }

    case cap_zombie_cap:
        fc_ret.remainder = cap;
        fc_ret.irq = irqInvalid;
        return fc_ret;

    case cap_irq_handler_cap:
        if (final) {
            irq_t irq = cap_irq_handler_cap_get_capIRQ(cap);

            deletingIRQHandler(irq);

            fc_ret.remainder = cap_null_cap_new();
            fc_ret.irq = irq;
            return fc_ret;
        }
        break;
    }

    fc_ret.remainder = cap_null_cap_new();
    fc_ret.irq = irqInvalid;
    return fc_ret;
}

cap_t
recycleCap(bool_t is_final, cap_t cap)
{
    if (isArchCap(cap)) {
        return Arch_recycleCap(is_final, cap);
    }

    switch (cap_get_capType(cap)) {
    case cap_null_cap:
        _fail("recycleCap: can't reconstruct Null", "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c", 222, __func__);
        break;
    case cap_domain_cap:
        return cap;
    case cap_cnode_cap:
        return cap;
    case cap_thread_cap:
        return cap;
    case cap_zombie_cap: {
        word_t type;

        type = cap_zombie_cap_get_capZombieType(cap);
        if (type == (1ul<<(5))) {
            tcb_t *tcb;
            _thread_state_t ts __attribute__((unused));

            tcb = ((tcb_t *)(cap_zombie_cap_get_capZombiePtr(cap) + (1 << (4 + 4))))
                                       ;
            ts = thread_state_get_tsType(tcb->tcbState);
            /* Haskell error:
             * "Zombie cap should point at inactive thread" */
            if(!(ts == ThreadState_Inactive || ts != ThreadState_IdleThreadState)) _assert_fail("ts == ThreadState_Inactive || ts != ThreadState_IdleThreadState",
 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c"
# 243 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c"
            ,
 244
# 243 "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c"
            , __FUNCTION__)
                                                     ;
            /* Haskell error:
             * "Zombie cap should not point at queued thread" */
            if(!(!thread_state_get_tcbQueued(tcb->tcbState))) _assert_fail("!thread_state_get_tcbQueued(tcb->tcbState)", "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c", 247, __FUNCTION__);
            /* Haskell error:
             * "Zombie cap should not point at bound thread" */
            if(!(tcb->boundAsyncEndpoint == ((void *)0))) _assert_fail("tcb->boundAsyncEndpoint == NULL", "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c", 250, __FUNCTION__);

            /* makeObject doesn't exist in C, objects are initialised by
             * zeroing. The effect of recycle in Haskell is to reinitialise
             * the TCB, with the exception of the TCB CTEs.  I achieve this
             * here by zeroing the TCB part of the structure, while leaving
             * the CNode alone. */
            memzero(tcb, sizeof (tcb_t));
            Arch_initContext(&tcb->tcbArch.tcbContext);
            tcb->tcbTimeSlice = 5;
            tcb->tcbDomain = ksCurDomain;

            return cap_thread_cap_new(((unsigned int)(tcb)));
        } else {
            return cap_cnode_cap_new(type, 0, 0,
                                     cap_zombie_cap_get_capZombiePtr(cap));
        }
    }
    case cap_endpoint_cap: {
        word_t badge = cap_endpoint_cap_get_capEPBadge(cap);
        if (badge) {
            endpoint_t* ep = (endpoint_t*)
                             cap_endpoint_cap_get_capEPPtr(cap);
            epCancelBadgedSends(ep, badge);
        }
        return cap;
    }
    default:
        return cap;
    }
}

bool_t __attribute__((__const__))
hasRecycleRights(cap_t cap)
{
    switch (cap_get_capType(cap)) {
    case cap_null_cap:
    case cap_domain_cap:
        return false;

    case cap_endpoint_cap:
        return cap_endpoint_cap_get_capCanSend(cap) &&
               cap_endpoint_cap_get_capCanReceive(cap) &&
               cap_endpoint_cap_get_capCanGrant(cap);

    case cap_async_endpoint_cap:
        return cap_async_endpoint_cap_get_capAEPCanSend(cap) &&
               cap_async_endpoint_cap_get_capAEPCanReceive(cap);

    default:
        if (isArchCap(cap)) {
            return Arch_hasRecycleRights(cap);
        } else {
            return true;
        }
    }
}

bool_t __attribute__((__const__))
sameRegionAs(cap_t cap_a, cap_t cap_b)
{
    switch (cap_get_capType(cap_a)) {
    case cap_untyped_cap: {
        word_t aBase, bBase, aTop, bTop;

        aBase = (word_t)((word_t *)(cap_untyped_cap_get_capPtr(cap_a)));
        bBase = (word_t)cap_get_capPtr(cap_b);

        aTop = aBase + ((1ul<<(cap_untyped_cap_get_capBlockSize(cap_a)))-1ul);
        bTop = bBase + ((1ul<<(cap_get_capSizeBits(cap_b)))-1ul);

        return ((bBase != 0) && (aBase <= bBase) &&
                (bTop <= aTop) && (bBase <= bTop));
    }

    case cap_endpoint_cap:
        if (cap_get_capType(cap_b) == cap_endpoint_cap) {
            return cap_endpoint_cap_get_capEPPtr(cap_a) ==
                   cap_endpoint_cap_get_capEPPtr(cap_b);
        }
        break;

    case cap_async_endpoint_cap:
        if (cap_get_capType(cap_b) == cap_async_endpoint_cap) {
            return cap_async_endpoint_cap_get_capAEPPtr(cap_a) ==
                   cap_async_endpoint_cap_get_capAEPPtr(cap_b);
        }
        break;

    case cap_cnode_cap:
        if (cap_get_capType(cap_b) == cap_cnode_cap) {
            return (cap_cnode_cap_get_capCNodePtr(cap_a) ==
                    cap_cnode_cap_get_capCNodePtr(cap_b)) &&
                   (cap_cnode_cap_get_capCNodeRadix(cap_a) ==
                    cap_cnode_cap_get_capCNodeRadix(cap_b));
        }
        break;

    case cap_thread_cap:
        if (cap_get_capType(cap_b) == cap_thread_cap) {
            return cap_thread_cap_get_capTCBPtr(cap_a) ==
                   cap_thread_cap_get_capTCBPtr(cap_b);
        }
        break;

    case cap_reply_cap:
        if (cap_get_capType(cap_b) == cap_reply_cap) {
            return cap_reply_cap_get_capTCBPtr(cap_a) ==
                   cap_reply_cap_get_capTCBPtr(cap_b);
        }
        break;

    case cap_domain_cap:
        if (cap_get_capType(cap_b) == cap_domain_cap) {
            return true;
        }
        break;

    case cap_irq_control_cap:
        if (cap_get_capType(cap_b) == cap_irq_control_cap ||
                cap_get_capType(cap_b) == cap_irq_handler_cap) {
            return true;
        }
        break;

    case cap_irq_handler_cap:
        if (cap_get_capType(cap_b) == cap_irq_handler_cap) {
            return (irq_t)cap_irq_handler_cap_get_capIRQ(cap_a) ==
                   (irq_t)cap_irq_handler_cap_get_capIRQ(cap_b);
        }
        break;

    default:
        if (isArchCap(cap_a) &&
                isArchCap(cap_b)) {
            return Arch_sameRegionAs(cap_a, cap_b);
        }
        break;
    }

    return false;
}

bool_t __attribute__((__const__))
sameObjectAs(cap_t cap_a, cap_t cap_b)
{
    if (cap_get_capType(cap_a) == cap_untyped_cap) {
        return false;
    }
    if (cap_get_capType(cap_a) == cap_irq_control_cap &&
            cap_get_capType(cap_b) == cap_irq_handler_cap) {
        return false;
    }
    if (isArchCap(cap_a) && isArchCap(cap_b)) {
        return Arch_sameObjectAs(cap_a, cap_b);
    }
    return sameRegionAs(cap_a, cap_b);
}

cap_t __attribute__((__const__))
updateCapData(bool_t preserve, word_t newData, cap_t cap)
{
    if (isArchCap(cap)) {
        return Arch_updateCapData(preserve, newData, cap);
    }

    switch (cap_get_capType(cap)) {
    case cap_endpoint_cap:
        if (!preserve && cap_endpoint_cap_get_capEPBadge(cap) == 0) {
            return cap_endpoint_cap_set_capEPBadge(cap, newData);
        } else {
            return cap_null_cap_new();
        }

    case cap_async_endpoint_cap:
        if (!preserve && cap_async_endpoint_cap_get_capAEPBadge(cap) == 0) {
            return cap_async_endpoint_cap_set_capAEPBadge(cap, newData);
        } else {
            return cap_null_cap_new();
        }

    case cap_cnode_cap: {
        word_t guard, guardSize;
        cnode_capdata_t w = { .words = { newData } };

        guardSize = cnode_capdata_get_guardSize(w);

        if (guardSize + cap_cnode_cap_get_capCNodeRadix(cap) > 32) {
            return cap_null_cap_new();
        } else {
            cap_t new_cap;

            guard = cnode_capdata_get_guard(w) & ((1ul<<(guardSize))-1ul);
            new_cap = cap_cnode_cap_set_capCNodeGuard(cap, guard);
            new_cap = cap_cnode_cap_set_capCNodeGuardSize(new_cap,
                                                          guardSize);

            return new_cap;
        }
    }

    default:
        return cap;
    }
}

cap_t __attribute__((__const__))
maskCapRights(cap_rights_t cap_rights, cap_t cap)
{
    if (isArchCap(cap)) {
        return Arch_maskCapRights(cap_rights, cap);
    }

    switch (cap_get_capType(cap)) {
    case cap_null_cap:
    case cap_domain_cap:
    case cap_cnode_cap:
    case cap_untyped_cap:
    case cap_reply_cap:
    case cap_irq_control_cap:
    case cap_irq_handler_cap:
    case cap_zombie_cap:
    case cap_thread_cap:
        return cap;

    case cap_endpoint_cap: {
        cap_t new_cap;

        new_cap = cap_endpoint_cap_set_capCanSend(
                      cap, cap_endpoint_cap_get_capCanSend(cap) &
                      cap_rights_get_capAllowWrite(cap_rights));
        new_cap = cap_endpoint_cap_set_capCanReceive(
                      new_cap, cap_endpoint_cap_get_capCanReceive(cap) &
                      cap_rights_get_capAllowRead(cap_rights));
        new_cap = cap_endpoint_cap_set_capCanGrant(
                      new_cap, cap_endpoint_cap_get_capCanGrant(cap) &
                      cap_rights_get_capAllowGrant(cap_rights));

        return new_cap;
    }

    case cap_async_endpoint_cap: {
        cap_t new_cap;

        new_cap = cap_async_endpoint_cap_set_capAEPCanSend(
                      cap, cap_async_endpoint_cap_get_capAEPCanSend(cap) &
                      cap_rights_get_capAllowWrite(cap_rights));
        new_cap = cap_async_endpoint_cap_set_capAEPCanReceive(new_cap,
                                                              cap_async_endpoint_cap_get_capAEPCanReceive(cap) &
                                                              cap_rights_get_capAllowRead(cap_rights));

        return new_cap;
    }

    default:
        _fail("Invalid cap type", "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c", 505, __func__); /* Sentinel for invalid enums */
    }
}

cap_t
createObject(object_t t, void *regionBase, int userSize, bool_t deviceMemory)
{
    /* Handle architecture-specific objects. */
    if (t >= (object_t) seL4_NonArchObjectTypeCount) {
        return Arch_createObject(t, regionBase, userSize, deviceMemory);
    }

    /* Create objects. */
    switch ((api_object_t)t) {
    case seL4_TCBObject: {
        tcb_t *tcb;
        memzero(regionBase, 1UL << 10);
        tcb = ((tcb_t *)((word_t)regionBase + (1 << (4 + 4))));
        /** AUXUPD: "(True, ptr_retyps 5
          (Ptr ((ptr_val \<acute>tcb) - 0x100) :: cte_C ptr)
            o (ptr_retyp \<acute>tcb))" */

        /* Setup non-zero parts of the TCB. */

        Arch_initContext(&tcb->tcbArch.tcbContext);
        tcb->tcbTimeSlice = 5;
        tcb->tcbDomain = ksCurDomain;


        strlcpy(tcb->tcbName, "child of: '", ((1ul<<((4 + 4))) - sizeof(tcb_t)));
        strlcat(tcb->tcbName, ksCurThread->tcbName, ((1ul<<((4 + 4))) - sizeof(tcb_t)));
        strlcat(tcb->tcbName, "'", ((1ul<<((4 + 4))) - sizeof(tcb_t)));


        return cap_thread_cap_new(((unsigned int)(tcb)));
    }

    case seL4_EndpointObject:
        memzero(regionBase, 1UL << 4);
        /** AUXUPD: "(True, ptr_retyp
          (Ptr (ptr_val \<acute>regionBase) :: endpoint_C ptr))" */
        return cap_endpoint_cap_new(0, true, true, true,
                                    ((unsigned int)(regionBase)));

    case seL4_AsyncEndpointObject:
        memzero(regionBase, 1UL << 4);
        /** AUXUPD: "(True, ptr_retyp
              (Ptr (ptr_val \<acute>regionBase) :: async_endpoint_C ptr))" */
        return cap_async_endpoint_cap_new(0, true, true,
                                          ((unsigned int)(regionBase)));

    case seL4_CapTableObject:
        memzero(regionBase, 1UL << (4 + userSize));
        /** AUXUPD: "(True, ptr_retyps (2 ^ (unat \<acute>userSize))
          (Ptr (ptr_val \<acute>regionBase) :: cte_C ptr))" */
        /** GHOSTUPD: "(True, gs_new_cnodes (unat \<acute>userSize)
                                (ptr_val \<acute>regionBase)
                                (4 + unat \<acute>userSize))" */
        return cap_cnode_cap_new(userSize, 0, 0, ((unsigned int)(regionBase)));

    case seL4_UntypedObject:
        /*
         * No objects need to be created; instead, just insert caps into
         * the destination slots.
         */
        return cap_untyped_cap_new(deviceMemory, userSize, ((unsigned int)(regionBase)));

    default:
        _fail("Invalid object type", "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c", 573, __func__);
    }
}

void
createNewObjects(object_t t, cte_t *parent, slot_range_t slots,
                 void *regionBase, unsigned int userSize, bool_t deviceMemory)
{
    word_t objectSize;
    void *nextFreeArea;
    unsigned int i;
    word_t totalObjectSize __attribute__((unused));

    /* ghost check that we're visiting less bytes than the max object size */
    objectSize = getObjectSize(t, userSize);
    totalObjectSize = slots.length << objectSize;
    /** GHOSTUPD: "(gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state = 0
        \<or> \<acute>totalObjectSize <= gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state, id)" */

    /* Create the objects. */
    nextFreeArea = regionBase;
    for (i = 0; i < slots.length; i++) {
        /* Create the object. */
        /** AUXUPD: "(True, typ_clear_region (ptr_val \<acute> nextFreeArea + ((\<acute> i) << unat (\<acute> objectSize))) (unat (\<acute> objectSize)))" */
        cap_t cap = createObject(t, (void *)((word_t)nextFreeArea + (i << objectSize)), userSize, deviceMemory);

        /* Insert the cap into the user's cspace. */
        insertNewCap(parent, &slots.cnode[slots.offset + i], cap);

        /* Move along to the next region of memory. been merged into a formula of i */
    }
}

exception_t
decodeInvocation(word_t label, unsigned int length,
                 cptr_t capIndex, cte_t *slot, cap_t cap,
                 extra_caps_t extraCaps, bool_t block, bool_t call,
                 word_t *buffer)
{
    if (isArchCap(cap)) {
        return Arch_decodeInvocation(label, length, capIndex,
                                     slot, cap, extraCaps, buffer);
    }

    switch (cap_get_capType(cap)) {
    case cap_null_cap:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 619, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Attempted to invoke a null cap #%u.", capIndex); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;

    case cap_zombie_cap:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 625, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Attempted to invoke a zombie cap #%u.", capIndex); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;

    case cap_endpoint_cap:
        if (__builtin_expect(!!(!cap_endpoint_cap_get_capCanSend(cap)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 633, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Attempted to invoke a read-only endpoint cap #%u.", capIndex); kprintf(">>" "\033[0m" "\n"); } while (0)
                               ;
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return performInvocation_Endpoint(
                   ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(cap))),
                   cap_endpoint_cap_get_capEPBadge(cap),
                   cap_endpoint_cap_get_capCanGrant(cap), block, call);

    case cap_async_endpoint_cap: {
        if (__builtin_expect(!!(!cap_async_endpoint_cap_get_capAEPCanSend(cap)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 648, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Attempted to invoke a read-only async-endpoint cap #%u.", capIndex); kprintf(">>" "\033[0m" "\n"); } while (0)
                               ;
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return performInvocation_AsyncEndpoint(
                   ((async_endpoint_t *)(cap_async_endpoint_cap_get_capAEPPtr(cap))),
                   cap_async_endpoint_cap_get_capAEPBadge(cap));
    }

    case cap_reply_cap:
        if (__builtin_expect(!!(cap_reply_cap_get_capReplyMaster(cap)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 663, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Attempted to invoke an invalid reply cap #%u.", capIndex); kprintf(">>" "\033[0m" "\n"); } while (0)
                               ;
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return performInvocation_Reply(
                   ((tcb_t *)(cap_reply_cap_get_capTCBPtr(cap))), slot);

    case cap_thread_cap:
        return decodeTCBInvocation(label, length, cap,
                                   slot, extraCaps, call, buffer);

    case cap_domain_cap:
        return decodeDomainInvocation(label, length, extraCaps, buffer);

    case cap_cnode_cap:
        return decodeCNodeInvocation(label, length, cap, extraCaps, buffer);

    case cap_untyped_cap:
        return decodeUntypedInvocation(label, length, slot, cap, extraCaps,
                                       call, buffer);

    case cap_irq_control_cap:
        return decodeIRQControlInvocation(label, length, slot,
                                          extraCaps, buffer);

    case cap_irq_handler_cap:
        return decodeIRQHandlerInvocation(label, length,
                                          cap_irq_handler_cap_get_capIRQ(cap), extraCaps, buffer);

    default:
        _fail("Invalid cap type", "/home/kq/Sources/RefOS_x86/kernel/src/object/objecttype.c", 696, __func__);
    }
}

exception_t
performInvocation_Endpoint(endpoint_t *ep, word_t badge,
                           bool_t canGrant, bool_t block,
                           bool_t call)
{
    sendIPC(block, call, badge, canGrant, ksCurThread, ep);

    return EXCEPTION_NONE;
}

exception_t
performInvocation_AsyncEndpoint(async_endpoint_t *aep, word_t badge)
{
    sendAsyncIPC(aep, badge);

    return EXCEPTION_NONE;
}

exception_t
performInvocation_Reply(tcb_t *thread, cte_t *slot)
{
    doReplyTransfer(ksCurThread, thread, slot);
    return EXCEPTION_NONE;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "./api/invocation.h" 1
/* @LICENSE(OKL_CORE) */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/string.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 26 "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c" 2

static inline void
addToBitmap(word_t dom, word_t prio)
{
    uint32_t l1index;

    l1index = prio_to_l1index(prio);
    ksReadyQueuesL1Bitmap[dom] |= (1ul<<(l1index));
    ksReadyQueuesL2Bitmap[dom][l1index] |= (1ul<<(prio & ((1ul<<(5))-1ul)));
}

static inline void
removeFromBitmap(word_t dom, word_t prio)
{
    uint32_t l1index;

    l1index = prio_to_l1index(prio);
    ksReadyQueuesL2Bitmap[dom][l1index] &= ~(1ul<<(prio & ((1ul<<(5))-1ul)));
    if (__builtin_expect(!!(!ksReadyQueuesL2Bitmap[dom][l1index]), 0)) {
        ksReadyQueuesL1Bitmap[dom] &= ~(1ul<<(l1index));
    }
}

/* Add TCB to the head of a scheduler queue */
void
tcbSchedEnqueue(tcb_t *tcb)
{
    if (!thread_state_get_tcbQueued(tcb->tcbState)) {
        tcb_queue_t queue;
        __attribute__((unused)) dom_t dom;
        prio_t prio;
        unsigned int idx;

        dom = tcb->tcbDomain;
        prio = tcb->tcbPriority;
        idx = ready_queues_index(dom, prio);
        queue = ksReadyQueues[idx];

        if (!queue.end) { /* Empty list */
            queue.end = tcb;
            addToBitmap(dom, prio);
        } else {
            queue.head->tcbSchedPrev = tcb;
        }
        tcb->tcbSchedPrev = ((void *)0);
        tcb->tcbSchedNext = queue.head;
        queue.head = tcb;

        ksReadyQueues[idx] = queue;

        thread_state_ptr_set_tcbQueued(&tcb->tcbState, true);
    }
}

/* Add TCB to the end of a scheduler queue */
void
tcbSchedAppend(tcb_t *tcb)
{
    if (!thread_state_get_tcbQueued(tcb->tcbState)) {
        tcb_queue_t queue;
        __attribute__((unused)) dom_t dom;
        prio_t prio;
        unsigned int idx;

        dom = tcb->tcbDomain;
        prio = tcb->tcbPriority;
        idx = ready_queues_index(dom, prio);
        queue = ksReadyQueues[idx];

        if (!queue.head) { /* Empty list */
            queue.head = tcb;
            addToBitmap(dom, prio);
        } else {
            queue.end->tcbSchedNext = tcb;
        }
        tcb->tcbSchedPrev = queue.end;
        tcb->tcbSchedNext = ((void *)0);
        queue.end = tcb;

        ksReadyQueues[idx] = queue;

        thread_state_ptr_set_tcbQueued(&tcb->tcbState, true);
    }
}

/* Remove TCB from a scheduler queue */
void
tcbSchedDequeue(tcb_t *tcb)
{
    if (thread_state_get_tcbQueued(tcb->tcbState)) {
        tcb_queue_t queue;
        __attribute__((unused)) dom_t dom;
        prio_t prio;
        unsigned int idx;

        dom = tcb->tcbDomain;
        prio = tcb->tcbPriority;
        idx = ready_queues_index(dom, prio);
        queue = ksReadyQueues[idx];

        if (tcb->tcbSchedPrev) {
            tcb->tcbSchedPrev->tcbSchedNext = tcb->tcbSchedNext;
        } else {
            queue.head = tcb->tcbSchedNext;
            if (__builtin_expect(!!(!tcb->tcbSchedNext), 1)) {
                removeFromBitmap(dom, prio);
            }
        }

        if (tcb->tcbSchedNext) {
            tcb->tcbSchedNext->tcbSchedPrev = tcb->tcbSchedPrev;
        } else {
            queue.end = tcb->tcbSchedPrev;
        }

        ksReadyQueues[idx] = queue;

        thread_state_ptr_set_tcbQueued(&tcb->tcbState, false);
    }
}

/* Add TCB to the end of an endpoint queue */
tcb_queue_t
tcbEPAppend(tcb_t *tcb, tcb_queue_t queue)
{
    if (!queue.head) { /* Empty list */
        queue.head = tcb;
    } else {
        queue.end->tcbEPNext = tcb;
    }
    tcb->tcbEPPrev = queue.end;
    tcb->tcbEPNext = ((void *)0);
    queue.end = tcb;

    return queue;
}

/* Remove TCB from an endpoint queue */
tcb_queue_t
tcbEPDequeue(tcb_t *tcb, tcb_queue_t queue)
{
    if (tcb->tcbEPPrev) {
        tcb->tcbEPPrev->tcbEPNext = tcb->tcbEPNext;
    } else {
        queue.head = tcb->tcbEPNext;
    }

    if (tcb->tcbEPNext) {
        tcb->tcbEPNext->tcbEPPrev = tcb->tcbEPPrev;
    } else {
        queue.end = tcb->tcbEPPrev;
    }

    return queue;
}

cptr_t __attribute__((__pure__))
getExtraCPtr(word_t *bufferPtr, unsigned int i)
{
    return (cptr_t)bufferPtr[seL4_MsgMaxLength + 2 + i];
}

void
setExtraBadge(word_t *bufferPtr, word_t badge,
              unsigned int i)
{
    bufferPtr[seL4_MsgMaxLength + 2 + i] = badge;
}

void
setupCallerCap(tcb_t *sender, tcb_t *receiver)
{
    cte_t *replySlot, *callerSlot;
    cap_t masterCap __attribute__((unused)), callerCap __attribute__((unused));

    setThreadState(sender, ThreadState_BlockedOnReply);
    replySlot = (((cte_t *)((unsigned int)(sender)&~((1ul<<(10))-1ul)))+(tcbReply));
    callerSlot = (((cte_t *)((unsigned int)(receiver)&~((1ul<<(10))-1ul)))+(tcbCaller));
    masterCap = replySlot->cap;
    /* Haskell error: "Sender must have a valid master reply cap" */
    if(!(cap_get_capType(masterCap) == cap_reply_cap)) _assert_fail("cap_get_capType(masterCap) == cap_reply_cap", "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c", 206, __FUNCTION__);
    if(!(cap_reply_cap_get_capReplyMaster(masterCap))) _assert_fail("cap_reply_cap_get_capReplyMaster(masterCap)", "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c", 207, __FUNCTION__);
    if(!(((tcb_t *)(cap_reply_cap_get_capTCBPtr(masterCap))) == ((void *)0))) _assert_fail("TCB_PTR(cap_reply_cap_get_capTCBPtr(masterCap)) == NULL", "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c", 208, __FUNCTION__);
    cap_reply_cap_ptr_set_capCallerSlot(&replySlot->cap, ((unsigned int)(callerSlot)));
    callerCap = callerSlot->cap;
    /* Haskell error: "Caller cap must not already exist" */
    if(!(cap_get_capType(callerCap) == cap_null_cap)) _assert_fail("cap_get_capType(callerCap) == cap_null_cap", "/home/kq/Sources/RefOS_x86/kernel/src/object/tcb.c", 212, __FUNCTION__);
    callerSlot->cap = cap_reply_cap_new(((unsigned int)(((void *)0))), false, ((unsigned int)(sender)));
}

void
deleteCallerCap(tcb_t *receiver)
{
    cte_t *callerSlot;

    callerSlot = (((cte_t *)((unsigned int)(receiver)&~((1ul<<(10))-1ul)))+(tcbCaller));
    if (cap_get_capType(callerSlot->cap) == cap_reply_cap) {
        finaliseCap(callerSlot->cap, true, true);
        callerSlot->cap = cap_null_cap_new();
    }
}

extra_caps_t current_extra_caps;

exception_t
lookupExtraCaps(tcb_t* thread, word_t *bufferPtr, message_info_t info)
{
    lookupSlot_raw_ret_t lu_ret;
    cptr_t cptr;
    unsigned int i, length;

    if (!bufferPtr) {
        current_extra_caps.excaprefs[0] = ((void *)0);
        return EXCEPTION_NONE;
    }

    length = message_info_get_msgExtraCaps(info);

    for (i = 0; i < length; i++) {
        cptr = getExtraCPtr(bufferPtr, i);

        lu_ret = lookupSlot(thread, cptr);
        if (lu_ret.status != EXCEPTION_NONE) {
            current_fault = fault_cap_fault_new(cptr, false);
            return lu_ret.status;
        }

        current_extra_caps.excaprefs[i] = lu_ret.slot;
    }
    if (i < ((1ul<<(seL4_MsgExtraCapBits))-1)) {
        current_extra_caps.excaprefs[i] = ((void *)0);
    }

    return EXCEPTION_NONE;
}

/* Copy IPC MRs from one thread to another */
unsigned int
copyMRs(tcb_t *sender, word_t *sendBuf, tcb_t *receiver,
        word_t *recvBuf, unsigned int n)
{
    unsigned int i;

    /* Copy inline words */
    for (i = 0; i < n && i < n_msgRegisters; i++) {
        setRegister(receiver, msgRegisters[i],
                    getRegister(sender, msgRegisters[i]));
    }

    if (!recvBuf || !sendBuf) {
        return i;
    }

    /* Copy out-of-line words */
    for (; i < n; i++) {
        recvBuf[i + 1] = sendBuf[i + 1];
    }

    return i;
}

/* The following functions sit in the syscall error monad, but include the
 * exception cases for the preemptible bottom end, as they call the invoke
 * functions directly.  This is a significant deviation from the Haskell
 * spec. */
exception_t
decodeTCBInvocation(word_t label, unsigned int length, cap_t cap,
                    cte_t* slot, extra_caps_t extraCaps, bool_t call,
                    word_t *buffer)
{
    switch (label) {
    case TCBReadRegisters:
        /* Second level of decoding */
        return decodeReadRegisters(cap, length, call, buffer);

    case TCBWriteRegisters:
        return decodeWriteRegisters(cap, length, buffer);

    case TCBCopyRegisters:
        return decodeCopyRegisters(cap, length, extraCaps, buffer);

    case TCBSuspend:
        /* Jump straight to the invoke */
        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeTCB_Suspend(
                   ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))));

    case TCBResume:
        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeTCB_Resume(
                   ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))));

    case TCBConfigure:
        return decodeTCBConfigure(cap, length, slot, extraCaps, buffer);

    case TCBSetPriority:
        return decodeSetPriority(cap, length, buffer);

    case TCBSetIPCBuffer:
        return decodeSetIPCBuffer(cap, length, slot, extraCaps, buffer);

    case TCBSetSpace:
        return decodeSetSpace(cap, length, slot, extraCaps, buffer);

    case TCBBindAEP:
        return decodeBindAEP(cap, extraCaps);

    case TCBUnbindAEP:
        return decodeUnbindAEP(cap);

        /* This is temporary until arch specific TCB operations are implemented */

    case TCBSetEPTRoot:
        return decodeSetEPTRoot(cap, extraCaps);


    default:
        /* Haskell: "throw IllegalOperation" */
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 344, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB: Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }
}

enum CopyRegistersFlags {
    CopyRegisters_suspendSource = 0,
    CopyRegisters_resumeTarget = 1,
    CopyRegisters_transferFrame = 2,
    CopyRegisters_transferInteger = 3
};

exception_t
decodeCopyRegisters(cap_t cap, unsigned int length,
                    extra_caps_t extraCaps, word_t *buffer)
{
    word_t transferArch;
    tcb_t *srcTCB;
    cap_t source_cap;
    word_t flags;

    if (length < 1 || extraCaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 367, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB CopyRegisters: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    flags = getSyscallArg(0, buffer);

    transferArch = Arch_decodeTransfer(flags >> 8);

    source_cap = extraCaps.excaprefs[0]->cap;

    if (cap_get_capType(source_cap) == cap_thread_cap) {
        srcTCB = ((tcb_t *)(cap_thread_cap_get_capTCBPtr(source_cap)));
    } else {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 381, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB CopyRegisters: Invalid source TCB."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_CopyRegisters(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))), srcTCB,
               flags & (1ul<<(CopyRegisters_suspendSource)),
               flags & (1ul<<(CopyRegisters_resumeTarget)),
               flags & (1ul<<(CopyRegisters_transferFrame)),
               flags & (1ul<<(CopyRegisters_transferInteger)),
               transferArch);

}

enum ReadRegistersFlags {
    ReadRegisters_suspend = 0
};

exception_t
decodeReadRegisters(cap_t cap, unsigned int length, bool_t call,
                    word_t *buffer)
{
    word_t transferArch, flags, n;

    if (length < 2) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 409, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB ReadRegisters: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    flags = getSyscallArg(0, buffer);
    n = getSyscallArg(1, buffer);

    if (n < 1 || n > n_frameRegisters + n_gpRegisters) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 419, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB ReadRegisters: Attempted to read an invalid number of registers (%d).", (int)n); kprintf(">>" "\033[0m" "\n"); } while (0)
                         ;
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 1;
        current_syscall_error.rangeErrorMax = n_frameRegisters +
                                              n_gpRegisters;
        return EXCEPTION_SYSCALL_ERROR;
    }

    transferArch = Arch_decodeTransfer(flags >> 8);

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_ReadRegisters(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))),
               flags & (1ul<<(ReadRegisters_suspend)),
               n, transferArch, call);
}

enum WriteRegistersFlags {
    WriteRegisters_resume = 0
};

exception_t
decodeWriteRegisters(cap_t cap, unsigned int length, word_t *buffer)
{
    word_t flags, w;
    word_t transferArch;
    tcb_t* thread;

    if (length < 2) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 448, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB WriteRegisters: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    flags = getSyscallArg(0, buffer);
    w = getSyscallArg(1, buffer);

    if (length - 2 < w) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 458, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB WriteRegisters: Message too short for requested write size (%d/%d).", (int)(length - 2), (int)w); kprintf(">>" "\033[0m" "\n"); } while (0)
                                            ;
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    transferArch = Arch_decodeTransfer(flags >> 8);

    thread = ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap)));

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_WriteRegisters(thread,
                                    flags & (1ul<<(WriteRegisters_resume)),
                                    w, transferArch, buffer);
}

/* SetPriority, SetIPCParams and SetSpace are all
 * specialisations of TCBConfigure. */

exception_t
decodeTCBConfigure(cap_t cap, unsigned int length, cte_t* slot,
                   extra_caps_t rootCaps, word_t *buffer)
{
    cte_t *bufferSlot, *cRootSlot, *vRootSlot;
    cap_t bufferCap, cRootCap, vRootCap;
    deriveCap_ret_t dc_ret;
    cptr_t faultEP;
    unsigned int prio;
    word_t cRootData, vRootData, bufferAddr;

    if (length < 5 || rootCaps.excaprefs[0] == ((void *)0)
            || rootCaps.excaprefs[1] == ((void *)0)
            || rootCaps.excaprefs[2] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 490, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB Configure: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    faultEP = getSyscallArg(0, buffer);
    prio = getSyscallArg(1, buffer);
    cRootData = getSyscallArg(2, buffer);
    vRootData = getSyscallArg(3, buffer);
    bufferAddr = getSyscallArg(4, buffer);

    cRootSlot = rootCaps.excaprefs[0];
    cRootCap = rootCaps.excaprefs[0]->cap;
    vRootSlot = rootCaps.excaprefs[1];
    vRootCap = rootCaps.excaprefs[1]->cap;
    bufferSlot = rootCaps.excaprefs[2];
    bufferCap = rootCaps.excaprefs[2]->cap;

    prio = prio & ((1ul<<(8))-1ul);

    if (prio > ksCurThread->tcbPriority) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 512, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB Configure: Requested priority %d too high (max %d).", (int)prio, (int)(ksCurThread->tcbPriority)); kprintf(">>" "\033[0m" "\n"); } while (0)
                                                             ;
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (bufferAddr == 0) {
        bufferSlot = ((void *)0);
    } else {
        exception_t e;

        dc_ret = deriveCap(bufferSlot, bufferCap);
        if (dc_ret.status != EXCEPTION_NONE) {
            return dc_ret.status;
        }
        bufferCap = dc_ret.cap;
        e = checkValidIPCBuffer(bufferAddr, bufferCap);
        if (e != EXCEPTION_NONE) {
            return e;
        }
    }

    if (slotCapLongRunningDelete(
                (((cte_t *)((unsigned int)(cap_thread_cap_get_capTCBPtr(cap))&~((1ul<<(10))-1ul)))+(tcbCTable))) ||
            slotCapLongRunningDelete(
                (((cte_t *)((unsigned int)(cap_thread_cap_get_capTCBPtr(cap))&~((1ul<<(10))-1ul)))+(tcbVTable)))) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 537, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB Configure: CSpace or VSpace currently being deleted."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (cRootData != 0) {
        cRootCap = updateCapData(false, cRootData, cRootCap);
    }

    dc_ret = deriveCap(cRootSlot, cRootCap);
    if (dc_ret.status != EXCEPTION_NONE) {
        return dc_ret.status;
    }
    cRootCap = dc_ret.cap;

    if (cap_get_capType(cRootCap) != cap_cnode_cap &&
            (!0 ||
             cap_get_capType(cRootCap) != cap_null_cap)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 555, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB Configure: CSpace cap is invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (vRootData != 0) {
        vRootCap = updateCapData(false, vRootData, vRootCap);
    }

    dc_ret = deriveCap(vRootSlot, vRootCap);
    if (dc_ret.status != EXCEPTION_NONE) {
        return dc_ret.status;
    }
    vRootCap = dc_ret.cap;

    if (!isValidVTableRoot(vRootCap)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 571, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB Configure: VSpace cap is invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_ThreadControl(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))), slot,
               faultEP, prio,
               cRootCap, cRootSlot,
               vRootCap, vRootSlot,
               bufferAddr, bufferCap,
               bufferSlot, thread_control_update_all);
}

exception_t
decodeSetPriority(cap_t cap, unsigned int length, word_t *buffer)
{
    prio_t newPrio;

    if (length < 1) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 592, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB SetPriority: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    newPrio = getSyscallArg(0, buffer);

    /* assuming here seL4_MaxPrio is of form 2^n - 1 */
    newPrio = newPrio & ((1ul<<(8))-1ul);

    if (newPrio > ksCurThread->tcbPriority) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 604, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB SetPriority: Requested priority %d too high (max %d).", (int)newPrio, (int)ksCurThread->tcbPriority); kprintf(">>" "\033[0m" "\n"); } while (0)
                                                              ;
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_ThreadControl(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))), ((void *)0),
               0, newPrio,
               cap_null_cap_new(), ((void *)0),
               cap_null_cap_new(), ((void *)0),
               0, cap_null_cap_new(),
               ((void *)0), thread_control_update_priority);
}

exception_t
decodeSetIPCBuffer(cap_t cap, unsigned int length, cte_t* slot,
                   extra_caps_t extraCaps, word_t *buffer)
{
    cptr_t cptr_bufferPtr;
    cap_t bufferCap;
    cte_t *bufferSlot;

    if (length < 1 || extraCaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 628, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB SetIPCBuffer: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    cptr_bufferPtr = getSyscallArg(0, buffer);
    bufferSlot = extraCaps.excaprefs[0];
    bufferCap = extraCaps.excaprefs[0]->cap;

    if (cptr_bufferPtr == 0) {
        bufferSlot = ((void *)0);
    } else {
        exception_t e;
        deriveCap_ret_t dc_ret;

        dc_ret = deriveCap(bufferSlot, bufferCap);
        if (dc_ret.status != EXCEPTION_NONE) {
            return dc_ret.status;
        }
        bufferCap = dc_ret.cap;
        e = checkValidIPCBuffer(cptr_bufferPtr, bufferCap);
        if (e != EXCEPTION_NONE) {
            return e;
        }
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_ThreadControl(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))), slot,
               0,
               0, /* used to be prioInvalid, but it doesn't matter */
               cap_null_cap_new(), ((void *)0),
               cap_null_cap_new(), ((void *)0),
               cptr_bufferPtr, bufferCap,
               bufferSlot, thread_control_update_ipc_buffer);
}

exception_t
decodeSetSpace(cap_t cap, unsigned int length, cte_t* slot,
               extra_caps_t extraCaps, word_t *buffer)
{
    cptr_t faultEP;
    word_t cRootData, vRootData;
    cte_t *cRootSlot, *vRootSlot;
    cap_t cRootCap, vRootCap;
    deriveCap_ret_t dc_ret;

    if (length < 3 || extraCaps.excaprefs[0] == ((void *)0)
            || extraCaps.excaprefs[1] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 677, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB SetSpace: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    faultEP = getSyscallArg(0, buffer);
    cRootData = getSyscallArg(1, buffer);
    vRootData = getSyscallArg(2, buffer);

    cRootSlot = extraCaps.excaprefs[0];
    cRootCap = extraCaps.excaprefs[0]->cap;
    vRootSlot = extraCaps.excaprefs[1];
    vRootCap = extraCaps.excaprefs[1]->cap;

    if (slotCapLongRunningDelete(
                (((cte_t *)((unsigned int)(cap_thread_cap_get_capTCBPtr(cap))&~((1ul<<(10))-1ul)))+(tcbCTable))) ||
            slotCapLongRunningDelete(
                (((cte_t *)((unsigned int)(cap_thread_cap_get_capTCBPtr(cap))&~((1ul<<(10))-1ul)))+(tcbVTable)))) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 695, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB SetSpace: CSpace or VSpace currently being deleted."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (cRootData != 0) {
        cRootCap = updateCapData(false, cRootData, cRootCap);
    }

    dc_ret = deriveCap(cRootSlot, cRootCap);
    if (dc_ret.status != EXCEPTION_NONE) {
        return dc_ret.status;
    }
    cRootCap = dc_ret.cap;

    if (cap_get_capType(cRootCap) != cap_cnode_cap &&
            (!0 ||
             cap_get_capType(cRootCap) != cap_null_cap)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 713, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB SetSpace: Invalid CNode cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (vRootData != 0) {
        vRootCap = updateCapData(false, vRootData, vRootCap);
    }

    dc_ret = deriveCap(vRootSlot, vRootCap);
    if (dc_ret.status != EXCEPTION_NONE) {
        return dc_ret.status;
    }
    vRootCap = dc_ret.cap;

    if (!isValidVTableRoot(vRootCap)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 729, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB SetSpace: Invalid VSpace cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_ThreadControl(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))), slot,
               faultEP,
               0, /* used to be prioInvalid, but it doesn't matter */
               cRootCap, cRootSlot,
               vRootCap, vRootSlot,
               0, cap_null_cap_new(), ((void *)0), thread_control_update_space);
}

exception_t
decodeDomainInvocation(word_t label, unsigned int length, extra_caps_t extraCaps, word_t *buffer)
{
    word_t domain;
    cap_t tcap;

    if (__builtin_expect(!!(label != DomainSetSet), 0)) {
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (__builtin_expect(!!(length == 0), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 756, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Domain Configure: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    } else {
        domain = getSyscallArg(0, buffer);
        if (domain >= 1) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 763, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Domain Configure: invalid domain (%u >= %u).", domain, 1); kprintf(">>" "\033[0m" "\n"); } while (0)
                                                 ;
            current_syscall_error.type = seL4_InvalidArgument;
            current_syscall_error.invalidArgumentNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }
    }

    if (__builtin_expect(!!(extraCaps.excaprefs[0] == ((void *)0)), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 771, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Domain Configure: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    tcap = extraCaps.excaprefs[0]->cap;
    if (__builtin_expect(!!(cap_get_capType(tcap) != cap_thread_cap), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 778, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Domain Configure: thread cap required."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    setDomain(((tcb_t *)(cap_thread_cap_get_capTCBPtr(tcap))), domain);
    return EXCEPTION_NONE;
}

exception_t decodeBindAEP(cap_t cap, extra_caps_t extraCaps)
{
    async_endpoint_t *aepptr;
    tcb_t *tcb;

    if (extraCaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 795, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB BindAEP: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (cap_get_capType(extraCaps.excaprefs[0]->cap) != cap_async_endpoint_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 801, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB BindAEP: Async endpoint is invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    tcb = ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap)));

    if (tcb->boundAsyncEndpoint) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 809, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB BindAEP: TCB already has AEP."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    aepptr = ((async_endpoint_t *)(cap_async_endpoint_cap_get_capAEPPtr(extraCaps.excaprefs[0]->cap)));
    if ((tcb_t*)async_endpoint_ptr_get_aepQueue_head(aepptr)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 816, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB BindAEP: AEP cannot be bound."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_AEPControl(tcb, aepptr);
}

exception_t decodeUnbindAEP(cap_t cap)
{
    tcb_t *tcb;

    tcb = ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap)));

    if (!tcb->boundAsyncEndpoint) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 832, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("TCB UnbindAEP: TCB already has no bound AEP."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_AEPControl(tcb, ((void *)0));
}

/* The following functions sit in the preemption monad and implement the
 * preemptible, non-faulting bottom end of a TCB invocation. */
exception_t
invokeTCB_Suspend(tcb_t *thread)
{
    suspend(thread);
    return EXCEPTION_NONE;
}

exception_t
invokeTCB_Resume(tcb_t *thread)
{
    restart(thread);
    return EXCEPTION_NONE;
}

exception_t
invokeTCB_ThreadControl(tcb_t *target, cte_t* slot,
                        cptr_t faultep, prio_t priority,
                        cap_t cRoot_newCap, cte_t *cRoot_srcSlot,
                        cap_t vRoot_newCap, cte_t *vRoot_srcSlot,
                        word_t bufferAddr, cap_t bufferCap,
                        cte_t *bufferSrcSlot,
                        thread_control_flag_t updateFlags)
{
    exception_t e;
    cap_t tCap = cap_thread_cap_new((word_t)target);

    if (updateFlags & thread_control_update_space) {
        target->tcbFaultHandler = faultep;
    }

    if (updateFlags & thread_control_update_priority) {
        setPriority(target, priority);
    }

    if (updateFlags & thread_control_update_space) {
        cte_t *rootSlot;

        rootSlot = (((cte_t *)((unsigned int)(target)&~((1ul<<(10))-1ul)))+(tcbCTable));
        e = cteDelete(rootSlot, true);
        if (e != EXCEPTION_NONE) {
            return e;
        }
        if (sameObjectAs(cRoot_newCap, cRoot_srcSlot->cap) &&
                sameObjectAs(tCap, slot->cap)) {
            cteInsert(cRoot_newCap, cRoot_srcSlot, rootSlot);
        }
    }

    if (updateFlags & thread_control_update_space) {
        cte_t *rootSlot;

        rootSlot = (((cte_t *)((unsigned int)(target)&~((1ul<<(10))-1ul)))+(tcbVTable));
        e = cteDelete(rootSlot, true);
        if (e != EXCEPTION_NONE) {
            return e;
        }
        if (sameObjectAs(vRoot_newCap, vRoot_srcSlot->cap) &&
                sameObjectAs(tCap, slot->cap)) {
            cteInsert(vRoot_newCap, vRoot_srcSlot, rootSlot);
        }
    }

    if (updateFlags & thread_control_update_ipc_buffer) {
        cte_t *bufferSlot;

        bufferSlot = (((cte_t *)((unsigned int)(target)&~((1ul<<(10))-1ul)))+(tcbBuffer));
        e = cteDelete(bufferSlot, true);
        if (e != EXCEPTION_NONE) {
            return e;
        }
        target->tcbIPCBuffer = bufferAddr;
        if (bufferSrcSlot && sameObjectAs(bufferCap, bufferSrcSlot->cap) &&
                sameObjectAs(tCap, slot->cap)) {
            cteInsert(bufferCap, bufferSrcSlot, bufferSlot);
        }
    }

    return EXCEPTION_NONE;
}

exception_t
invokeTCB_CopyRegisters(tcb_t *dest, tcb_t *tcb_src,
                        bool_t suspendSource, bool_t resumeTarget,
                        bool_t transferFrame, bool_t transferInteger,
                        word_t transferArch)
{
    if (suspendSource) {
        suspend(tcb_src);
    }

    if (resumeTarget) {
        restart(dest);
    }

    if (transferFrame) {
        unsigned int i;
        word_t v;
        word_t pc;

        for (i = 0; i < n_frameRegisters; i++) {
            v = getRegister(tcb_src, frameRegisters[i]);
            setRegister(dest, frameRegisters[i], v);
        }

        pc = getRestartPC(dest);
        setNextPC(dest, pc);
    }

    if (transferInteger) {
        unsigned int i;
        word_t v;

        for (i = 0; i < n_gpRegisters; i++) {
            v = getRegister(tcb_src, gpRegisters[i]);
            setRegister(dest, gpRegisters[i], v);
        }
    }

    return Arch_performTransfer(transferArch, tcb_src, dest);
}

/* ReadRegisters is a special case: replyFromKernel & setMRs are
 * unfolded here, in order to avoid passing the large reply message up
 * to the top level in a global (and double-copying). We prevent the
 * top-level replyFromKernel_success_empty() from running by setting the
 * thread state. Retype does this too.
 */
exception_t
invokeTCB_ReadRegisters(tcb_t *tcb_src, bool_t suspendSource,
                        unsigned int n, word_t arch, bool_t call)
{
    unsigned int i, j;
    exception_t e;
    tcb_t *thread;

    thread = ksCurThread;

    if (suspendSource) {
        suspend(tcb_src);
    }

    e = Arch_performTransfer(arch, tcb_src, ksCurThread);
    if (e != EXCEPTION_NONE) {
        return e;
    }

    if (call) {
        word_t *ipcBuffer;

        ipcBuffer = lookupIPCBuffer(true, thread);

        setRegister(thread, badgeRegister, 0);

        for (i = 0; i < n && i < n_frameRegisters && i < n_msgRegisters; i++) {
            setRegister(thread, msgRegisters[i],
                        getRegister(tcb_src, frameRegisters[i]));
        }

        if (ipcBuffer != ((void *)0) && i < n && i < n_frameRegisters) {
            for (; i < n && i < n_frameRegisters; i++) {
                ipcBuffer[i + 1] = getRegister(tcb_src, frameRegisters[i]);
            }
        }

        j = i;

        for (i = 0; i < n_gpRegisters && i + n_frameRegisters < n
                && i + n_frameRegisters < n_msgRegisters; i++) {
            setRegister(thread, msgRegisters[i + n_frameRegisters],
                        getRegister(tcb_src, gpRegisters[i]));
        }

        if (ipcBuffer != ((void *)0) && i < n_gpRegisters
                && i + n_frameRegisters < n) {
            for (; i < n_gpRegisters && i + n_frameRegisters < n; i++) {
                ipcBuffer[i + n_frameRegisters + 1] =
                    getRegister(tcb_src, gpRegisters[i]);
            }
        }

        setRegister(thread, msgInfoRegister, wordFromMessageInfo(
                        message_info_new(0, 0, 0, i + j)));
    }
    setThreadState(thread, ThreadState_Running);

    return EXCEPTION_NONE;
}

exception_t
invokeTCB_WriteRegisters(tcb_t *dest, bool_t resumeTarget,
                         unsigned int n, word_t arch, word_t *buffer)
{
    unsigned int i;
    word_t pc;
    exception_t e;

    e = Arch_performTransfer(arch, ksCurThread, dest);
    if (e != EXCEPTION_NONE) {
        return e;
    }

    if (n > n_frameRegisters + n_gpRegisters) {
        n = n_frameRegisters + n_gpRegisters;
    }

    for (i = 0; i < n_frameRegisters && i < n; i++) {
        /* Offset of 2 to get past the initial syscall arguments */
        setRegister(dest, frameRegisters[i],
                    sanitiseRegister(frameRegisters[i],
                                     getSyscallArg(i + 2, buffer)));
    }

    for (i = 0; i < n_gpRegisters && i + n_frameRegisters < n; i++) {
        setRegister(dest, gpRegisters[i],
                    sanitiseRegister(gpRegisters[i],
                                     getSyscallArg(i + n_frameRegisters + 2,
                                                   buffer)));
    }

    pc = getRestartPC(dest);
    setNextPC(dest, pc);

    if (resumeTarget) {
        restart(dest);
    }

    return EXCEPTION_NONE;
}

exception_t
invokeTCB_AEPControl(tcb_t *tcb, async_endpoint_t *aepptr)
{
    if (aepptr) {
        bindAsyncEndpoint(tcb, aepptr);
    } else {
        unbindAsyncEndpoint(tcb);
    }

    return EXCEPTION_NONE;
}


void
setThreadName(tcb_t *tcb, const char *name)
{
    strlcpy(tcb->tcbName, name, ((1ul<<((4 + 4))) - sizeof(tcb_t)));
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2
# 1 "./api/invocation.h" 1
/* @LICENSE(OKL_CORE) */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/untyped.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/object/untyped.c" 2

static word_t
alignUp(word_t baseValue, unsigned int alignment)
{
    return (baseValue + ((1ul<<(alignment)) - 1)) & ~((1ul<<(alignment))-1ul);
}

exception_t
decodeUntypedInvocation(word_t label, unsigned int length, cte_t *slot,
                        cap_t cap, extra_caps_t extraCaps,
                        bool_t call, word_t *buffer)
{
    word_t newType, userObjSize, nodeIndex;
    word_t nodeDepth, nodeOffset, nodeWindow;
    cte_t *rootSlot __attribute__((unused));
    exception_t status;
    cap_t nodeCap;
    lookupSlot_ret_t lu_ret;
    word_t nodeSize;
    unsigned int i;
    slot_range_t slots;
    word_t freeRef, objectSize, untypedSize;
    word_t freeIndex, alignedFreeIndex;

    /* Ensure operation is valid. */
    if (label != UntypedRetype) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 50, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped cap: Illegal operation attempted."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Ensure message length valid. */
    if (length < 7 || extraCaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 57, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped invocation: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Fetch arguments. */
    newType = getSyscallArg(0, buffer);
    freeIndex = getSyscallArg(1, buffer);
    userObjSize = getSyscallArg(2, buffer);
    nodeIndex = getSyscallArg(3, buffer);
    nodeDepth = getSyscallArg(4, buffer);
    nodeOffset = getSyscallArg(5, buffer);
    nodeWindow = getSyscallArg(6, buffer);

    rootSlot = extraCaps.excaprefs[0];

    /*
     * Okay to retype if at least one of the following criteria hold:
     *   - the original untyped sits in the kernel window.
     *   - we are retyping to a frame (small, big, whatever).
     *   - we are retyping to an untyped
     */
    if (!(inKernelWindow((void *)cap_untyped_cap_get_capPtr(cap)) ||
            Arch_isFrameType(newType) ||
            newType == seL4_UntypedObject)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 82, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Untyped outside kernel window (%p).", (void*)newType); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Is the requested object type valid? */
    if (newType >= seL4_ObjectTypeCount) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 90, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Invalid object type."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Is the requested object size valid? */
    if (userObjSize >= (32 - 1)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 98, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Invalid object size."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 0;
        current_syscall_error.rangeErrorMax = 32 - 2;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* If the target object is a CNode, is it at least size 1? */
    if (newType == seL4_CapTableObject && userObjSize == 0) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 107, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Requested CapTable size too small."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* If the target object is a Untyped, is it at least size 4? */
    if (newType == seL4_UntypedObject && userObjSize < 4) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 115, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Requested UntypedItem size too small."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Lookup the destination CNode (where our caps will be placed in). */
    if (nodeDepth == 0) {
        nodeCap = extraCaps.excaprefs[0]->cap;
    } else {
        cap_t rootCap = extraCaps.excaprefs[0]->cap;
        lu_ret = lookupTargetSlot(rootCap, nodeIndex, nodeDepth);
        if (lu_ret.status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 128, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Invalid destination address."); kprintf(">>" "\033[0m" "\n"); } while (0);
            return lu_ret.status;
        }
        nodeCap = lu_ret.slot->cap;
    }

    /* Is the destination actually a CNode? */
    if (cap_get_capType(nodeCap) != cap_cnode_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 136, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Destination cap invalid or read-only."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = 0;
        current_lookup_fault = lookup_fault_missing_capability_new(nodeDepth);
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Is the region where the user wants to put the caps valid? */
    nodeSize = 1 << cap_cnode_cap_get_capCNodeRadix(nodeCap);
    if (nodeOffset > nodeSize - 1) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 147, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Destination node offset #%d too large.", (int)nodeOffset); kprintf(">>" "\033[0m" "\n"); } while (0)
                                  ;
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 0;
        current_syscall_error.rangeErrorMax = nodeSize - 1;
        return EXCEPTION_SYSCALL_ERROR;
    }
    if (nodeWindow < 1 || nodeWindow > 256) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 155, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Number of requested objects (%d) too small or large.", (int)nodeWindow); kprintf(">>" "\033[0m" "\n"); } while (0)
                                  ;
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 1;
        current_syscall_error.rangeErrorMax = 256;
        return EXCEPTION_SYSCALL_ERROR;
    }
    if (nodeWindow > nodeSize - nodeOffset) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 162, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Requested destination window overruns size of node."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 1;
        current_syscall_error.rangeErrorMax = nodeSize - nodeOffset;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Ensure that the destination slots are all empty. */
    slots.cnode = ((cte_t *)(cap_cnode_cap_get_capCNodePtr(nodeCap)));
    slots.offset = nodeOffset;
    slots.length = nodeWindow;
    for (i = nodeOffset; i < nodeOffset + nodeWindow; i++) {
        status = ensureEmptySlot(slots.cnode + i);
        if (status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 177, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Slot #%d in destination window non-empty.", (int)i); kprintf(">>" "\033[0m" "\n"); } while (0)
                             ;
            return status;
        }
    }

    objectSize = getObjectSize(newType, userObjSize);

    /* Align up the free region so that it is aligned to the target object's
     * size. */
    alignedFreeIndex = alignUp(freeIndex, objectSize);

    freeRef = ((word_t)(((word_t)(cap_untyped_cap_get_capPtr(cap))) + (alignedFreeIndex)));

    /* Check that this object will be within the bounds of the untyped */
    untypedSize = (1ul<<(cap_untyped_cap_get_capBlockSize(cap)));
    if (objectSize >= 32 || alignedFreeIndex + (1ul<<(objectSize)) > untypedSize) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 193, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Insufficient memory or offset outside untyped"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_NotEnoughMemory;
        current_syscall_error.memoryLeft = untypedSize;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Check to see if this retype will collide with an existing child. */
    if (newType != seL4_UntypedObject && !cap_untyped_cap_get_capDeviceMemory(cap)) {
        cte_t *child = cdtFindTypedInRange(freeRef, nodeWindow * objectSize);
        if (child) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 203, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: collision with existing child"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_RevokeFirst;
            return EXCEPTION_SYSCALL_ERROR;
        }
    }

    /* Check we do not create non frames in frame only untypeds */
    if ( (cap_untyped_cap_get_capDeviceMemory(cap) && !Arch_isFrameType(newType))
            && newType != seL4_UntypedObject) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4" "\033[0m" "\033[30;1m" " [%s/%d T%x \"%s\" @%x]: ", __func__, 212, (int)ksCurThread, ksCurThread->tcbName, (int)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Creating kernel objects with frame only untyped"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Perform the retype. */
    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeUntyped_Retype(
               slot, ((word_t *)(cap_untyped_cap_get_capPtr(cap))),
               (void*)freeRef, newType, userObjSize, slots, call, cap_untyped_cap_get_capDeviceMemory(cap));
}

exception_t
invokeUntyped_Retype(cte_t *srcSlot, void* regionBase,
                     void* freeRegionBase,
                     object_t newType, unsigned int userSize,
                     slot_range_t destSlots, bool_t call, bool_t deviceMemory)
{
    word_t size_ign __attribute__((unused));

    /*
     * If this is the first object we are creating in this untyped region, we
     * need to detype the old memory. At the concrete C level, this doesn't
     * have any effect, but updating this shadow state is important for the
     * verification process.
     */
    size_ign = cap_untyped_cap_ptr_get_capBlockSize(&(srcSlot->cap));
    /** AUXUPD: "(True,
        if (\<acute>freeRegionBase = \<acute>regionBase) then
          (typ_region_bytes (ptr_val \<acute>regionBase) (unat \<acute>size_ign))
        else
          id)" */
    /** GHOSTUPD: "(True,
        if (\<acute>freeRegionBase = \<acute>regionBase) then
          (gs_clear_region (ptr_val \<acute>regionBase) (unat \<acute>size_ign))
        else
          id)" */

    /* Create new objects and caps. */
    createNewObjects(newType, srcSlot, destSlots, freeRegionBase, userSize, deviceMemory);

    return EXCEPTION_NONE;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/acpi.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/devices.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c" 2



enum acpi_type {
    ACPI_RSDP,
    ACPI_RSDT
};

/* Root System Descriptor Pointer */
typedef struct acpi_rsdp {
    char signature[8];
    uint8_t checksum;
    char oem_id[6];
    uint8_t revision;
    uint32_t rsdt_address;
    uint32_t length;
    uint32_t xsdt_address[2];
    uint8_t extended_checksum;
    char reserved[3];
} acpi_rsdp_t;
typedef int __assert_failed_acpi_rsdp_packed[(sizeof(acpi_rsdp_t) == 36) ? 1 : -1];

/* DMA Remapping Reporting Table */
typedef struct acpi_dmar {
    acpi_header_t header;
    uint8_t host_addr_width;
    uint8_t flags;
    uint8_t reserved[10];
} acpi_dmar_t;
typedef int __assert_failed_acpi_dmar_packed[(sizeof(acpi_dmar_t) == sizeof(acpi_header_t) + 12) ? 1 : -1];


/* DMA Remapping Structure Header */
typedef struct acpi_dmar_header {
    uint16_t type;
    uint16_t length;
} acpi_dmar_header_t;
typedef int __assert_failed_acpi_dmar_header_packed[(sizeof(acpi_dmar_header_t) == 4) ? 1 : -1];

/* DMA Remapping Structure Types */
enum acpi_table_dmar_struct_type {
    DMAR_DRHD = 0,
    DMAR_RMRR = 1,
    DMAR_ATSR = 2,
};

/* DMA Remapping Hardware unit Definition */
typedef struct acpi_dmar_drhd {
    acpi_dmar_header_t header;
    uint8_t flags;
    uint8_t reserved;
    uint16_t segment;
    uint32_t reg_base[2];
} acpi_dmar_drhd_t;
typedef int __assert_failed_acpi_dmar_drhd_packed[(sizeof(acpi_dmar_drhd_t) == sizeof(acpi_dmar_header_t) + 12) ? 1 : -1];


/* Reserved Memory Region Reporting structure Definition */
typedef struct acpi_dmar_devscope {
    uint8_t type;
    uint8_t length;
    uint16_t reserved;
    uint8_t enum_id;
    uint8_t start_bus;
    struct {
        uint8_t dev;
        uint8_t fun;
    } path_0;
} acpi_dmar_devscope_t;
typedef int __assert_failed_acpi_dmar_devscope_packed[(sizeof(acpi_dmar_devscope_t) == 8) ? 1 : -1];

/* Reserved Memory Region Reporting structure Definition */
typedef struct acpi_dmar_rmrr {
    acpi_dmar_header_t header;
    uint16_t reserved;
    uint16_t segment;
    uint32_t reg_base[2];
    uint32_t reg_limit[2];
    acpi_dmar_devscope_t devscope_0;
} acpi_dmar_rmrr_t;
typedef int __assert_failed_acpi_dmar_rmrr_packed[(sizeof(acpi_dmar_rmrr_t) == sizeof(acpi_dmar_header_t) + 20 + sizeof(acpi_dmar_devscope_t)) ? 1 : -1];


/* Multiple APIC Description Table (MADT) */
typedef struct acpi_madt {
    acpi_header_t header;
    uint32_t apic_addr;
    uint32_t flags;
} acpi_madt_t;
typedef int __assert_failed_acpi_madt_packed[(sizeof(acpi_madt_t) == sizeof(acpi_header_t) + 8) ? 1 : -1];


typedef struct acpi_madt_header {
    uint8_t type;
    uint8_t length;
} acpi_madt_header_t;
typedef int __assert_failed_acpi_madt_header_packed[(sizeof(acpi_madt_header_t) == 2) ? 1 : -1];

enum acpi_table_madt_struct_type {
    MADT_APIC = 0,
    MADT_IOAPIC = 1,
    MADT_ISO = 2,
};

typedef struct acpi_madt_apic {
    acpi_madt_header_t header;
    uint8_t cpu_id;
    uint8_t apic_id;
    uint32_t flags;
} acpi_madt_apic_t;
typedef int __assert_failed_acpi_madt_apic_packed[(sizeof(acpi_madt_apic_t) == sizeof(acpi_madt_header_t) + 6) ? 1 : -1];


typedef struct acpi_madt_ioapic {
    acpi_madt_header_t header;
    uint8_t ioapic_id;
    uint8_t reserved[1];
    uint32_t ioapic_addr;
    uint32_t gsib;
} acpi_madt_ioapic_t;
typedef int __assert_failed_acpi_madt_ioapic_packed[(sizeof(acpi_madt_ioapic_t) == sizeof(acpi_madt_header_t) + 10) ? 1 : -1];


typedef struct acpi_madt_iso {
    acpi_madt_header_t header;
    uint8_t bus; /* always 0 (ISA) */
    uint8_t source;
    uint32_t gsi;
    uint16_t flags;
} acpi_madt_iso_t;
/* We can't assert on the sizeof acpi_madt_iso because it contains trailing
 * padding.
 */
typedef int __assert_failed_acpi_madt_iso_packed[(__builtin_offsetof(acpi_madt_iso_t, flags) == sizeof(acpi_madt_header_t) + 6) ? 1 : -1];


/* workaround because string literals are not supported by C parser */
const char acpi_str_rsd[] = {'R', 'S', 'D', ' ', 'P', 'T', 'R', ' ', 0};
const char acpi_str_apic[] = {'A', 'P', 'I', 'C', 0};

__attribute__((__section__(".boot.text"))) static uint8_t
acpi_calc_checksum(char* start, uint32_t length)
{
    uint8_t checksum = 0;

    while (length > 0) {
        checksum += *start;
        start++;
        length--;
    }
    return checksum;
}

__attribute__((__section__(".boot.text"))) static acpi_rsdp_t*
acpi_get_rsdp(void)
{
    char* addr;

    for (addr = (char*)0x0e0000; addr < (char*)0x100000; addr += 16) {
        if (strncmp(addr, acpi_str_rsd, 8) == 0) {
            if (acpi_calc_checksum(addr, 20) == 0) {
                return (acpi_rsdp_t*)addr;
            }
        }
    }
    return ((void *)0);
}

void* acpi_table_init(void* entry, enum acpi_type table_type);
__attribute__((__section__(".boot.text"))) void*
acpi_table_init(void* entry, enum acpi_type table_type)
{
    void* acpi_table;
    unsigned int pages_for_table;
    unsigned int pages_for_header = 1;

    /* if we need to map another page to read header */
    uint32_t offset_in_page = (uint32_t)entry & ((1ul<<(IA32_4M_bits))-1ul);
    if (((1ul<<(IA32_4M_bits))-1ul) - offset_in_page < sizeof(acpi_rsdp_t)) {
        pages_for_header++;
    }

    /* map in table's header */
    acpi_table = map_temp_boot_page(entry, pages_for_header);

    switch (table_type) {
    case ACPI_RSDP: {
        acpi_rsdp_t *rsdp_entry = (acpi_rsdp_t*)entry;
        pages_for_table = (rsdp_entry->length + offset_in_page) / ((1ul<<(IA32_4M_bits))-1ul) + 1;
        break;
    }
    case ACPI_RSDT: { // RSDT, MADT, DMAR etc.
        acpi_rsdt_t *rsdt_entry = (acpi_rsdt_t*)entry;
        pages_for_table = (rsdt_entry->header.length + offset_in_page) / ((1ul<<(IA32_4M_bits))-1ul) + 1;
        break;
    }
    default:
        kprintf("Error: Mapping unknown ACPI table type\n");
        if(!(false)) _assert_fail("false", "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c", 217, __FUNCTION__);
        return ((void *)0);
    }

    /* map in full table */
    acpi_table = map_temp_boot_page(entry, pages_for_table);

    return acpi_table;
}

__attribute__((__section__(".boot.text"))) acpi_rsdt_t*
acpi_init(void)
{
    acpi_rsdp_t* acpi_rsdp = acpi_get_rsdp();
    acpi_rsdt_t* acpi_rsdt;
    acpi_rsdt_t* acpi_rsdt_mapped;

    if (acpi_rsdp == ((void *)0)) {
        kprintf("BIOS: No ACPI support detected\n");
        return ((void *)0);
    }
    kprintf("ACPI: RSDP paddr=0x%x\n", (unsigned int)acpi_rsdp);
    acpi_rsdp = acpi_table_init(acpi_rsdp, ACPI_RSDP);
    kprintf("ACPI: RSDP vaddr=0x%x\n", (unsigned int)acpi_rsdp);

    acpi_rsdt = (acpi_rsdt_t*)acpi_rsdp->rsdt_address;
    kprintf("ACPI: RSDT paddr=0x%x\n", (unsigned int)acpi_rsdt);
    acpi_rsdt_mapped = (acpi_rsdt_t*)acpi_table_init(acpi_rsdt, ACPI_RSDT);
    kprintf("ACPI: RSDT vaddr=0x%x\n", (unsigned int)acpi_rsdt_mapped);

    if(!(acpi_rsdt_mapped->header.length > 0)) _assert_fail("acpi_rsdt_mapped->header.length > 0", "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c", 247, __FUNCTION__);
    if (acpi_calc_checksum((char*)acpi_rsdt_mapped, acpi_rsdt_mapped->header.length) != 0) {
        kprintf("ACPI: RSDT checksum failure\n");
        return ((void *)0);
    }

    return acpi_rsdt;
}

__attribute__((__section__(".boot.text"))) uint32_t
acpi_madt_scan(
    acpi_rsdt_t* acpi_rsdt,
    cpu_id_t* cpu_list,
    uint32_t max_list_len,
    uint32_t* num_ioapic,
    paddr_t* ioapic_paddrs
)
{
    unsigned int entries;
    uint32_t num_cpu;
    uint32_t count;
    acpi_madt_t* acpi_madt;
    acpi_madt_header_t* acpi_madt_header;

    acpi_rsdt_t* acpi_rsdt_mapped;
    acpi_madt_t* acpi_madt_mapped;
    acpi_rsdt_mapped = (acpi_rsdt_t*)acpi_table_init(acpi_rsdt, ACPI_RSDT);

    num_cpu = 0;
    *num_ioapic = 0;

    if(!(acpi_rsdt_mapped->header.length >= sizeof(acpi_header_t))) _assert_fail("acpi_rsdt_mapped->header.length >= sizeof(acpi_header_t)", "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c", 278, __FUNCTION__);
    entries = (acpi_rsdt_mapped->header.length - sizeof(acpi_header_t)) / sizeof(acpi_header_t*);
    for (count = 0; count < entries; count++) {
        acpi_madt = (acpi_madt_t*)acpi_rsdt_mapped->entry[count];
        acpi_madt_mapped = (acpi_madt_t*)acpi_table_init(acpi_madt, ACPI_RSDT);

        if (strncmp(acpi_str_apic, acpi_madt_mapped->header.signature, 4) == 0) {
            kprintf("ACPI: MADT paddr=0x%x\n", (unsigned int)acpi_madt);
            kprintf("ACPI: MADT vaddr=0x%x\n", (unsigned int)acpi_madt_mapped);
            kprintf("ACPI: MADT apic_addr=0x%x\n", acpi_madt_mapped->apic_addr);
            kprintf("ACPI: MADT flags=0x%x\n", acpi_madt_mapped->flags);

            acpi_madt_header = (acpi_madt_header_t*)(acpi_madt_mapped + 1);

            while ((char*)acpi_madt_header < (char*)acpi_madt_mapped + acpi_madt_mapped->header.length) {
                switch (acpi_madt_header->type) {
                case MADT_APIC: {
                    /* what Intel calls apic_id is what is called cpu_id in seL4! */
                    uint8_t cpu_id = ((acpi_madt_apic_t*)acpi_madt_header)->apic_id;
                    uint32_t flags = ((acpi_madt_apic_t*)acpi_madt_header)->flags;
                    if (flags == 1) {
                        kprintf("ACPI: MADT_APIC apic_id=0x%x\n", cpu_id);
                        if (num_cpu < max_list_len) {
                            cpu_list[num_cpu] = cpu_id;
                        }
                        num_cpu++;
                    }
                    break;
                }
                case MADT_IOAPIC:
                    kprintf("ACPI: MADT_IOAPIC ioapic_id=%d ioapic_addr=0x%x gsib=%d\n", ((acpi_madt_ioapic_t*)acpi_madt_header)->ioapic_id, ((acpi_madt_ioapic_t*)acpi_madt_header)->ioapic_addr, ((acpi_madt_ioapic_t*)acpi_madt_header)->gsib)




                     ;
                    if (*num_ioapic == 1) {
                        kprintf("ACPI: Not recording this IOAPIC, only support %d\n", 1);
                    } else {
                        ioapic_paddrs[*num_ioapic] = ((acpi_madt_ioapic_t*)acpi_madt_header)->ioapic_addr;
                        (*num_ioapic)++;
                    }
                    break;
                case MADT_ISO:
                    kprintf("ACIP: MADT_ISO bus=%d source=%d gsi=%d flags=0x%x\n", ((acpi_madt_iso_t*)acpi_madt_header)->bus, ((acpi_madt_iso_t*)acpi_madt_header)->source, ((acpi_madt_iso_t*)acpi_madt_header)->gsi, ((acpi_madt_iso_t*)acpi_madt_header)->flags)



                                                                       ;
                    break;
                default:
                    break;
                }
                acpi_madt_header = (acpi_madt_header_t*)((char*)acpi_madt_header + acpi_madt_header->length);
            }
        }
    }

    kprintf("ACPI: %d CPU(s) detected\n", num_cpu);

    return num_cpu;
}



__attribute__((__section__(".boot.text"))) void
acpi_dmar_scan(
    acpi_rsdt_t* acpi_rsdt,
    paddr_t* drhu_list,
    uint32_t* num_drhu,
    uint32_t max_drhu_list_len,
    acpi_rmrr_list_t *rmrr_list
)
{
    unsigned int i;
    unsigned int entries;
    uint32_t count;
    uint32_t reg_basel, reg_baseh;
    int rmrr_count;
    dev_id_t dev_id;

    acpi_dmar_t* acpi_dmar;
    acpi_dmar_header_t* acpi_dmar_header;
    acpi_dmar_rmrr_t* acpi_dmar_rmrr;
    acpi_dmar_devscope_t* acpi_dmar_devscope;

    acpi_rsdt_t* acpi_rsdt_mapped;
    acpi_dmar_t* acpi_dmar_mapped;

    acpi_rsdt_mapped = (acpi_rsdt_t*)acpi_table_init(acpi_rsdt, ACPI_RSDT);

    *num_drhu = 0;
    rmrr_count = 0;

    if(!(acpi_rsdt_mapped->header.length >= sizeof(acpi_header_t))) _assert_fail("acpi_rsdt_mapped->header.length >= sizeof(acpi_header_t)", "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/acpi.c", 372, __FUNCTION__);
    entries = (acpi_rsdt_mapped->header.length - sizeof(acpi_header_t)) / sizeof(acpi_header_t*);
    for (count = 0; count < entries; count++) {
        acpi_dmar = (acpi_dmar_t*)acpi_rsdt_mapped->entry[count];
        acpi_dmar_mapped = (acpi_dmar_t*)acpi_table_init(acpi_dmar, ACPI_RSDT);

        if (strncmp("DMAR", acpi_dmar_mapped->header.signature, 4) == 0) {
            kprintf("ACPI: DMAR paddr=0x%x\n", (unsigned int)acpi_dmar);
            kprintf("ACPI: DMAR vaddr=0x%x\n", (unsigned int)acpi_dmar_mapped);
            kprintf("ACPI: IOMMU host address width: %d\n", acpi_dmar_mapped->host_addr_width + 1);
            acpi_dmar_header = (acpi_dmar_header_t*)(acpi_dmar_mapped + 1);

            while ((char*)acpi_dmar_header < (char*)acpi_dmar_mapped + acpi_dmar_mapped->header.length) {
                switch (acpi_dmar_header->type) {

                case DMAR_DRHD:
                    if (*num_drhu == max_drhu_list_len) {
                        kprintf("ACPI: too many IOMMUs, disabling IOMMU support\n");
                        /* try to increase MAX_NUM_DRHU in config.h */
                        *num_drhu = 0; /* report zero IOMMUs */
                        return;
                    }
                    reg_basel = ((acpi_dmar_drhd_t*)acpi_dmar_header)->reg_base[0];
                    reg_baseh = ((acpi_dmar_drhd_t*)acpi_dmar_header)->reg_base[1];
                    /* check if value fits into uint32_t */
                    if (reg_baseh != 0) {
                        kprintf("ACPI: DMAR_DRHD reg_base exceeds 32 bit, disabling IOMMU support\n");
                        /* try to make BIOS map it below 4G */
                        *num_drhu = 0; /* report zero IOMMUs */
                        return;
                    }
                    drhu_list[*num_drhu] = (paddr_t)reg_basel;
                    (*num_drhu)++;
                    break;

                case DMAR_RMRR:
                    /* loop through all device scopes of this RMRR */
                    acpi_dmar_rmrr = (acpi_dmar_rmrr_t*)acpi_dmar_header;
                    if (acpi_dmar_rmrr->reg_base[1] != 0 ||
                            acpi_dmar_rmrr->reg_limit[1] != 0) {
                        kprintf("ACPI: RMRR device above 4GiB, disabling IOMMU support\n");
                        *num_drhu = 0;
                        return ;
                    }

                    kprintf("ACPI: RMRR providing region 0x%x-0x%x\n", acpi_dmar_rmrr->reg_base[0], acpi_dmar_rmrr->reg_limit[0]);

                    for (i = 0; i <= (acpi_dmar_header->length - sizeof(acpi_dmar_rmrr_t)) / sizeof(acpi_dmar_devscope_t); i++) {
                        acpi_dmar_devscope = &acpi_dmar_rmrr->devscope_0 + i;

                        if (acpi_dmar_devscope->type != 1) {
                            /* FIXME - bugzilla bug 170 */
                            kprintf("ACPI: RMRR device scope: non-PCI-Endpoint-Devices not supported yet, disabling IOMMU support\n");
                            *num_drhu = 0; /* report zero IOMMUs */
                            return;
                        }

                        if (acpi_dmar_devscope->length > sizeof(acpi_dmar_devscope_t)) {
                            /* FIXME - bugzilla bug 170 */
                            kprintf("ACPI: RMRR device scope: devices behind bridges not supported yet, disabling IOMMU support\n");
                            *num_drhu = 0; /* report zero IOMMUs */
                            return;
                        }

                        dev_id =
                            (((acpi_dmar_devscope->start_bus) << 8) | ((acpi_dmar_devscope->path_0.dev) << 3) | (acpi_dmar_devscope->path_0.fun))



                             ;

                        if (rmrr_count == 32) {
                            kprintf("ACPI: Too many RMRR entries, disabling IOMMU support\n");
                            *num_drhu = 0;
                            return;
                        }
                        kprintf("\tACPI: registering RMRR entry for region for device: bus=0x%x dev=0x%x fun=0x%x\n", acpi_dmar_devscope->start_bus, acpi_dmar_devscope->path_0.dev, acpi_dmar_devscope->path_0.fun)



                               ;

                        rmrr_list->entries[rmrr_count].device = dev_id;
                        rmrr_list->entries[rmrr_count].base = acpi_dmar_rmrr->reg_base[0];
                        rmrr_list->entries[rmrr_count].limit = acpi_dmar_rmrr->reg_limit[0];
                        rmrr_count++;
                    }
                    break;

                case DMAR_ATSR:
                    /* not implemented yet */
                    break;

                default:
                    kprintf("ACPI: Unknown DMA remapping structure type: %x\n", acpi_dmar_header->type);
                }
                acpi_dmar_header = (acpi_dmar_header_t*)((char*)acpi_dmar_header + acpi_dmar_header->length);
            }
        }
    }
    rmrr_list->num = rmrr_count;
    kprintf("ACPI: %d IOMMUs detected\n", *num_drhu);
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/debug_helpers.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/debug_helpers.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/debug_helpers.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/debug_helpers.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/debug_helpers.c" 2



unsigned char getDebugChar(void)
{
    while ((in8(ia32KSdebugPort + 5) & 1) == 0);
    return in8(ia32KSdebugPort);
}

void putDebugChar(unsigned char a)
{
    while ((in8(ia32KSdebugPort + 5) & 0x20) == 0);
    out8(ia32KSdebugPort, a);
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/apic.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/pic.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/ioapic.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c" 2


# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/intel-vtd.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c" 2


/* ============================== interrupts/IRQs ============================== */

/* Enable or disable irq according to the 'mask' flag. */
void maskInterrupt(bool_t mask, irq_t irq)
{
    if(!(irq >= irq_controller_min)) _assert_fail("irq >= irq_controller_min", "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c", 29, __FUNCTION__);
    if(!(irq <= maxIRQ)) _assert_fail("irq <= maxIRQ", "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c", 30, __FUNCTION__);

    if (irq <= irq_controller_max) {



        pic_mask_irq(mask, irq);

    } else {
        /* we can't mask/unmask specific APIC vectors (e.g. MSIs/IPIs) */
    }
}

/* Set mode of an irq */
void setInterruptMode(irq_t irq, bool_t levelTrigger, bool_t polarityLow)
{
# 56 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/hardware.c"
}

/* Handle a platform-reserved IRQ. */
void handleReservedIRQ(irq_t irq)
{

    if (irq == irq_iommu) {
        vtd_handle_fault();
        return;
    }

    kprintf("Received reserved IRQ: %d\n", (int)irq);
}

/* Get the IRQ number currently working on. */
irq_t getActiveIRQ(void)
{
    if (ia32KScurInterrupt == int_invalid) {
        return irqInvalid;
    } else {
        return ia32KScurInterrupt - 0x20;
    }
}

/* Checks for pending IRQ */
bool_t isIRQPending(void)
{
    if (apic_is_interrupt_pending()) {
        return true;
    }

    if (pic_is_irq_pending()) {
        return true;
    }

    return false;
}

void ackInterrupt(irq_t irq)
{

    if (irq <= irq_isa_max) {
        pic_ack_active_irq();
    } else

    {
        apic_ack_active_interrupt();
    }
}

void handleSpuriousIRQ(void)
{
    /* Do nothing */
}

/* ============================== timer ============================== */

void resetTimer(void)
{
    /* not necessary */
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c" 2



# 1 "/home/kq/Sources/RefOS_x86/kernel/include/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/apic.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/acpi.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/intel-vtd.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c" 2
# 38 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c"
/* Bit Positions within Registers */





/* ICC is 63rd bit in CCMD_REG, but since we will be
 * accessing this register as 4 byte word, ICC becomes
 * 31st bit in the upper 32bit word.
 */
# 90 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c"
typedef uint32_t drhu_id_t;

static inline uint32_t vtd_read32(drhu_id_t drhu_id, uint32_t offset)
{
    return *(volatile uint32_t*)((0xffff0000 + (1ul<<(IA32_4K_bits))) + (drhu_id << IA32_4K_bits) + offset);
}

static inline void vtd_write32(drhu_id_t drhu_id, uint32_t offset, uint32_t value)
{
    *(volatile uint32_t*)((0xffff0000 + (1ul<<(IA32_4K_bits))) + (drhu_id << IA32_4K_bits) + offset) = value;
}

static inline uint32_t get_ivo(drhu_id_t drhu_id)
{
    return ((vtd_read32(drhu_id, 0x10) >> 8) & 0x3FF) * 16;
}

static inline int supports_passthrough(drhu_id_t drhu_id)
{
    return (vtd_read32(drhu_id, 0x10) >> 6) & 1;
}

static uint32_t get_fro_offset(drhu_id_t drhu_id)
{
    uint32_t fro_offset;

    /* Get bits 31 to 24 from lower Capability Register */
    fro_offset = (vtd_read32(drhu_id, 0x08) >> 24) & 0xFF;

    /* Get bits 33 to 32 from higher Capability Register */
    fro_offset |= (vtd_read32(drhu_id, 0x08 + 4) & 0x3) << 8;

    return fro_offset << 4;
}

void invalidate_context_cache(void)
{
    /* FIXME - bugzilla bug 172
     * 1. Instead of assuming global invalidation, this function should
     *    accept a parameter to control the granularity of invalidation
     *    request.
     * 2. Instead of doing invalidation for all the IOMMUs, it should
     *    only do it for the IOMMU responsible for the requesting PCI
     *    device.
     */

    uint8_t invalidate_command = 0x1;
    uint32_t ccmd_reg_upper;
    drhu_id_t i;

    for (i = 0; i < ia32KSnumDrhu; i++) {
        /* Wait till ICC bit is clear */
        while ((vtd_read32(i, 0x28 + 4) >> 31 /* Invalidate Context Cache */) & 1);

        /* Program CIRG for Global Invalidation by setting bit 61 which
         * will be bit 29 in upper 32 bits of CCMD_REG
         */
        ccmd_reg_upper = invalidate_command << 29 /* Context Invalidation Request Granularity */;

        /* Invalidate Context Cache */
        ccmd_reg_upper |= (1U << 31 /* Invalidate Context Cache */);
        vtd_write32(i, 0x28, 0);
        vtd_write32(i, 0x28 + 4, ccmd_reg_upper);

        /* Wait for the invalidation to complete */
        while ((vtd_read32(i, 0x28 + 4) >> 31 /* Invalidate Context Cache */) & 1);
    }
}

void invalidate_iotlb(void)
{
    /* FIXME - bugzilla bug 172
     * 1. Instead of assuming global invalidation, this function should
     *    accept a parameter to control the granularity of invalidation
     *    request.
     * 2. Instead of doing invalidation for all the IOMMUs, it should
     *    only do it for the IOMMU responsible for the requesting PCI
     *    device.
     */

    uint8_t invalidate_command = 0x1;
    uint32_t iotlb_reg_upper;
    uint32_t ivo_offset;
    drhu_id_t i;

    for (i = 0; i < ia32KSnumDrhu; i++) {
        ivo_offset = get_ivo(i);

        /* Wait till IVT bit is clear */
        while ((vtd_read32(i, ivo_offset + 0x08 + 4) >> 31 /* Invalidate IOTLB */) & 1);

        /* Program IIRG for Global Invalidation by setting bit 60 which
         * will be bit 28 in upper 32 bits of IOTLB_REG
         */
        iotlb_reg_upper = invalidate_command << 28 /* IOTLB Invalidation Request Granularity */;

        /* Invalidate IOTLB */
        iotlb_reg_upper |= (1U << 31 /* Invalidate IOTLB */);
        iotlb_reg_upper |= (1 << 17) | (1 << 16);

        vtd_write32(i, ivo_offset + 0x08, 0);
        vtd_write32(i, ivo_offset + 0x08 + 4, iotlb_reg_upper);

        /* Wait for the invalidation to complete */
        while ((vtd_read32(i, ivo_offset + 0x08 + 4) >> 31 /* Invalidate IOTLB */) & 1);
    }
}

static void vtd_clear_fault(drhu_id_t i, word_t fr_reg)
{
    /* Clear the 'F' (Fault) bit to indicate that this fault is processed */
    vtd_write32(i, fr_reg + 12, (1ul<<(31)));
}

static void vtd_process_faults(drhu_id_t i)
{
    /* Fault Recording register offset relative to the base register */
    uint32_t fro_offset;
    uint32_t source_id __attribute__((unused));
    uint32_t fault_type __attribute__((unused));
    uint32_t address[2] __attribute__((unused));
    uint32_t reason __attribute__((unused));
    uint32_t num_fault_regs;
    uint32_t fr_reg;
    uint32_t fault_status;
    uint32_t fault_record_index;

    /* Retrieves FRO by looking into Capability register bits 33 to 24 */
    fro_offset = get_fro_offset(i);
    fault_status = (vtd_read32(i, 0x34) >> 1) & 1;

    if (fault_status) {
        num_fault_regs = ((vtd_read32(i, 0x08 + 4) >> 8 /* high word of CAP_REG */) & 0xff) + 1;
        fault_record_index = (vtd_read32(i, 0x34) >> 0x8 /* Fault Recording Index */) & 0xFF;
        fr_reg = fro_offset + 16 * fault_record_index;

        /* Traverse the fault register ring buffer */
        do {
            source_id = vtd_read32(i, fr_reg + 8) & 0xFFFF;

            fault_type = (vtd_read32(i, fr_reg + 12) >> 30) & 1;
            address[1] = vtd_read32(i, fr_reg + 4);
            address[0] = vtd_read32(i, fr_reg);
            reason = vtd_read32(i, fr_reg + 12) & 0xFF;

            kprintf("IOMMU: DMA %s page fault ", fault_type ? "read" : "write");
            kprintf("from bus/dev/fun 0x%x ", source_id);
            kprintf("on address 0x%x:%x ", address[1], address[0]);
            kprintf("with reason code 0x%x\n", reason);

            vtd_clear_fault(i, fr_reg);

            fault_record_index = (fault_record_index + 1) % num_fault_regs;
            fr_reg = fro_offset + 16 * fault_record_index;
        } while ((vtd_read32(i, fr_reg + 12) >> 31) & 1);

        /* Check for Primary Fault Overflow */
        if (vtd_read32(i, 0x34) & 1) {
            /* Clear PFO bit, so new faults will be generated again ! */
            vtd_write32(i, 0x34, 1);
        }
    }
}

void vtd_handle_fault(void)
{
    drhu_id_t i;

    for (i = 0; i < ia32KSnumDrhu; i++) {
        vtd_process_faults(i);
    }
}

__attribute__((__section__(".boot.text"))) static void
vtd_create_root_table(void)
{
    ia32KSvtdRootTable = (void*)alloc_region(12);
    memzero((void*)ia32KSvtdRootTable, 1 << 12);
}

/* This function is a simplistic duplication of some of the logic
 * in iospace.c
 */
__attribute__((__section__(".boot.text"))) static void
vtd_map_reserved_page(vtd_cte_t *vtd_context_table, int context_index, paddr_t addr)
{
    int i;
    vtd_pte_t *iopt;
    vtd_pte_t *vtd_pte_slot;
    /* first check for the first page table */
    vtd_cte_t *vtd_context_slot = vtd_context_table + context_index;
    if (!vtd_cte_ptr_get_present(vtd_context_slot)) {
        iopt = (vtd_pte_t*)alloc_region((9 + 3));
        if (!iopt) {
            _fail("Failed to allocate IO page table", "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c", 284, __func__);
        }
        memzero(iopt, 1 << (9 + 3));
        flushCacheRange(iopt, (9 + 3));

        vtd_cte_ptr_new(
            vtd_context_slot,
            ia32KSFirstValidIODomain, /* Domain ID                              */
            0, /* CTE Depth. Ignored as reserved mapping */
            true, /* RMRR Mapping                           */
            ia32KSnumIOPTLevels - 2, /* Address Width                          */
            pptr_to_paddr(iopt), /* Address Space Root                     */
            0, /* Translation Type                       */
            true); /* Present                                */
        ia32KSFirstValidIODomain++;
        flushCacheRange(vtd_context_slot, 3);
    } else {
        iopt = (vtd_pte_t*)paddr_to_pptr(vtd_cte_ptr_get_asr(vtd_context_slot));
    }
    /* now recursively find and map page tables */
    for (i = ia32KSnumIOPTLevels - 1; i >= 0; i--) {
        uint32_t iopt_index;
        /* If we are still looking up bits beyond the 32bit of physical
         * that we support then we select entry 0 in the current PT */
        if (9 * i >= 32) {
            iopt_index = 0;
        } else {
            iopt_index = ( (addr >> IA32_4K_bits) >> (9 * i)) & ((1ul<<(9))-1ul);
        }
        vtd_pte_slot = iopt + iopt_index;
        if (i == 0) {
            /* Now put the mapping in */
            vtd_pte_ptr_new(vtd_pte_slot, addr, 0, 1, 1);
            flushCacheRange(vtd_pte_slot, 3);
        } else {
            if (!vtd_pte_ptr_get_write(vtd_pte_slot)) {
                iopt = (vtd_pte_t*)alloc_region((9 + 3));
                if (!iopt) {
                    _fail("Failed to allocate IO page table", "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c", 322, __func__);
                }
                memzero(iopt, 1 << (9 + 3));
                flushCacheRange(iopt, (9 + 3));

                vtd_pte_ptr_new(vtd_pte_slot, pptr_to_paddr(iopt), 0, 1, 1);
                flushCacheRange(vtd_pte_slot, 3);
            } else {
                iopt = (vtd_pte_t*)paddr_to_pptr(vtd_pte_ptr_get_addr(vtd_pte_slot));
            }
        }
    }
}

__attribute__((__section__(".boot.text"))) static void
vtd_create_context_table(
    uint8_t bus,
    uint32_t max_num_iopt_levels,
    acpi_rmrr_list_t *rmrr_list
)
{
    unsigned int i;
    vtd_cte_t* vtd_context_table = (vtd_cte_t*)alloc_region((9 + 3));
    if (!vtd_context_table) {
        _fail("Failed to allocate context table", "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/intel-vtd.c", 346, __func__);
    }

    kprintf("IOMMU: Create VTD context table for PCI bus 0x%x (pptr=0x%x)\n", bus, (uint32_t)vtd_context_table);
    memzero(vtd_context_table, 1 << (9 + 3));
    flushCacheRange(vtd_context_table, (9 + 3));

    ia32KSvtdRootTable[bus] =
        vtd_rte_new(
            pptr_to_paddr(vtd_context_table), /* Context Table Pointer */
            true /* Present               */
        );

    /* map in any RMRR regions */
    for (i = 0; i < rmrr_list->num; i++) {
        if (vtd_get_root_index(rmrr_list->entries[i].device) == bus) {
            uint32_t addr;
            for (addr = rmrr_list->entries[i].base; addr < rmrr_list->entries[i].limit; addr += (1ul<<(IA32_4K_bits))) {
                (void)vtd_map_reserved_page;
                vtd_map_reserved_page(vtd_context_table, vtd_get_context_index(rmrr_list->entries[i].device), addr);
            }
        }
    }
}

__attribute__((__section__(".boot.text"))) static bool_t
vtd_enable(cpu_id_t cpu_id)
{
    drhu_id_t i;

    for (i = 0; i < ia32KSnumDrhu; i++) {
        /* Set the Root Table Register */
        vtd_write32(i, 0x20, pptr_to_paddr((void*)ia32KSvtdRootTable));
        vtd_write32(i, 0x20 + 4, 0);

        /* Set SRTP bit in GCMD_REG */
        vtd_write32(i, 0x18, (1 << 30 /* Set Root Table Pointer */));

        /* Wait for SRTP operation to complete by polling
         * RTPS bit from GSTS_REG
         */
        while (!((vtd_read32(i, 0x1C) >> 30 /* Root Table Pointer Status */) & 1));
    }

    /* Globally invalidate context cache of all IOMMUs */
    invalidate_context_cache();

    /* Globally invalidate IOTLB of all IOMMUs */
    invalidate_iotlb();

    for (i = 0; i < ia32KSnumDrhu; i++) {
        uint32_t data, addr;

        data = int_iommu;
        addr = apic_get_base_paddr();
        if (!addr) {
            return false;
        }
        addr |= (cpu_id << 12);

        vtd_process_faults(i);
        vtd_write32(i, 0x38, 0);
        vtd_write32(i, 0x3C, data);
        vtd_write32(i, 0x40, addr);
        vtd_write32(i, 0x44, 0);

        /*flush IOMMU write buffer */
        vtd_write32(i, 0x18, (1ul<<(27)));
        while (((vtd_read32(i, 0x1C) >> 27) & 1));

        kprintf("IOMMU 0x%x: enabling...", i);

        /* Enable the DMA translation by setting TE bit in GCMD_REG */
        vtd_write32(i, 0x18, (1U << 31 /* Translation Enable */));

        /* Wait for Translation Enable operation to complete by polling
         * TES bit from GSTS_REG
         */
        while (!((vtd_read32(i, 0x1C) >> 31 /* Translation Enable Status */) & 1));

        kprintf(" enabled\n");
    }
    return true;
}

__attribute__((__section__(".boot.text"))) bool_t
vtd_init(
    cpu_id_t cpu_id,
    uint32_t num_drhu,
    acpi_rmrr_list_t *rmrr_list
)
{
    drhu_id_t i;
    uint32_t bus;
    uint32_t aw_bitmask = 0xffffffff;
    uint32_t max_num_iopt_levels;
    /* Start the number of domains at 16 bits */
    uint32_t num_domain_id_bits = 16;

    ia32KSnumDrhu = num_drhu;
    ia32KSFirstValidIODomain = 0;

    if (ia32KSnumDrhu == 0) {
        return true;
    }

    for (i = 0; i < ia32KSnumDrhu; i++) {
        uint32_t bits_supported = 4 + 2 * (vtd_read32(i, 0x08) & 7);
        aw_bitmask &= vtd_read32(i, 0x08) >> 8;
        kprintf("IOMMU 0x%x: %d-bit domain IDs supported\n", i, bits_supported);
        if (bits_supported < num_domain_id_bits) {
            num_domain_id_bits = bits_supported;
        }
    }

    ia32KSnumIODomainIDBits = num_domain_id_bits;

    if (aw_bitmask & 0x10) {
        max_num_iopt_levels = 6;
    } else if (aw_bitmask & 0x08) {
        max_num_iopt_levels = 5;
    } else if (aw_bitmask & 0x04) {
        max_num_iopt_levels = 4;
    } else if (aw_bitmask & 0x02) {
        max_num_iopt_levels = 3;
    } else if (aw_bitmask & 0x01) {
        max_num_iopt_levels = 2;
    } else {
        kprintf("IOMMU: mismatch of supported number of PT levels between IOMMUs\n");
        return false;
    }

    if (aw_bitmask & 0x02) {
        ia32KSnumIOPTLevels = 3;
    } else if (aw_bitmask & 0x04) {
        ia32KSnumIOPTLevels = 4;
    } else if (aw_bitmask & 0x08) {
        ia32KSnumIOPTLevels = 5;
    } else if (aw_bitmask & 0x10) {
        ia32KSnumIOPTLevels = 6;
    } else if (aw_bitmask & 0x01) {
        ia32KSnumIOPTLevels = 2;
    } else {
        kprintf("IOMMU: mismatch of supported number of PT levels between IOMMUs\n");
        return false;
    }

    kprintf("IOMMU: Using %d page-table levels (max. supported: %d)\n", ia32KSnumIOPTLevels, max_num_iopt_levels);

    vtd_create_root_table();

    for (bus = 0; bus < 256; bus++) {
        vtd_create_context_table(
            bus,
            max_num_iopt_levels,
            rmrr_list
        );
    }

    flushCacheRange(ia32KSvtdRootTable, 12);

    if (!vtd_enable(cpu_id)) {
        return false;
    }
    return true;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/io.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/boot_sys.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/io.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/kernel/lock.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/io.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/io.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/io.c" 2



static uint16_t get_console_port(void)
{
    if (in_boot_phase()) {
        return console_port_of_node(node_of_cpu(cur_cpu_id()));
    } else {
        return ia32KSconsolePort;
    }
}

void serial_init(uint16_t port)
{
    while (!(in8(port + 5) & 0x60)); /* wait until not busy */

    out8(port + 1, 0x00); /* disable generating interrupts */
    out8(port + 3, 0x80); /* line control register: command: set divisor */
    out8(port, 0x01); /* set low byte of divisor to 0x01 = 115200 baud */
    out8(port + 1, 0x00); /* set high byte of divisor to 0x00 */
    out8(port + 3, 0x03); /* line control register: set 8 bit, no parity, 1 stop bit */
    out8(port + 4, 0x0b); /* modem control register: set DTR/RTS/OUT2 */

    in8(port); /* clear recevier port */
    in8(port + 5); /* clear line status port */
    in8(port + 6); /* clear modem status port */
}

void console_putchar(char c)
{
    uint16_t port = get_console_port();

    lock_acquire(&lock_debug);

    if (port > 0) {
        while (!(in8(port + 5) & 0x60));
        out8(port, c);
        if (c == '\n') {
            while (!(in8(port + 5) & 0x60));
            out8(port, '\r');
        }
    }

    lock_release(&lock_debug);
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/ioapic.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/ioapic.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/pic.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/pic.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/pic.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/pic.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/pic.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/pic.c" 2

/* PIC (i8259) base registers */



/* Program PIC (i8259) to remap IRQs 0-15 to interrupt vectors starting at 'interrupt' */
__attribute__((__section__(".boot.text"))) void
pic_remap_irqs(interrupt_t interrupt)
{
    out8(0x20, 0x11);
    out8(0xa0, 0x11);
    out8(0x20 + 1, interrupt);
    out8(0xa0 + 1, interrupt + 8);
    out8(0x20 + 1, 0x04);
    out8(0xa0 + 1, 0x02);
    out8(0x20 + 1, 0x01);
    out8(0xa0 + 1, 0x01);
    out8(0x20 + 1, 0x0);
    out8(0xa0 + 1, 0x0);
}

__attribute__((__section__(".boot.text"))) void pic_disable(void)
{
    /* We assume that pic_remap_irqs has already been called and
     * just mask all the irqs */
    out8(0x20 + 1, 0xff);
    out8(0xa0 + 1, 0xff);
}



void pic_mask_irq(bool_t mask, irq_t irq)
{
    uint8_t bit_mask;
    uint16_t pic_port;

    if(!(irq >= irq_isa_min)) _assert_fail("irq >= irq_isa_min", "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/pic.c", 51, __FUNCTION__);
    if(!(irq <= irq_isa_max)) _assert_fail("irq <= irq_isa_max", "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/pic.c", 52, __FUNCTION__);

    if (irq < 8) {
        bit_mask = (1ul<<(irq));
        pic_port = 0x20 + 1;
    } else {
        bit_mask = (1ul<<(irq - 8));
        pic_port = 0xa0 + 1;
    }

    if (mask) {
        /* Disables the interrupt */
        out8(pic_port, (in8(pic_port) | bit_mask));
    } else {
        /* Enables the interrupt */
        out8(pic_port, (in8(pic_port) & ~bit_mask));
    }
}

bool_t pic_is_irq_pending(void)
{
    /* Interrupt Request Register (IRR) - holds pending IRQs */
    uint8_t irr;

    /* Send to PIC1's OCW3, in order to read IRR from next inb instruction */
    out8(0x20, 0x0a);

    /* Read IRR */
    irr = in8(0x20);

    /* Since slave PIC is connected to IRQ2 of master PIC,
     * there is no need to check IRR of slave PIC.
     */
    return irr != 0;
}

static uint16_t pic_get_isr(void)
{
    out8(0x20, 0x0b);
    out8(0xa0, 0x0b);
    return (((uint16_t)in8(0xa0)) << 8) | in8(0x20);
}

void pic_ack_active_irq(void)
{
    irq_t irq = getActiveIRQ();
    if (irq >= irq_isa_min + 8) {
        /* ack slave PIC, unless we got a spurious irq 15
         * It is spurious if the bit is not set in the ISR
         * Even if it was spurious we will still need to
         * acknowledge the master PIC */
        if (irq != irq_isa_min + 15 || (pic_get_isr() & (1ul<<(15)))) {
            out8(0xa0, 0x20);
        }
    }
    /* ack master PIC, unless we got a spurious IRQ 7
     * It is spurious if the bit is not set in the ISR */
    if (irq != irq_isa_min + 7 || (pic_get_isr() & (1ul<<(7)))) {
        out8(0x20, 0x20);
    }
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/pit.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/arch/x86/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/pit.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/pit.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/plat/pc99/plat/machine/pit.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/plat/pc99/machine/pit.c" 2

/* PIT (i8253) registers */



/* Count frequency in Hz */


__attribute__((__section__(".phys.text"))) void
pit_init(void)
{
    uint16_t divisor = (1193180 * 50) / 1000;

    out8_phys(0x43, 0x34); /* Set mode 2 and wait for divisor bytes */
    out8_phys(0x40, divisor & 0xff); /* Set low byte of divisor */
    out8_phys(0x40, divisor >> 8); /* Set high byte of divisor */
}

__attribute__((__section__(".phys.text"))) void
pit_wait_wraparound(void)
{
    uint16_t count;
    uint16_t count_old;

    out8_phys(0x43, 0x00);
    count = in8_phys(0x40);
    count |= (in8_phys(0x40) << 8);
    count_old = count;

    while (count <= count_old) {
        count_old = count;
        out8_phys(0x43, 0x00);
        count = in8_phys(0x40);
        count |= (in8_phys(0x40) << 8);
    }
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/string.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/string.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/string.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/string.c" 2



unsigned int strnlen(const char *s, unsigned int maxlen)
{
    unsigned int len;
    for (len = 0; len < maxlen && s[len]; len++);
    return len;
}

unsigned int strlcpy(char *dest, const char *src, unsigned int size)
{
    unsigned int len;
    for (len = 0; len + 1 < size && src[len]; len++) {
        dest[len] = src[len];
    }
    dest[len] = '\0';
    return len;
}

unsigned int strlcat(char *dest, const char *src, unsigned int size)
{
    unsigned int len;
    /* get to the end of dest */
    for (len = 0; len < size && dest[len]; len++);
    /* check that dest was at least 'size' length to prevent inserting
     * a null byte when we shouldn't */
    if (len < size) {
        for (; len + 1 < size && *src; len++, src++) {
            dest[len] = *src;
        }
        dest[len] = '\0';
    }
    return len;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/util.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/util.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/util.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/kq/Sources/RefOS_x86/kernel/src/util.c" 2

/*
 * Zero 'n' bytes of memory starting from 's'.
 *
 * 'n' and 's' must be word aligned.
 */
void
memzero(void *s, unsigned int n)
{
    uint8_t *p = s;

    /* Ensure alignment constraints are met. */
    if(!((unsigned int)s % 4 == 0)) _assert_fail("(unsigned int)s % 4 == 0", "/home/kq/Sources/RefOS_x86/kernel/src/util.c", 26, __FUNCTION__);
    if(!(n % 4 == 0)) _assert_fail("n % 4 == 0", "/home/kq/Sources/RefOS_x86/kernel/src/util.c", 27, __FUNCTION__);

    /* We will never memzero an area larger than the largest current
       live object */
    /** GHOSTUPD: "(gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state = 0
        \<or> \<acute>n <= gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state, id)" */

    /* Write out words. */
    while (n != 0) {
        *(uint32_t *)p = 0;
        p += 4;
        n -= 4;
    }
}

void*
memset(void *s, unsigned int c, unsigned int n)
{
    uint8_t *p;

    /*
     * If we are only writing zeros and we are word aligned, we can
     * use the optimized 'memzero' function.
     */
    if (__builtin_expect(!!(c == 0 && ((uint32_t)s % 4) == 0 && (n % 4) == 0), 1)) {
        memzero(s, n);
    } else {
        /* Otherwise, we use a slower, simple memset. */
        for (p = (uint8_t *)s; n > 0; n--, p++) {
            *p = (uint8_t)c;
        }
    }

    return s;
}

void*
memcpy(void* ptr_dst, const void* ptr_src, unsigned int n)
{
    uint8_t *p;
    const uint8_t *q;

    for (p = (uint8_t *)ptr_dst, q = (const uint8_t *)ptr_src; n; n--, p++, q++) {
        *p = *q;
    }

    return ptr_dst;
}

int
strncmp(const char* s1, const char* s2, int n)
{
    unsigned int i;
    int diff;

    for (i = 0; i < n; i++) {
        diff = ((unsigned char*)s1)[i] - ((unsigned char*)s2)[i];
        if (diff != 0 || s1[i] == '\0') {
            return diff;
        }
    }

    return 0;
}

int __attribute__((__const__))
char_to_int(char c)
{
    if (c >= '0' && c <= '9') {
        return c - '0';
    } else if (c >= 'A' && c <= 'F') {
        return c - 'A' + 10;
    } else if (c >= 'a' && c <= 'f') {
        return c - 'a' + 10;
    }
    return -1;
}

int __attribute__((__pure__))
str_to_int(const char* str)
{
    unsigned int base;
    int res;
    int val = 0;
    char c;

    /*check for "0x" */
    if (*str == '0' && (*(str + 1) == 'x' || *(str + 1) == 'X')) {
        base = 16;
        str += 2;
    } else {
        base = 10;
    }

    if (!*str) {
        return -1;
    }

    c = *str;
    while (c != '\0') {
        res = char_to_int(c);
        if (res == -1 || res >= base) {
            return -1;
        }
        val = val * base + res;
        str++;
        c = *str;
    }

    return val;
}
# 1 "/home/kq/Sources/RefOS_x86/kernel/src/config/default_domain.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/kq/Sources/RefOS_x86/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/kq/Sources/RefOS_x86/kernel/src/config/default_domain.c" 2
# 1 "/home/kq/Sources/RefOS_x86/kernel/include/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/kq/Sources/RefOS_x86/kernel/src/config/default_domain.c" 2

/* Default schedule. */
const dschedule_t ksDomSchedule[] = {
    { .domain = 0, .length = 1 },
};

const unsigned int ksDomScheduleLength = sizeof(ksDomSchedule) / sizeof(dschedule_t);
